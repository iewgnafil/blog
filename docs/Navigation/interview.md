---
# date是手动设置此篇文章编写的时间
date: "2022/2/4 11:08"

# 手动设置此篇文章封面
coverUrl: "http://cdn-ali-img-shstaticbz.shanhutech.cn/bizhi/staticwp/202111/bf510fc53ed6ffc5c5a215992c7c8f60--761544518.jpg"

# 是否置顶
sticky: true

# 设置keyword 多个以,分开
keyword: 面试表达

# 设置description
description: interview expression

# 手动设置标题，否则使用h1标签作为标题
title: interview-1

# 这是设置标签，数组形式
tag: [笔记]

# 这里设置类别，数组形式
categories: [面试表达]
---
## 一、事件循环
> Javascript是一门单线程语言，只有前一个任务执行完毕才会运行下一个任务，为了规避掉资源分配的浪费，所以将Javascript的任务分为同步任务和异步任务 
>
> > 异步任务又分为宏任务和微任务
### EventLoop
> 先执行同步操作，异步操作排在事件队列里
1. 先判断是同步还是异步，同步任务进入主线程，异步任务进入Event Table(任务队列)
2. 异步任务在Event Table中注册事件，当满足促发条件的时候，会被推入到Event Queue(事件队列)
3. 主线程空闲时，才会在Event Queue中看是否又需要执行的异步任务，如果有，就推入主线程中执行
>异步任务执行顺序为先执行微任务，在执行宏任务

---

## 二、this是什么
  当一个函数被调用时,会创建一个执行上下文,这个执行上下文包含函数在哪里调用(调用栈),函数的调用方法,传入的参数等,**this**就是用来记录当前这个执行上下文信息的一个属性
### 关于this指针的指向问题
1. **this**始终会指向一个对象,是根据函数的执行环境来决定的,函数作为一个对象的方法被调用的话,**this**就指向这个对象
2. 如果是new的话,**this**就指向new出来的这个实例化对象
3. 因为匿名函数和自执行函数的执行环境具有全局性,所以它的this一般指向window
4. 箭头函数没有自己的this,它里面的**this**的指向跟外部作用域中**this**指向一致

---

## 三、闭包相关问题
> 当内部函数被保存到外部时,将会产生闭包

***定义***:在JavaScript中,根据词法作用域的规则,内部函数总是可以访问其外部函数中申明的变量,当通过调用一个外部函数返回一个内部函数后,即使该外部函数已经执行结束,但是内部函数引用外部函数的变量,依然保存在内存中,我们把这些变量的集合称为闭包

***缺点***:闭包会导致原有的作用域链不释放,造成内存泄漏\
***优点***:
1. 实现公有化变量 (企业的模块开发) 
2. 做缓存 
3. 实现属性的私有化
4. 模块化开发，防止污染全局变量
> 变量长期驻扎在内存中,避免全局变量的污染,私有成员的存在

---

## 四、vue的生命周期

>Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、销毁等一系列过程，我们称这是Vue的生命周期。通俗说就是Vue实例从创建到销毁的过程，就是生命周期。

每一个组件或者实例都会经历一个完整的生命周期，总共分为三个阶段：初始化、运行中、销毁。
1. 实例、组件通过new Vue() 创建出来之后会初始化事件和生命周期，然后就会执行**beforeCreate**钩子函数，这个时候，数据还没有挂载呢，只是一个空壳，无法访问到数据和真实的dom，一般不做操作
2. 挂载数据，绑定事件等等，然后执行**created**函数，这个时候已经可以使用到数据，也可以更改数据,在这里更改数据不会触发updated函数，在这里可以在渲染前倒数第二次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取
3. 接下来开始找实例或者组件对应的模板，编译模板为虚拟dom放入到render函数中准备渲染，然后执行**beforeMount**钩子函数，在这个函数中虚拟dom已经创建完成，马上就要渲染,在这里也可以更改数据，不会触发**updated**，在这里可以在渲染前最后一次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取
4. 接下来开始render，渲染出真实dom，然后执行**mounted**钩子函数，此时，组件已经出现在页面中，数据、真实dom都已经处理好了,事件都已经挂载好了，可以在这里操作真实dom等事情...
5. 当组件或实例的数据更改之后，会立即执行**beforeUpdate**，然后vue的虚拟dom机制会重新构建虚拟dom与上一次的虚拟dom树利用diff算法进行对比之后重新渲染，一般不做什么事儿
6. 当更新完成后，执行**updated**，数据已经更改完成，dom也重新render完成，可以操作更新后的虚拟dom
7. 当经过某种途径调用$destroy方法后，立即执行**beforeDestroy**，一般在这里做一些善后工作，例如清除计时器、清除非指令绑定的事件等等
8. 组件的数据绑定、监听...去掉后只剩下dom空壳，这个时候，执行**destroyed**，在这里做善后工作也可以

---

## 五、web前端开发技术的优化策略
[web前端开发技术的优化策略](https://blog.csdn.net/smell201611010513/article/details/103784242)
1. 减少HTTP请求数
2. 优化文件的规模
3. 减少DNS查找
4. 杜绝无用响应
5. 有效避免重定向
6. 优化网页内容

### 减少页面加载时间的方式
1. 优化图片 
2. 图像格式的选择（GIF：提供的颜色较少，可用在一些对颜色要求不高的地方） 
3. 优化CSS（压缩合并css，如 margin-top, margin-left...) 
4. 网址后加斜杠（如www.campr.com/目录，会判断这个目录是什么文件类型，或者是目录。） 
5. cdn托管 
6. 标明高度和宽度（如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小，如果图片很多，浏览器需要不断地调整页面。这不但影响速度，也影响浏览体验。\
当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加 载后面的内容。从而加载时间快了，浏览体验也更好了）
7. 减少http请求（合并文件，合并图片）

---
## 六、回流和重绘
**回流**：当render tree中的一部分或者全部因为元素的规模尺寸，布局，隐藏等改变而需要重新构建，这就叫回流
>每个页面至少需要一次回流，就是在页面第一次加载的时候，这时候一定会发生回流，因为要构建render tree

**重绘**:在回流的时候，浏览器会使渲染树中收到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏 览器会重新绘制受影响的部分到屏幕中，这就是重绘
>当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，不会影响布局，就叫重绘

### 何时发生回流重绘
- 回流这一阶段主要是计算节点的位置和几何信息，那么当页面布局和几何信息发生变化的时候，就需要回流。比如以下情况：
- 添加或删除可见的DOM元素
- 元素的位置发生变化
- 元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）
- 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。
- 页面一开始渲染的时候（这肯定避免不了）
- 浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）

**注意：回流一定会触发重绘，而重绘不一定会回流**

### 减少重排重绘的方法
[减少重排重绘的方法](https://github.com/chenjigeng/blog/issues/4)
### 浏览器的优化机制
目前大多数浏览器，都会通过队列化来批量的修改重排的过程，浏览器会将修改操作放到队列中，直到一段时间后，队列的存储达到阈值，才会一次性全部重排，清空队列；**但是！当你获取布局信息的操作的时候，会强制队列刷新**
- offsetTop、offsetLeft、offsetWidth、offsetHeight
- scrollTop、scrollLeft、scrollWidth、scrollHeight
- clientTop、clientLeft、clientWidth、clientHeight
- getComputedStyle()
- getBoundingClientRect
>以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。因此，我们在修改样式的时候，**最好避免使用上面列出的属性，他们都会刷新渲染队列**如果要使用它们，最好将值缓存起来。

---

## 七、常见的HTTP状态码

### 状态码分类：

| 分类      | 	分类描述                                       |
| --------- | ------------------------------------------- |
| 1**       | 信息，服务器收到请求，需要请求者继续执行操作    |
| 2**       | 成功，操作被成功接收并处理                     |
| 3**       | 重定向，需要进一步的操作以完成请求              |
| 4**       | 客户端错误，请求包含语法错误或无法完成请求       |
| 5**       | 服务器错误，服务器在处理请求的过程中发生了错误   |


### 常见的HTTP状态码列表:
| 状态码 |     描述                                      |
| --------- | ------------------------------------------- |
| ***100*** | 这个状态码告诉客户应该继续发送请求，这个临时响应是用来通知客户端的，部分的请求服务器已经接受，但是客户端应该继续发送请求的剩余部分，如果请求已经完成，就忽略这个响应，而且服务器会在请求完成后向客户发送一个最终的结果。|
| ***200*** | 这个是最常见的http状态码，表示服务器已经成功接受请求，并将返回客户端所请求的最终结果。|
| ***202*** | 表示服务器已经接受了请求，但是还没有处理，而且这个请求最终会不会处理还不确定。|
| ***204*** | 服务器成功处理了请求，但没有返回任何实体内容，可能会返回新的头部元信息。|
| ***301*** | 客户端请求的页面已经永久移动到新的位置，当链接发生变化时，返回301代码告诉客户端连接的变化，客户端保存新的链接，并向新的链接发出请求，已返回请求结果。|
| ***404*** | 请求失败，客户端请求的资源没有找到或者是不存在。|
| ***500*** | 服务器遇到未知的错误，导致无法完成客户端当前的请求。|
| ***503*** | 服务器由于临时的服务器过载或者是维护，无法解决当前的请求。|

[参考](https://www.runoob.com/http/http-status-codes.html)


---

## 八、Ajax如何使用
一个完整的AJAX请求包括五个步骤：
具体来说，AJAX 包括以下几个步骤。

1. 创建 XMLHttpRequest 对象，也就是创建一个异步调用对象

2. 创建一个新的 HTTP 请求，并指定该 HTTP 请求的方法、URL 及验证信息

3. 设置响应 HTTP 请求状态变化的函数

4. 发送 HTTP 请求

5. 获取异步调用返回的数据

6. 使用 JavaScript 和 DOM 实现局部刷新


```js
// 创建可以请求的实例对象
var myAjax = new XMLHttpRequest()
// 设置请求的url参数，这是准备工作
myAjax.open('GET', 'https://autumnfish.cn/search?keywords="我们俩"' )
// 发送请求
myAjax.send()
// 接收
myAjax.onreadystatechange = function() {
  if (myAjax.readyState == 4 && myAjax.status == 200) {
    console.log(JSON.parse(myAjax.responseText));  // JSON将字符串转换为对象
  }
}
```
[参考链接](https://juejin.cn/post/6992525007716876325#heading-54)


---

## 九、下面代码中 a 在什么情况下会打印 1？
```js
var a = ?;
if(a == 1 && a == 2 && a == 3){
 	conso.log(1);
}
```
>答案解析 因为==会进行隐式类型转换 所以我们重写toString方法就可以了
```js
var a = {
  i: 1,
  toString() {
    return a.i++;
  }
}

if( a == 1 && a == 2 && a == 3 ) {
  console.log(1);
}
```

---

## 十、介绍下 BFC 及其应用

BFC 就是块级格式上下文，是页面盒模型布局中的一种 CSS 渲染模式，相当于一个独立的容器，里面的元素和外部的元素相互不影响。\
创建BFC 的方式有：

下列方式会创建块格式化上下文：

- html根元素（）

- float浮动（元素的 float 不是 none）

- 绝对定位元素（元素的 position 为 absolute 或 fixed）

- 行内块元素（元素的 display 为 inline-block）

- display 为表格布局、弹性元素（flex、inline-flex）、网格元素（grid、inline-grid）

- overflow 计算值(Computed)不为 visible 的块元素
- 等。。。

BFC 主要的作用是：
1. 清除浮动
3. 防止同一 BFC 容器中的相邻元素间的外边距重叠问题

BFC特性:
- BFC元素的垂直方向上会发生边距重叠。

- BFC元素和浮动元素不会发生重叠。

- BFC在计算高度时会把浮动元素计算进去。

- BFC在页面是个独立的容器，里外元素互不影响。

--- 

## 十一、对sort()的理解
>使用 sort() 对数组 [3, 15, 8, 29, 102, 22] 进行排序，输出结果

答案:**[102, 15, 22, 29, 3, 8]**

解析:
>根据MDN上对Array.sort()的解释，***默认的排序方法会将数组元素转换为字符串，然后比较字符串中字符的UTF-16编码顺序来进行排序***。所以'102' 会排在 '15' 前面。

如果要对数值进行升序排列：
```js
[3, 15, 8, 29, 102, 22].sort((a, b) => a - b) 
// [3, 8, 15, 22, 29, 102]
```

---

## 十二、call、apply、bind的区别
作用：
> 改变函数执行时的上下文,其中call和apply是立即调用的
1. cal、apply、bind必须通过函数来调用，第一个参数为对象，若第一个参数为null或者undefined，则指向window
2. call和bind方法可以接收多个参数，apply方法只能接收2个参数，且第二个参数为数组或者伪数组
3. call、apply、bind方法的调用：
    1. call和apply方法没有返回值（即返回undefined）
    2. bind方法返回一个原函数的拷贝，并具有指定的this值和初始参数
4. call、apply、bind方法的调用：
    1. call和apply是立即执行的 
    2. bind返回值是一个函数，需要稍后再调用一下，才会执行。

[参考](参考：https://segmentfault.com/a/1190000018017796)

---

## 十三、分析比较 opacity: 0、visibility: hidden、display: none 优劣和适用场景。

总结一下：\
***结构***：
- display:none: 会让元素完全从渲染树中消失，渲染的时候不占据任何空间, 不能点击，
- visibility: hidden:不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，不能点击
- opacity: 0: 不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，可以点击

***继承***：
- display: none和opacity: 0：是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示。
- visibility: hidden：是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显式。

***性能***：
- displaynone : 修改元素会造成文档回流,读屏器不会读取display: none元素内容，性能消耗较大
- visibility:hidden: 修改元素只会造成本元素的重绘,性能消耗较少读屏器读取visibility: hidden元素内容
- opacity: 0 ： 修改元素会造成重绘，性能消耗较少

***联系***：它们都能让元素不可见

[参考](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/100)

---

## 十四、ES6 代码转成 ES5 代码的实现思路是什么
Babel 是如何把 ES6 转成 ES5 呢\
其大致分为三步：
1. 将代码字符串解析成抽象语法树，即所谓的 AST
2. 对 AST 进行处理，在这个阶段可以对 ES6 代码进行相应转换，即转成 ES5 代码
3. 根据处理后的 AST 再生成代码字符串

>将ES6的代码转换为AST语法树，然后再将ES6 AST转为ES5 AST，再将AST转为代码

--- 

## 十五、数组里面有10万个数据，取第一个元素和第10万个元素的时间相差多少

1. 脚本里面的数组不是真正的数组，用的Hash算法，所以读取时间是一致的；
2. 即便真正的数组，读取时间也是一致的，连续内存直接读就好了；
3. 只有对单向链表才有差异；

---

## 十六、Vue 的父组件和子组件生命周期钩子执行顺序是什么

1. 加载渲染过程\
**父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted**
2. 子组件更新过程\
**父beforeUpdate->子beforeUpdate->子updated->父updated**
3. 父组件更新过程\
**父beforeUpdate->父updated**
4. 销毁过程\
**父beforeDestroy->子beforeDestroy->子destroyed->父destroyed**

***总结***：从外到内，再从内到外

---

## 十七、import导入的模块
> import导入的模块是只读的：您不能修改导入的模块。只有导出它们的模块才能更改其值

[例题](https://github.com/lydiahallie/javascript-questions#57-whats-the-output)

---

## 十八、var、let 和 const 

- **var**的话会直接在栈内存里预分配内存空间，然后等到实际语句执行的时候，再存储对应的变量，如果传的是引用类型，那么会在堆内存里开辟一个内存空间存储实际内容，栈内存会存储一个指向堆内存的指针

- **let**的话，是不会在栈内存里预分配内存空间，而且在栈内存分配变量时，做一个检查，如果已经有相同变量名存在就会报错

- **const**的话，也不会预分配内存空间，在栈内存分配变量时也会做同样的检查。不过const存储的变量是不可修改的，对于基本类型来说你无法修改定义的值，对于引用类型来说你无法修改栈内存里分配的指针，但是你可以修改指针指向的对象里面的属性

---

## 十九、 Object.steal()和Object.freezze()
1. O**bject.steal()**
    1. 防止对象添加新属性或删除现有属性

    2. 但仍可以修改现有属性的值

[例题](https://github.com/lydiahallie/javascript-questions#136-which-of-the-following-will-modify-the-person-object)


2. **Object.freeze()**
    1. 冻结一个对象，不可添加、修改、删除任何属性

    2. 但只是浅冻结对象，只是对对象的直接属性进行了冻结，若属性中又另一个对象，则可对这个对象进行修改

[例题](https://github.com/lydiahallie/javascript-questions#137-which-of-the-following-will-modify-the-person-object)



---

<div style="font-weight:700; text-align:center; padding-top:20px;">最后更新时间：2022.02.12</div>