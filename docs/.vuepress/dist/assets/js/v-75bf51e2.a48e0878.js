"use strict";(self.webpackChunkIEWGANFIL=self.webpackChunkIEWGANFIL||[]).push([[628],{2735:(e,s,a)=>{a.r(s),a.d(s,{data:()=>t});const t={key:"v-75bf51e2",path:"/study/study4.html",title:"跨域",lang:"zh-CN",frontmatter:{date:"2022/1/21 20:23",coverUrl:"http://cdn-ali-img-shstaticbz.shanhutech.cn/bizhi/staticwp/202201/ec75de816ec1a1e965b9604a936e5c3e--333631415.jpg",sticky:!0,keyword:"跨域,jsonp,cros,postMessage",description:"跨域",title:"跨域",tag:["跨域","面试题"],categories:["跨域"]},excerpt:"",headers:[{level:2,title:"常见的跨域场景",slug:"常见的跨域场景",children:[]},{level:2,title:"特别说明",slug:"特别说明",children:[]},{level:2,title:"跨域的解决方案",slug:"跨域的解决方案",children:[{level:3,title:"1. jsonp",slug:"_1-jsonp",children:[]},{level:3,title:"2. cors",slug:"_2-cors",children:[]},{level:3,title:"3. postMessage",slug:"_3-postmessage",children:[]}]}],git:{updatedTime:16427402e5,contributors:[{name:"iewgnafil",email:"1519467168@qq.com",commits:1}]}}},3190:(e,s,a)=>{a.r(s),a.d(s,{default:()=>l});const t=(0,a(6252).uE)('<h1 id="什么是跨域" tabindex="-1"><a class="header-anchor" href="#什么是跨域" aria-hidden="true">#</a> 什么是跨域</h1><p>浏览器都具有同源策略 --- 协议 + 域名 + 端口 都相同</p><p>http:// www . abc.com : 8080 / detail <br> 协议 子域名 主域名 端口 请求资源地址</p><ul><li><p>同源策略限制了ajax请求</p></li><li><p>没有被同源策略所影响的三个标签</p></li></ul><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>  <span class="token operator">&lt;</span>img src<span class="token operator">=</span>&quot;xxx<span class="token operator">&gt;</span> \n  <span class="token operator">&lt;</span>link href<span class="token operator">=</span>&quot;xxx<span class="token operator">&gt;</span>\n  <span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">&quot;xxx&quot;</span><span class="token operator">&gt;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="常见的跨域场景" tabindex="-1"><a class="header-anchor" href="#常见的跨域场景" aria-hidden="true">#</a> 常见的跨域场景</h2><p>http://www.a.com/a.js <br> http://www.a.com/b.js 同一个域名，允许通信</p><p>http://www.a.com/a.js <br> https://www.a.com/a.js 协议不同，跨域</p><p>http://www.a.com/a.js <br> http://script.a.com/a.js 主域相同，子域不相同，跨域</p><h2 id="特别说明" tabindex="-1"><a class="header-anchor" href="#特别说明" aria-hidden="true">#</a> 特别说明</h2><ol><li>如果是端口和协议照成的跨域，前端是没有办法解决的</li><li>跨域仅仅只是根据url的首部 来识别，不会根据这个首部对应得ip地址来判断</li><li>跨域并不是请求没有发出去，请求时能发出去得，服务器也是能响应的，只是响应结果被浏览器拦截了</li></ol><h2 id="跨域的解决方案" tabindex="-1"><a class="header-anchor" href="#跨域的解决方案" aria-hidden="true">#</a> 跨域的解决方案</h2><h3 id="_1-jsonp" tabindex="-1"><a class="header-anchor" href="#_1-jsonp" aria-hidden="true">#</a> 1. jsonp</h3><p>原理：<strong>利用script标签上的src属性不会被同源的策略所拦截的这一机制</strong>，将我们要请求的url地址，添加到script的src属性中，且携带上前端全局下的函数名作为参数给到后端，后端获取到前端传递的函数名，然后返回该函数的调用语法，将要返回的数据放在该函数的调用中作为参数，当浏览器接收到全局下的函数被调用的后端响应，会自动执行该函数，从而从参数中获取到后端返回的数据</p><p>缺点：</p><ol><li>需要对方的服务器做支持才可以</li><li>只支持<strong>get</strong> 请求，有局限性，可能会遭到 <strong>XSS攻击</strong></li></ol><h3 id="_2-cors" tabindex="-1"><a class="header-anchor" href="#_2-cors" aria-hidden="true">#</a> 2. cors</h3><p>cors是W3C的标准，它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求。也就是说浏览器发请求是不会被跨域的，跨域的核心是后端响应不了。</p><blockquote><p>要让后端响应内容能够补被浏览器拦截，关键在于后端。如果后端也能遵从CorS标准的话，后端的响应也可以跨源.</p></blockquote><p>分为简单请求和复杂请求两种：</p><ul><li><p>简单请求<br> . 使用GET、POST、HEAD <br> . Content-Type的值仅限于:<strong>text/plain || multipart/from-data || application/x-www-from-urlencoded</strong></p></li><li><p>复杂请求<br> . 不满足简单请求的条件的就是复杂请求<br> . 复杂请求的cors请求，会在正式通信之前，增加一次http查询请求，称为&quot;预检&quot;，预检是用来知道服务端是都允许跨域请求，预检请求发的是options方法</p></li></ul><h3 id="_3-postmessage" tabindex="-1"><a class="header-anchor" href="#_3-postmessage" aria-hidden="true">#</a> 3. postMessage</h3><p>html5中的 xhr 提供的API，postMessage()方法允许来自不同源的脚本采用异步的方法进行有限通信，可以实现跨文本，多窗口，跨域消息传递 <br> 可以解决这么几个问题：</p><ul><li>页面和其他新的窗口的数据传递</li><li>多窗口之间的消息传递</li><li>页面与嵌套的iframe消息传递</li><li>上面三个场景的跨域数据传递</li></ul><p>otherWindow.postMessage(message, targrtOrigin, [transfer])</p><ul><li>message: 要发送给其他window的数据</li><li>targetOrigin: 目标窗口</li><li>transfer(可选)和message一起传递的一个对象，这个对象的所有权限将移交给消息接收方</li></ul><p>缺点: <strong>场景比较简单</strong></p>',27),r={},l=(0,a(3744).Z)(r,[["render",function(e,s){return t}]])}}]);