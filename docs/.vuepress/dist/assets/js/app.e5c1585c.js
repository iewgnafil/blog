"use strict";(self.webpackChunkIEWGANFIL=self.webpackChunkIEWGANFIL||[]).push([[143],{6396:(n,a,s)=>{s.d(a,{g:()=>d});var e=s(7478),t=s(5748),p=s(1598),o=s(1341),r=s(1843),l=s(6911),c=s(881),i=s(9146);const u=(0,s(7621).vW)((({app:n,router:a,siteData:s})=>{})),d=[e.Z,t.Z,p.Z,o.Z,r.Z,l.Z,c.Z,i.Z,u]},9947:(n,a,s)=>{s.d(a,{p:()=>p});var e=s(3051),t=s(8805);const p=[e.Z,t.Z]},4611:(n,a,s)=>{s.d(a,{l:()=>o});var e=s(1263),t=s(6243),p=s(7593);const o=[e.Z,t.Z,p.Z]},4150:(n,a,s)=>{s.d(a,{Z:()=>t});var e=s(6252);const t={404:(0,e.RC)((()=>Promise.all([s.e(973),s.e(431)]).then(s.bind(s,2431)))),Layout:(0,e.RC)((()=>s.e(887).then(s.bind(s,8887))))}},6056:(n,a,s)=>{s.d(a,{b:()=>t});var e=s(6252);const t={"v-245bbacd":(0,e.RC)((()=>s.e(685).then(s.bind(s,7802)))),"v-3f77dce2":(0,e.RC)((()=>s.e(462).then(s.bind(s,5257)))),"v-39cc4c5a":(0,e.RC)((()=>s.e(406).then(s.bind(s,70)))),"v-0359f486":(0,e.RC)((()=>s.e(207).then(s.bind(s,4754)))),"v-d40e49ba":(0,e.RC)((()=>s.e(549).then(s.bind(s,5303)))),"v-af0475ae":(0,e.RC)((()=>s.e(75).then(s.bind(s,7065)))),"v-7ffc659c":(0,e.RC)((()=>s.e(529).then(s.bind(s,5107)))),"v-7c92b45e":(0,e.RC)((()=>s.e(459).then(s.bind(s,4272)))),"v-79290320":(0,e.RC)((()=>s.e(271).then(s.bind(s,1479)))),"v-75bf51e2":(0,e.RC)((()=>s.e(628).then(s.bind(s,5055)))),"v-3706649a":(0,e.RC)((()=>s.e(88).then(s.bind(s,8109)))),"v-8daa1a0e":(0,e.RC)((()=>s.e(509).then(s.bind(s,1829)))),"v-74bc627b":(0,e.RC)((()=>s.e(5).then(s.bind(s,9085)))),"v-14f724bf":(0,e.RC)((()=>s.e(69).then(s.bind(s,8784)))),"v-14e6501c":(0,e.RC)((()=>s.e(713).then(s.bind(s,779)))),"v-744d024e":(0,e.RC)((()=>s.e(146).then(s.bind(s,7034)))),"v-705c21a6":(0,e.RC)((()=>s.e(888).then(s.bind(s,8099)))),"v-6629f178":(0,e.RC)((()=>s.e(158).then(s.bind(s,7984)))),"v-f693f690":(0,e.RC)((()=>s.e(516).then(s.bind(s,2209)))),"v-e2acc714":(0,e.RC)((()=>s.e(356).then(s.bind(s,5506)))),"v-3c506944":(0,e.RC)((()=>s.e(219).then(s.bind(s,5455)))),"v-3279cf61":(0,e.RC)((()=>s.e(118).then(s.bind(s,1973))))}},9706:(n,a,s)=>{s.d(a,{T:()=>e});const e={"v-245bbacd":()=>s.e(685).then(s.bind(s,7018)).then((({data:n})=>n)),"v-3f77dce2":()=>s.e(462).then(s.bind(s,9261)).then((({data:n})=>n)),"v-39cc4c5a":()=>s.e(406).then(s.bind(s,5527)).then((({data:n})=>n)),"v-0359f486":()=>s.e(207).then(s.bind(s,8796)).then((({data:n})=>n)),"v-d40e49ba":()=>s.e(549).then(s.bind(s,3365)).then((({data:n})=>n)),"v-af0475ae":()=>s.e(75).then(s.bind(s,3570)).then((({data:n})=>n)),"v-7ffc659c":()=>s.e(529).then(s.bind(s,3573)).then((({data:n})=>n)),"v-7c92b45e":()=>s.e(459).then(s.bind(s,6676)).then((({data:n})=>n)),"v-79290320":()=>s.e(271).then(s.bind(s,3805)).then((({data:n})=>n)),"v-75bf51e2":()=>s.e(628).then(s.bind(s,2735)).then((({data:n})=>n)),"v-3706649a":()=>s.e(88).then(s.bind(s,1801)).then((({data:n})=>n)),"v-8daa1a0e":()=>s.e(509).then(s.bind(s,6464)).then((({data:n})=>n)),"v-74bc627b":()=>s.e(5).then(s.bind(s,2988)).then((({data:n})=>n)),"v-14f724bf":()=>s.e(69).then(s.bind(s,4770)).then((({data:n})=>n)),"v-14e6501c":()=>s.e(713).then(s.bind(s,4502)).then((({data:n})=>n)),"v-744d024e":()=>s.e(146).then(s.bind(s,6041)).then((({data:n})=>n)),"v-705c21a6":()=>s.e(888).then(s.bind(s,6762)).then((({data:n})=>n)),"v-6629f178":()=>s.e(158).then(s.bind(s,4141)).then((({data:n})=>n)),"v-f693f690":()=>s.e(516).then(s.bind(s,1442)).then((({data:n})=>n)),"v-e2acc714":()=>s.e(356).then(s.bind(s,6790)).then((({data:n})=>n)),"v-3c506944":()=>s.e(219).then(s.bind(s,3350)).then((({data:n})=>n)),"v-3279cf61":()=>s.e(118).then(s.bind(s,8588)).then((({data:n})=>n))}},4634:(n,a,s)=>{s.d(a,{g:()=>t});var e=s(4802);const t=[["v-245bbacd","/how-to-write-article.html",{},["/how-to-write-article","/how-to-write-article.md"]],["v-3f77dce2","/JS/%E5%8E%9F%E7%94%9FJS.html",{},["/JS/原生JS.html","/JS/%E5%8E%9F%E7%94%9FJS","/JS/原生JS.md","/JS/%E5%8E%9F%E7%94%9FJS.md"]],["v-39cc4c5a","/Navigation/interview.html",{},["/Navigation/interview","/Navigation/interview.md"]],["v-0359f486","/Navigation/interview2.html",{},["/Navigation/interview2","/Navigation/interview2.md"]],["v-d40e49ba","/Navigation/navigation.html",{},["/Navigation/navigation","/Navigation/navigation.md"]],["v-af0475ae","/Navigation/PDF.html",{},["/Navigation/PDF","/Navigation/PDF.md"]],["v-7ffc659c","/study/study1.html",{},["/study/study1","/study/study1.md"]],["v-7c92b45e","/study/study2.html",{},["/study/study2","/study/study2.md"]],["v-79290320","/study/study3.html",{},["/study/study3","/study/study3.md"]],["v-75bf51e2","/study/study4.html",{},["/study/study4","/study/study4.md"]],["v-3706649a","/404.html",{},["/404"]],["v-8daa1a0e","/",{},["/index.html"]],["v-74bc627b","/about/",{},["/about/index.html"]],["v-14f724bf","/mood/",{},["/mood/index.html"]],["v-14e6501c","/link/",{},["/link/index.html"]],["v-744d024e","/tag/",{},["/tag/index.html"]],["v-705c21a6","/archive/",{},["/archive/index.html"]],["v-6629f178","/aurora-coze/",{},["/aurora-coze/index.html"]],["v-f693f690","/aurora-register/",{},["/aurora-register/index.html"]],["v-e2acc714","/photo/",{},["/photo/index.html"]],["v-3c506944","/aurora-music/",{},["/aurora-music/index.html"]],["v-3279cf61","/aurora-archive/",{},["/aurora-archive/index.html"]]].reduce(((n,[a,s,t,p])=>(n.push({name:a,path:s,component:e.Y,meta:t},...p.map((n=>({path:n,redirect:s})))),n)),[{name:"404",path:"/:catchAll(.*)",component:e.Y}])},5472:(n,a,s)=>{s.d(a,{D:()=>e});const e=[{title:"JavaScript数据类型的相关问题看这篇文章就够了",headers:[{level:2,title:"了解强、弱类型和动态、静态类型语言",slug:"了解强、弱类型和动态、静态类型语言",children:[{level:3,title:"强类型",slug:"强类型",children:[]},{level:3,title:"弱类型",slug:"弱类型",children:[]},{level:3,title:"静态类型",slug:"静态类型",children:[]},{level:3,title:"动态类型",slug:"动态类型",children:[]}]},{level:2,title:"基本数据类型",slug:"基本数据类型",children:[]},{level:2,title:"引用数据类型",slug:"引用数据类型",children:[{level:3,title:"引用类型的检索",slug:"引用类型的检索",children:[]}]},{level:2,title:"拓展：深浅拷贝",slug:"拓展-深浅拷贝",children:[{level:3,title:"手写方法实现深拷贝：",slug:"手写方法实现深拷贝",children:[]}]},{level:2,title:"typeof方法",slug:"typeof方法",children:[]},{level:2,title:"拓展：为什么null返回的是一个object呢？",slug:"拓展-为什么null返回的是一个object呢",children:[]},{level:2,title:"instanceof方法",slug:"instanceof方法",children:[]}],path:"/how-to-write-article.html",pathLocale:"/",extraFields:[]},{title:"原生JavaScript灵魂拷问",headers:[{level:2,title:"前言",slug:"前言",children:[]},{level:2,title:"JS类型之问——概念与检测篇",slug:"js类型之问——概念与检测篇",children:[{level:3,title:"1.JS中的数据类型有哪些？",slug:"_1-js中的数据类型有哪些",children:[]},{level:3,title:"2.你真的懂typeof吗？",slug:"_2-你真的懂typeof吗",children:[]},{level:3,title:"3.什么是instanceof？你能模拟实现一个instanceof吗？",slug:"_3-什么是instanceof-你能模拟实现一个instanceof吗",children:[]},{level:3,title:"4.如何区分数组与对象？使用instanceof判断数组可靠吗？",slug:"_4-如何区分数组与对象-使用instanceof判断数组可靠吗",children:[]},{level:3,title:"5.如何判断一个数是否为NaN？",slug:"_5-如何判断一个数是否为nan",children:[]},{level:3,title:"6.如何实现一个功能完善的类型判断函数？",slug:"_6-如何实现一个功能完善的类型判断函数",children:[]}]},{level:2,title:"JS类型之问——类型转换篇",slug:"js类型之问——类型转换篇",children:[{level:3,title:"7.toString 和 valueOf 方法有什么区别？",slug:"_7-tostring-和-valueof-方法有什么区别",children:[]},{level:3,title:"8.你知道对象转换成原始值是什么流程吗 (ToPrimitive)？",slug:"_8-你知道对象转换成原始值是什么流程吗-toprimitive",children:[]},{level:3,title:"9.你能做出下面这个题吗？",slug:"_9-你能做出下面这个题吗",children:[]},{level:3,title:"10.你能理清类型转换吗？",slug:"_10-你能理清类型转换吗",children:[]},{level:3,title:"11.== 的隐式转换规则",slug:"_11-的隐式转换规则",children:[]},{level:3,title:"12.1 + {} 与 {} + 1的输出结果分别是什么？",slug:"_12-1-与-1的输出结果分别是什么",children:[]},{level:3,title:"13.[]与{}的相加的结果是多少？",slug:"_13-与-的相加的结果是多少",children:[]},{level:3,title:"14.你能灵活运用 parseInt 与 parseFloat 吗",slug:"_14-你能灵活运用-parseint-与-parsefloat-吗",children:[]},{level:3,title:"15.如何让 if(a == 1 && a == 2) 条件成立？",slug:"_15-如何让-if-a-1-a-2-条件成立",children:[]}]}],path:"/JS/%E5%8E%9F%E7%94%9FJS.html",pathLocale:"/",extraFields:[]},{title:"interview-1",headers:[{level:2,title:"一、事件循环",slug:"一、事件循环",children:[{level:3,title:"EventLoop",slug:"eventloop",children:[]}]},{level:2,title:"二、this是什么",slug:"二、this是什么",children:[{level:3,title:"关于this指针的指向问题",slug:"关于this指针的指向问题",children:[]}]},{level:2,title:"三、闭包相关问题",slug:"三、闭包相关问题",children:[]},{level:2,title:"四、vue的生命周期",slug:"四、vue的生命周期",children:[]},{level:2,title:"五、web前端开发技术的优化策略",slug:"五、web前端开发技术的优化策略",children:[{level:3,title:"减少页面加载时间的方式",slug:"减少页面加载时间的方式",children:[]}]},{level:2,title:"六、回流和重绘",slug:"六、回流和重绘",children:[{level:3,title:"何时发生回流重绘",slug:"何时发生回流重绘",children:[]},{level:3,title:"减少重排重绘的方法",slug:"减少重排重绘的方法",children:[]},{level:3,title:"浏览器的优化机制",slug:"浏览器的优化机制",children:[]}]},{level:2,title:"七、常见的HTTP状态码",slug:"七、常见的http状态码",children:[{level:3,title:"状态码分类：",slug:"状态码分类",children:[]},{level:3,title:"常见的HTTP状态码列表:",slug:"常见的http状态码列表",children:[]}]},{level:2,title:"八、Ajax如何使用",slug:"八、ajax如何使用",children:[]},{level:2,title:"九、下面代码中 a 在什么情况下会打印 1？",slug:"九、下面代码中-a-在什么情况下会打印-1",children:[]},{level:2,title:"十、介绍下 BFC 及其应用",slug:"十、介绍下-bfc-及其应用",children:[]},{level:2,title:"十一、对sort()的理解",slug:"十一、对sort-的理解",children:[]},{level:2,title:"十二、call、apply、bind的区别",slug:"十二、call、apply、bind的区别",children:[]},{level:2,title:"十三、分析比较 opacity: 0、visibility: hidden、display: none 优劣和适用场景。",slug:"十三、分析比较-opacity-0、visibility-hidden、display-none-优劣和适用场景。",children:[]},{level:2,title:"十四、ES6 代码转成 ES5 代码的实现思路是什么",slug:"十四、es6-代码转成-es5-代码的实现思路是什么",children:[]},{level:2,title:"十五、数组里面有10万个数据，取第一个元素和第10万个元素的时间相差多少",slug:"十五、数组里面有10万个数据-取第一个元素和第10万个元素的时间相差多少",children:[]},{level:2,title:"十六、Vue 的父组件和子组件生命周期钩子执行顺序是什么",slug:"十六、vue-的父组件和子组件生命周期钩子执行顺序是什么",children:[]},{level:2,title:"十七、import导入的模块",slug:"十七、import导入的模块",children:[]},{level:2,title:"十八、var、let 和 const",slug:"十八、var、let-和-const",children:[]},{level:2,title:"十九、 Object.steal()和Object.freezze()",slug:"十九、-object-steal-和object-freezze",children:[]}],path:"/Navigation/interview.html",pathLocale:"/",extraFields:[]},{title:"interview-2",headers:[{level:2,title:"一、什么是 Data URL",slug:"一、什么是-data-url",children:[]},{level:2,title:"二、伪类与伪元素有什么区别",slug:"二、伪类与伪元素有什么区别",children:[]},{level:2,title:"三、如何实现表格单双行条纹样式",slug:"三、如何实现表格单双行条纹样式",children:[]},{level:2,title:"四、prefetch 与 preload 的区别是什么",slug:"四、prefetch-与-preload-的区别是什么",children:[]},{level:2,title:"五、如何实现页面文本不可复制",slug:"五、如何实现页面文本不可复制",children:[]},{level:2,title:"六、js 代码压缩",slug:"六、js-代码压缩",children:[]},{level:2,title:"七、package.json 指南",slug:"七、package-json-指南",children:[]},{level:2,title:"八、CSS 选择器优先级特异性权重",slug:"八、css-选择器优先级特异性权重",children:[]}],path:"/Navigation/interview2.html",pathLocale:"/",extraFields:[]},{title:"面试知识导航",headers:[{level:2,title:"一、你真的了解回流和重绘吗",slug:"一、你真的了解回流和重绘吗",children:[]},{level:2,title:"二、重新认识构造函数、原型和原型链",slug:"二、重新认识构造函数、原型和原型链",children:[]},{level:2,title:"三、改造下面的代码，使之输出0 - 9，写出你能想到的所有解法。",slug:"三、改造下面的代码-使之输出0-9-写出你能想到的所有解法。",children:[]},{level:2,title:"四、怎么让一个 div 水平垂直居中",slug:"四、怎么让一个-div-水平垂直居中",children:[]},{level:2,title:"五、箭头函数与普通函数（function）的区别是什么？构造函数（function）可以使用 new 生成实例，那么箭头函数可以吗？为什么？",slug:"五、箭头函数与普通函数-function-的区别是什么-构造函数-function-可以使用-new-生成实例-那么箭头函数可以吗-为什么",children:[]},{level:2,title:"六、介绍下 BFC、IFC、GFC 和 FFC",slug:"六、介绍下-bfc、ifc、gfc-和-ffc",children:[]},{level:2,title:"七、常见的DOM操作",slug:"七、常见的dom操作",children:[]},{level:2,title:"八、前端项目中常见的报错类型汇总",slug:"八、前端项目中常见的报错类型汇总",children:[]},{level:2,title:"九、分清splice、slice和split",slug:"九、分清splice、slice和split",children:[]},{level:2,title:"十、flex 的三个参数 flex:1 0 auto",slug:"十、flex-的三个参数-flex-1-0-auto",children:[]},{level:2,title:"十一、防抖和节流",slug:"十一、防抖和节流",children:[]},{level:2,title:"十二、数组扁平化",slug:"十二、数组扁平化",children:[]}],path:"/Navigation/navigation.html",pathLocale:"/",extraFields:[]},{title:"PDF导航",headers:[{level:2,title:"前端js篇",slug:"前端js篇",children:[]},{level:2,title:"前端网络篇",slug:"前端网络篇",children:[]},{level:2,title:"前端面试小书",slug:"前端面试小书",children:[]},{level:2,title:"面试题精选大全",slug:"面试题精选大全",children:[]},{level:2,title:"算法",slug:"算法",children:[]}],path:"/Navigation/PDF.html",pathLocale:"/",extraFields:[]},{title:"扁平化",headers:[{level:2,title:"实现方法",slug:"实现方法",children:[{level:3,title:"扩展：手写flat",slug:"扩展-手写flat",children:[]}]}],path:"/study/study1.html",pathLocale:"/",extraFields:[]},{title:"防抖和节流",headers:[],path:"/study/study2.html",pathLocale:"/",extraFields:[]},{title:"输出什么",headers:[{level:3,title:"map",slug:"map",children:[]},{level:3,title:"parseInt",slug:"parseint",children:[]},{level:3,title:"回到真实的事例上",slug:"回到真实的事例上",children:[]}],path:"/study/study3.html",pathLocale:"/",extraFields:[]},{title:"跨域",headers:[{level:2,title:"常见的跨域场景",slug:"常见的跨域场景",children:[]},{level:2,title:"特别说明",slug:"特别说明",children:[]},{level:2,title:"跨域的解决方案",slug:"跨域的解决方案",children:[{level:3,title:"1. jsonp",slug:"_1-jsonp",children:[]},{level:3,title:"2. cors",slug:"_2-cors",children:[]},{level:3,title:"3. postMessage",slug:"_3-postmessage",children:[]}]}],path:"/study/study4.html",pathLocale:"/",extraFields:[]},{title:"",headers:[],path:"/404.html",pathLocale:"/",extraFields:[]},{title:"",headers:[],path:"/",pathLocale:"/",extraFields:[]},{title:"",headers:[],path:"/about/",pathLocale:"/",extraFields:[]},{title:"",headers:[],path:"/mood/",pathLocale:"/",extraFields:[]},{title:"",headers:[],path:"/link/",pathLocale:"/",extraFields:[]},{title:"",headers:[],path:"/tag/",pathLocale:"/",extraFields:[]},{title:"",headers:[],path:"/archive/",pathLocale:"/",extraFields:[]},{title:"",headers:[],path:"/aurora-coze/",pathLocale:"/",extraFields:[]},{title:"",headers:[],path:"/aurora-register/",pathLocale:"/",extraFields:[]},{title:"",headers:[],path:"/photo/",pathLocale:"/",extraFields:[]},{title:"",headers:[],path:"/aurora-music/",pathLocale:"/",extraFields:[]},{title:"",headers:[],path:"/aurora-archive/",pathLocale:"/",extraFields:[]}]},5220:(n,a,s)=>{s.d(a,{H:()=>e});const e={base:"/",lang:"zh-CN",title:"IEWGANFIL",description:"",head:[["script",{src:"https://at.alicdn.com/t/font_2849934_v6y652peian.js"}],["link",{href:"https://s2.loli.net/2022/01/21/PXGSkwrIpBiOUm4.jpg",rel:"icon"}],["link",{rel:"stylesheet",type:"text/css",href:"//at.alicdn.com/t/font_2932340_r7zitafg82.css"}]],locales:{}}},2232:(n,a,s)=>{s.d(a,{f:()=>e});const e={donate:{articlePage:!1},navbar:[{text:"好用网站",iconClass:"aurora-navbar-si-glyph-glass-water",children:[{text:"网站",children:[{text:"掘金主页",link:"https://juejin.cn/user/1082363860234023"},{text:"MVCAT",link:"https://www.mvcat.com/movie/"},{text:"图片上传",link:"https://sm.ms/"},{text:"音乐转换",link:"https://link.hhtjim.com/"}]},{text:"文档",children:[{text:"MDN",link:"https://developer.mozilla.org/zh-CN/"},{text:"菜鸟教程",link:"https://www.runoob.com/"},{text:"vue",link:"https://cn.vuejs.org/"}]},{text:"算法相关",iconClass:"aurora-navbar-si-glyph-billiard-ball",children:[{text:"LeetCode",link:"https://leetcode-cn.com/problemset/all/"},{text:"书籍",link:"https://programmercarl.com/"}]}]},{text:"学习相关",iconClass:"aurora-navbar-kechengguanli",children:[{text:"前端一百问",link:"https://juejin.cn/post/6844903885488783374"},{text:"GitHub选择题",link:"https://github.com/lydiahallie/javascript-questions"},{text:"高频前端汇总",link:"https://juejin.cn/post/6940945178899251230"},{text:"大厂面试秘籍",link:"https://juejin.cn/post/6844903776512393224"},{text:"十大经典排序算法总结",link:"https://juejin.cn/post/6844903444365443080"},{text:"牛客前端面试",link:"https://www.nowcoder.com/tutorial/96/f5212664ab664984882b00635066ded2"}]},{text:"学校",iconClass:"aurora-navbar-si-glyph-emoticon",children:[{text:"VPN",link:"https://nic.ecut.edu.cn/f9/d1/c4905a63953/page.htm"},{text:"学习通",link:"http://passport2.chaoxing.com/login?fid=&newversion=true&refer=http%3A%2F%2Fi.chaoxing.com"}]},{text:"About",link:"/about",iconClass:"aurora-navbar-a-ziyuan107"},{text:"Tag",link:"/tag",iconClass:"aurora-navbar-hua2"},{text:"Time",link:"/archive",iconClass:"aurora-navbar-shoulijindu-xuanzhong"},{text:"Mood",iconClass:"aurora-navbar-si-glyph-game-1",children:[{text:"chat",children:[{text:"mood",link:"/mood"},{text:"Photos",link:"/photo"},{text:"注册",link:"/aurora-register"}]}]},{text:"IEWGANFIL",link:"https://github.com/iewganfil",iconClass:"aurora-navbar-github-circle"}],darkMode:!1,repo:"https://github.com/iewganfil/blog",repoIconClass:"IEWGANFIL",docsRepo:"https://github.com/iewganfil",githubActions:!0,docsBranch:"main",repoLabel:"IEWGANFIL",editLink:!1,editLinkText:"edit",lastUpdated:!0,lastUpdatedText:"lastTime",logoColor:"#2c3e50",showFont:"李",heroImg:"/avatar.jpg",logo:"/avatar.jpg",lazyLoadingImg:"https://ooszy.cco.vin/img/blog-public/ljz.gif",homePageLazyLoadingImg:"https://ooszy.cco.vin/img/blog-public/ljz.gif",customRandomSay:!1,customRandomValue:"Vuepress-theme-Aurora",socials:[{aHref:"tencent://message/?uin=1519467168",isHome:!0,show:!0,sidebar:!0,symbol:"#icon-qq"},{aHref:"https://github.com/iewgnafil",isHome:!0,show:!0,sidebar:!0,symbol:"#icon-github-fill"},{aHref:"https://juejin.cn/user/1082363860234023",isHome:!0,show:!0,symbol:"#icon-juejin",sidebar:!0},{aHref:"https://space.bilibili.com/443173945",isHome:!0,show:!0,sidebar:!0,symbol:"#icon-bilibili-1"},{aHref:"https://music.163.com/#/user/home?id=1890980793",isHome:!0,show:!0,symbol:"#icon-wangyiyunyinle",sidebar:!0},{aHref:"mailto:1519467168@qq.com",isHome:!0,show:!0,sidebar:!0,symbol:"#icon-email"}],logoTitle:"IEWGANFIL",headTitle:"this is headTitle",description:"IEWGANFIL 学习网站",keyword:"vuepress主题,vuepress theme,生活琐事,简约博客,博客主题,静态主题",slideTime:3e5,randomSaw:"https://international.v1.hitokoto.cn/?c=b&max_length=45",about:[{bar:!1,title:"我?",describe:["目前是一名大三学生","偶尔动态、偶尔存在、不善社交","把节奏放慢，生活也是，爱情例外","遇到不好的事情，酌情处理，适当过滤","你所见即我，好与坏都不重要","门庭冷落，来者需诚","不能与你感同身受但能做你的最佳听众","会心动、会难过、会感动、会生气、想好好生活","一个能力很小欲望很大的普通人☔"],tag:["coding","电影","音乐","懒"],showTag:!0},{bar:!1,title:"大三规划",describe:["做项目","想找实习","复习数据结构","做点什么有意义的事"],tag:["大家加油呀`Σ(￣□￣||)` ..."],showTag:!0},{bar:!1,title:"未来规划",describe:["前端工程师","赚money"],tag:["忘记过去，展望未来"],showTag:!0},{bar:!0,title:"技  能",describe:[{name:"java",score:20},{name:"HTML5",score:60},{name:"javascript",score:60},{name:"css",score:60},{name:"mysql",score:20},{name:"vue",score:60},{name:"spring",score:0},{name:"springMVC",score:0},{name:"springBoot",score:0}],showTag:!1},{showTag:!1,bar:!0,title:"掌握框架",describe:[{name:"spring",score:0},{name:"springMVC",score:0},{name:"springBoot",score:0},{name:"vue",score:60}]},{bar:!0,showTag:!1,title:"掌握技能",describe:[{name:"linux",score:0},{name:"git",score:50},{name:"Ctrl C V",score:100}]}],randomSawQuery:"hitokoto",method:"get",randomColor:["#54b8f7"],maxFontColorArr:8,fontColor:["#2c3e50","#42a5f5","#8093f1","#FF6EC7","#FF7F00","#8FBC8F","#EAADEA","#3299CC","#CDCDCD","#CC3299","#FF7F00","#2F4F4F"],friendLinks:[{title:"我的朋友",links:[{title:"IEWGANFIL",url:"http://8.134.129.78/",logo:"https://s2.loli.net/2022/01/21/KYjOrXUu3SAWlga.jpg",describe:"人生若只是初见,何事秋风悲画扇",cover:"https://s2.loli.net/2022/01/24/RxMbWdsieDP9I8c.png"},{title:"小鱼想买718",url:"http://smallfish.space/",logo:"http://smallfish.space/img/1.jpg",describe:"不会辜负她和梦想的男人",cover:"https://s2.loli.net/2022/01/24/i3F5VRHSBszMNLY.png"}]}],fontFamily:["-apple-system","hlt","tzt","sst","lf","xsf","lsf","cgt"],footer:["Copyright © by IEWGANFIL All Rights Reserved.","<a target='_blank' href='http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=36073202360802' style='display:inline-block;text-decoration:none;height:20px;line-height:20px;'><img src='' style='float:left;'/><p style='float:left;height:20px;line-height:20px;margin: 0px 0px 0px 5px;'>赣ICP备2022000943号-1</p></a>"],isShowFooter:!0,isShowThemeCopyright:!1,isShowRunTime:!0,startRunTime:"1/19/2022 12:22:00",prefixRuntime:"IEW已运行",message:["STUDY CODING","⭐⭐⭐⭐⭐"],recommendPageLength:30,recommendNoTitle:"`╮(￣▽￣)╭`",tagNoTitle:"暂时还没有标题哟",mood:"IEWGANFIL",isFitter:!0,defaultBorderRadius:20,defaultOpacity:1,isHomePageFollow:!0,defaultBlur:1,split:"~",comment:{showComment:!0,serverURL:"https://blog-message-8xz9uhokh-iewgnafil.vercel.app/",emojis:["https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/alus","https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/bilibili","https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/tieba","https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/weibo"],avatar:"monsterid"},poster:{description:"CODING",author:"IEWGANFIL",preBlog:"IFL",suffixBlog:" CODING",avatar:"https://s2.loli.net/2022/01/21/KYjOrXUu3SAWlga.jpg"},showOnlineMood:!0,showMoodEdit:!1,addMood:{siteName:"localhost:8080",appId:"q4LlYVTTk2r39sNrJr7BL9A6p",appKey:"VxezWTppppyX2LTx4TUK8w6e2"},customTopImg:{custom:!0,page:["/bg/3.JPG"],friend:["/bg/3.jpg"],tag:["/bg/3.jpg"],mood:["/bg/3.jpg"]},homeWps:["https://www.iewganfil.top/bg/3.JPG"],homeWpsMobile:["/bg/4.jpg"],pageSize:3,githubUrl:"https://github.com/iewgnafil",latestPageSize:6,showHomePageImg:!1,sidebarCatalogLevel:1,homePageImgApi:"",mobileCutText:"IEWGANFIL",sidebarTag:"categories",showAddMood:!0,postImgApi:"https://picture.cco.vin/pic/rmimg?type=bing",articleH2Icon:"⭐",articleH3Icon:"🐳",articleH4Icon:"⛄",sidebarAvatar:"/avatar.jpg",sugCountPerMin:300,showRecommend:!1,articlePagination:!0,global:{sidebar:{showStatus:!0,perData:!1,social:!1,friendLink:!0,navbar:!1,latestPage:!0,message:!1,tag:!0,siteData:!1},footer:!1},excludePath:["/footer.html","/v1.3.0/","/plugin/","/node.html","/style.html"],categoriesIncludeFolderName:!0,wave:{showWave:!0},bubble:{show:!0,bubbleNumber:.14,bubbleAlpha:.6,alphaChangeSpeed:1e-5,size:.4,sizeChangeSpeed:2e-4,riseSpeed:.4,color:"255,255,255"},leanCloud:{appId:"2A2Dyd2AffrnldhwftlEddVn-MdYXbMMI",appKey:"qHYTbb91iOPLelyC9lpbXxLH",masterKey:"eUwfvS3luIPnPiHS5SpEhDYr"},showPageMeta:!0,randomSayApi:{method:"GET",urlApi:"https://v1.hitokoto.cn/?encode=text&c=a"},homeTopText:"Top",sidebarDesc:"COGING、STUDY",locales:{"/":{selectLanguageName:"English"}},selectLanguageText:"Languages",selectLanguageAriaLabel:"Select language",sidebar:"auto",sidebarDepth:2,contributors:!0,contributorsText:"Contributors",notFound:["There's nothing here.","How did we get here?","That's a Four-Oh-Four.","Looks like we've got some broken links."],backToHome:"Take me home",openInNewWindow:"open in new window"}},4125:(n,a,s)=>{s.d(a,{Z:()=>e});const e=[{data:{key:"v-245bbacd",path:"/how-to-write-article.html",title:"JavaScript数据类型的相关问题看这篇文章就够了",lang:"zh-CN",frontmatter:{date:"2022/1/20 10:08",coverUrl:"https://pic1.zhimg.com/80/v2-904505bcf0c424788f6028b8952aa2e7_1440w.jpg?source=1940ef5c",sticky:!0,keyword:"设置keyword,设置keyword,设置keyword,设置keyword",description:"JavaScript 数据类型种类、存储方式、判断方法",title:"JavaScript数据类型的相关问题看这篇文章就够了",tag:["笔记"],categories:["Javascript"]},excerpt:"",headers:[{level:2,title:"了解强、弱类型和动态、静态类型语言",slug:"了解强、弱类型和动态、静态类型语言",children:[{level:3,title:"强类型",slug:"强类型",children:[]},{level:3,title:"弱类型",slug:"弱类型",children:[]},{level:3,title:"静态类型",slug:"静态类型",children:[]},{level:3,title:"动态类型",slug:"动态类型",children:[]}]},{level:2,title:"基本数据类型",slug:"基本数据类型",children:[]},{level:2,title:"引用数据类型",slug:"引用数据类型",children:[{level:3,title:"引用类型的检索",slug:"引用类型的检索",children:[]}]},{level:2,title:"拓展：深浅拷贝",slug:"拓展-深浅拷贝",children:[{level:3,title:"手写方法实现深拷贝：",slug:"手写方法实现深拷贝",children:[]}]},{level:2,title:"typeof方法",slug:"typeof方法",children:[]},{level:2,title:"拓展：为什么null返回的是一个object呢？",slug:"拓展-为什么null返回的是一个object呢",children:[]},{level:2,title:"instanceof方法",slug:"instanceof方法",children:[]}],git:{updatedTime:1642668034e3,contributors:[{name:"iewgnafil",email:"1519467168@qq.com",commits:1}]}},key:"v-245bbacd",path:"/how-to-write-article.html",title:"JavaScript数据类型的相关问题看这篇文章就够了",lang:"zh-CN",frontmatter:{date:"2022/1/20 10:08",coverUrl:"https://pic1.zhimg.com/80/v2-904505bcf0c424788f6028b8952aa2e7_1440w.jpg?source=1940ef5c",sticky:!0,keyword:"设置keyword,设置keyword,设置keyword,设置keyword",description:"JavaScript 数据类型种类、存储方式、判断方法",title:"JavaScript数据类型的相关问题看这篇文章就够了",tag:["笔记"],categories:["Javascript"]},excerpt:"",headers:[{level:2,title:"了解强、弱类型和动态、静态类型语言",slug:"了解强、弱类型和动态、静态类型语言",children:[{level:3,title:"强类型",slug:"强类型",children:[]},{level:3,title:"弱类型",slug:"弱类型",children:[]},{level:3,title:"静态类型",slug:"静态类型",children:[]},{level:3,title:"动态类型",slug:"动态类型",children:[]}]},{level:2,title:"基本数据类型",slug:"基本数据类型",children:[]},{level:2,title:"引用数据类型",slug:"引用数据类型",children:[{level:3,title:"引用类型的检索",slug:"引用类型的检索",children:[]}]},{level:2,title:"拓展：深浅拷贝",slug:"拓展-深浅拷贝",children:[{level:3,title:"手写方法实现深拷贝：",slug:"手写方法实现深拷贝",children:[]}]},{level:2,title:"typeof方法",slug:"typeof方法",children:[]},{level:2,title:"拓展：为什么null返回的是一个object呢？",slug:"拓展-为什么null返回的是一个object呢",children:[]},{level:2,title:"instanceof方法",slug:"instanceof方法",children:[]}],content:"\r\n\r\n# JavaScript 数据类型\r\n值类型（基本类型）有7种，分别是 \r\n- undefined\r\n- null\r\n- Boolean\r\n- String\r\n- Number\r\n- Symbol(ES6新增)\r\n- BigInt(ES10新增)\r\n\r\n引用类型：\r\n- Object\r\n- Array\r\n- function\r\n- Set\r\n- Map\r\n- WeakMap\r\n- WeakSet\r\n- RegExp\r\n- Date\r\n- Math…\r\n# 拓展：JavaScript 是一种动态弱类型语言。\r\n这意味着相同的变量可用作不同的类型：\r\n\r\n```js\r\nvar x;               // x 为 undefined\r\nvar x = 5;           // 现在 x 为数字\r\nvar x = \"John\";      // 现在 x 为字符串\r\n```\r\n## 了解强、弱类型和动态、静态类型语言\r\n### 强类型\r\n\r\n-   语言层面限制函数的实参类型必须与形参类型相同\r\n-   强类型语言中不允许任意的隐式类型转换\r\n\r\n### 弱类型\r\n\r\n-   弱类型语言层面不会限制实参的类型\r\n-   弱类型语言允许任意的数据隐式类型转换\r\n\r\n### 静态类型\r\n\r\n一个变量声明时它的类型就是明确的，声明过后它的类型不再允许修改\r\n\r\n### 动态类型\r\n\r\n- 运行阶段才能够明确变量类型，变量的类型随时可以改变\r\n\r\n- 动态类型语言中的变量没有类型，变量中存放的值才有类型\r\n# 基本数据类型和引用数据类型的存储方式：\r\n## 基本数据类型\r\n基本数据类型存储在**栈内存**，存储的是**值**。\r\n> 原始类型存储的都是值，是没有函数可以调用的。\r\n## 引用数据类型\r\n引用数据类型的值存储在**堆内存**，**地址指针**（该指针指向堆中的该实体）存储在栈内存。\r\n> 之所以引用数据类型存储在堆内存中，是因为引用数据类型占据空间大、占用内存不固定。 如果存储在栈中，将会影响程序运行的性能。\r\n### 引用类型的检索\r\n当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体；所以当我们把对象赋值给另外一个变量的时候，复制的是地址，指向同一块内存空间，当其中一个对象改变时，另一个对象也会变化。上述的赋值行为发生**浅拷贝**：拷贝的是栈中的内存地址，所以如果其中一个对象改变了这个地址里的值，就会影响到另一个对象。\r\n## 拓展：深浅拷贝\r\n在JavaScript中，基本类型 值的复制是直接拷贝一份新的一模一样的数据，这两份数据相互独立，互不影响。而引用类型值的复制则为传递对象的引用，则需要考虑深浅拷贝的问题。\r\n\r\n-   深拷贝：创建一个新的对象，将一个对象从内存中**完整地拷贝**出来一份给该新对象，并从**堆内存中开辟一个全新的空间存放新对象**，且新对象的修改并不会改变原对象。\r\n\r\n```js\r\nlet arr = [1, 2, 3, 4, 5]\r\nlet arr2 =JSON.parse(JSON.stringify(arr))       \r\n// arr.slice()    // [...arr]     //[].concat(arr)    皆可实现数组的深拷贝\r\n// JSON.parse(JSON.stringify(arr))  先将arr变成字符串  然后再将arr变成对象\r\n\r\narr[0] = 0\r\nconsole.log(arr2);      // [1, 2, 3, 4, 5]\r\n```\r\n\r\n-   浅拷贝：创建一个新的对象，来接收你要拷贝的对象的值，复制的是**栈内存中存放的的地址**，所以两者指向的**仍然是堆里的同一个对象**，所以如果其中一个对象改变了栈内存中存放的地址所指向的对象，就会影响到另一个对象。\r\n\r\n```js\r\nlet c = {name:'小明', age: 18}\r\nlet d = c\r\nc.age = 19\r\nconsole.log(d);   // { name: '小明', age: 19 }\r\n```\r\n\r\n### 手写方法实现深拷贝：\r\n\r\n```js\r\nlet person = {\r\n    name: '小明',\r\n    age: 18,\r\n    like: {\r\n        sport: 'running',\r\n        food: 'beef'\r\n    }\r\n}\r\n\r\nfunction deepCopy(obj) {\r\n    let n = obj instanceof Array ? [] : {}     // 判断是否为Array  来判断创建n的数据类型\r\n    for (let item in obj) {\r\n        if (obj.hasOwnProperty(item)) {     // 判断是自己的  还是原型上继承下来的\r\n            n[item] = obj[item] instanceof Object ? deepCopy(obj[item]) : obj[item]    \r\n            // 判断item是否还是对象或数组\r\n        }\r\n    }\r\n    return n\r\n}\r\n\r\nlet newPerson = deepCopy(person)\r\nperson.like.sport = 'swimming'\r\nconsole.log(newPerson);     // { name: '小明', age: 18, like: { sport: 'running', food: 'beef' } }\r\nconsole.log(person);       // { name: '小明', age: 18, like: { sport: 'swimming', food: 'beef' } }\r\n\r\n```\r\n\r\n\r\n\r\n# 判断数据类型的方法\r\n## typeof方法\r\n可以通过typeof检测基本类型和引用类型，不过检测出来的引用类型都是对象：\r\n\r\n```js\r\nconsole.log(\r\n    typeof 123,     //number\r\n    typeof 'abc',   //string\r\n    typeof false,   //boolean\r\n    typeof undefined, //undefined\r\n    typeof null, //object\r\n    typeof function(){console.log('aaa');}, // function\r\n    typeof new Date(), //object\r\n    typeof [1,2,3], //object\r\n    typeof {a:1,b:2,c:3}   //object\r\n);\r\n```\r\n首先 **typeof** 能够正确的判断基本数据类型，但除了null, **typeof null所输出的为object**。\r\n但是对于对象来说，`typeof`也不能正确的判断其类型， 如`typeof`一个函数可以输出 `function`,而除此之外，输出的全是` object`,这种情况下，我们无法准确的知道对象的类型。\r\n## 拓展：为什么null返回的是一个object呢？\r\njs 在底层存储变量的时候，会在变量的机器码的低位1-3位存储其类型信息\r\n-   000：对象\r\n-   010：浮点数\r\n-   100：字符串\r\n-   110：布尔\r\n-   1：整数\r\n在JS的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 `null` 表示为全零，所以typeof错误的将它判断为 `object` 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。\r\n\r\n#### null 和 undefined 的区别：\r\n- `null` 是 javascript 的关键字，表示一个特殊值，常用来描述\"空值\"，typeof 运算返回\"object\"。\r\n- `undefined` 是预定义的全局变量，他的值就是\"未定义\"， typeof 运算返回 \"undefined\"\r\n- `undefined` 这个值表示变量不含有值。可以通过将变量的值设置为 null 来清空变量。\r\n- 相对来说，null更接近其他语言的空、而undefined则是js特有的机制\r\n## instanceof方法\r\n由上可知`typeof`来判断引用类型是不准确的，故想要检测引用类型可以通过 **instanceof**\r\n\r\n    语法：object instanceof constructor（object为实例对象，constructor为构造函数）\r\n    \r\n关于**instanceof** 的实现原理的理解，可参考下面的代码：\r\n\r\n```js\r\nfunction instance_of (left, right){\r\n    let leftVal = left.__proto__\r\n    let rightVal = right.prototype\r\n    while(true){\r\n        if(leftVal === null) return false\r\n        if(leftVal === rightVal)  return true\r\n        leftVal = leftVal.__proto__\r\n    }\r\n}\r\nlet a = [1, 2, 3]\r\nconsole.log(instance_of(a,Array));    // true\r\n```\r\n由此可知`instanceof`是顺着**原型链**去找，直到找到相同的原型对象，返回true，否则为false。\r\n\r\n**instanceof**可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型\r\n\r\n",contentRendered:'<h1 id="javascript-数据类型" tabindex="-1"><a class="header-anchor" href="#javascript-数据类型" aria-hidden="true">#</a> JavaScript 数据类型</h1>\n<p>值类型（基本类型）有7种，分别是</p>\n<ul>\n<li>undefined</li>\n<li>null</li>\n<li>Boolean</li>\n<li>String</li>\n<li>Number</li>\n<li>Symbol(ES6新增)</li>\n<li>BigInt(ES10新增)</li>\n</ul>\n<p>引用类型：</p>\n<ul>\n<li>Object</li>\n<li>Array</li>\n<li>function</li>\n<li>Set</li>\n<li>Map</li>\n<li>WeakMap</li>\n<li>WeakSet</li>\n<li>RegExp</li>\n<li>Date</li>\n<li>Math…</li>\n</ul>\n<h1 id="拓展-javascript-是一种动态弱类型语言。" tabindex="-1"><a class="header-anchor" href="#拓展-javascript-是一种动态弱类型语言。" aria-hidden="true">#</a> 拓展：JavaScript 是一种动态弱类型语言。</h1>\n<p>这意味着相同的变量可用作不同的类型：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">var</span> x<span class="token punctuation">;</span>               <span class="token comment">// x 为 undefined</span>\n<span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>           <span class="token comment">// 现在 x 为数字</span>\n<span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token string">"John"</span><span class="token punctuation">;</span>      <span class="token comment">// 现在 x 为字符串</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="了解强、弱类型和动态、静态类型语言" tabindex="-1"><a class="header-anchor" href="#了解强、弱类型和动态、静态类型语言" aria-hidden="true">#</a> 了解强、弱类型和动态、静态类型语言</h2>\n<h3 id="强类型" tabindex="-1"><a class="header-anchor" href="#强类型" aria-hidden="true">#</a> 强类型</h3>\n<ul>\n<li>语言层面限制函数的实参类型必须与形参类型相同</li>\n<li>强类型语言中不允许任意的隐式类型转换</li>\n</ul>\n<h3 id="弱类型" tabindex="-1"><a class="header-anchor" href="#弱类型" aria-hidden="true">#</a> 弱类型</h3>\n<ul>\n<li>弱类型语言层面不会限制实参的类型</li>\n<li>弱类型语言允许任意的数据隐式类型转换</li>\n</ul>\n<h3 id="静态类型" tabindex="-1"><a class="header-anchor" href="#静态类型" aria-hidden="true">#</a> 静态类型</h3>\n<p>一个变量声明时它的类型就是明确的，声明过后它的类型不再允许修改</p>\n<h3 id="动态类型" tabindex="-1"><a class="header-anchor" href="#动态类型" aria-hidden="true">#</a> 动态类型</h3>\n<ul>\n<li>\n<p>运行阶段才能够明确变量类型，变量的类型随时可以改变</p>\n</li>\n<li>\n<p>动态类型语言中的变量没有类型，变量中存放的值才有类型</p>\n</li>\n</ul>\n<h1 id="基本数据类型和引用数据类型的存储方式" tabindex="-1"><a class="header-anchor" href="#基本数据类型和引用数据类型的存储方式" aria-hidden="true">#</a> 基本数据类型和引用数据类型的存储方式：</h1>\n<h2 id="基本数据类型" tabindex="-1"><a class="header-anchor" href="#基本数据类型" aria-hidden="true">#</a> 基本数据类型</h2>\n<p>基本数据类型存储在<strong>栈内存</strong>，存储的是<strong>值</strong>。</p>\n<blockquote>\n<p>原始类型存储的都是值，是没有函数可以调用的。</p>\n</blockquote>\n<h2 id="引用数据类型" tabindex="-1"><a class="header-anchor" href="#引用数据类型" aria-hidden="true">#</a> 引用数据类型</h2>\n<p>引用数据类型的值存储在<strong>堆内存</strong>，<strong>地址指针</strong>（该指针指向堆中的该实体）存储在栈内存。</p>\n<blockquote>\n<p>之所以引用数据类型存储在堆内存中，是因为引用数据类型占据空间大、占用内存不固定。 如果存储在栈中，将会影响程序运行的性能。</p>\n</blockquote>\n<h3 id="引用类型的检索" tabindex="-1"><a class="header-anchor" href="#引用类型的检索" aria-hidden="true">#</a> 引用类型的检索</h3>\n<p>当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体；所以当我们把对象赋值给另外一个变量的时候，复制的是地址，指向同一块内存空间，当其中一个对象改变时，另一个对象也会变化。上述的赋值行为发生<strong>浅拷贝</strong>：拷贝的是栈中的内存地址，所以如果其中一个对象改变了这个地址里的值，就会影响到另一个对象。</p>\n<h2 id="拓展-深浅拷贝" tabindex="-1"><a class="header-anchor" href="#拓展-深浅拷贝" aria-hidden="true">#</a> 拓展：深浅拷贝</h2>\n<p>在JavaScript中，基本类型 值的复制是直接拷贝一份新的一模一样的数据，这两份数据相互独立，互不影响。而引用类型值的复制则为传递对象的引用，则需要考虑深浅拷贝的问题。</p>\n<ul>\n<li>深拷贝：创建一个新的对象，将一个对象从内存中<strong>完整地拷贝</strong>出来一份给该新对象，并从<strong>堆内存中开辟一个全新的空间存放新对象</strong>，且新对象的修改并不会改变原对象。</li>\n</ul>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>\n<span class="token keyword">let</span> arr2 <span class="token operator">=</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span>       \n<span class="token comment">// arr.slice()    // [...arr]     //[].concat(arr)    皆可实现数组的深拷贝</span>\n<span class="token comment">// JSON.parse(JSON.stringify(arr))  先将arr变成字符串  然后再将arr变成对象</span>\n\narr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr2<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// [1, 2, 3, 4, 5]</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ul>\n<li>浅拷贝：创建一个新的对象，来接收你要拷贝的对象的值，复制的是<strong>栈内存中存放的的地址</strong>，所以两者指向的<strong>仍然是堆里的同一个对象</strong>，所以如果其中一个对象改变了栈内存中存放的地址所指向的对象，就会影响到另一个对象。</li>\n</ul>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">\'小明\'</span><span class="token punctuation">,</span> <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">}</span>\n<span class="token keyword">let</span> d <span class="token operator">=</span> c\nc<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">19</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// { name: \'小明\', age: 19 }</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="手写方法实现深拷贝" tabindex="-1"><a class="header-anchor" href="#手写方法实现深拷贝" aria-hidden="true">#</a> 手写方法实现深拷贝：</h3>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>\n    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">\'小明\'</span><span class="token punctuation">,</span>\n    <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>\n    <span class="token literal-property property">like</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n        <span class="token literal-property property">sport</span><span class="token operator">:</span> <span class="token string">\'running\'</span><span class="token punctuation">,</span>\n        <span class="token literal-property property">food</span><span class="token operator">:</span> <span class="token string">\'beef\'</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">let</span> n <span class="token operator">=</span> obj <span class="token keyword">instanceof</span> <span class="token class-name">Array</span> <span class="token operator">?</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>     <span class="token comment">// 判断是否为Array  来判断创建n的数据类型</span>\n    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> item <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment">// 判断是自己的  还是原型上继承下来的</span>\n            n<span class="token punctuation">[</span>item<span class="token punctuation">]</span> <span class="token operator">=</span> obj<span class="token punctuation">[</span>item<span class="token punctuation">]</span> <span class="token keyword">instanceof</span> <span class="token class-name">Object</span> <span class="token operator">?</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>item<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">:</span> obj<span class="token punctuation">[</span>item<span class="token punctuation">]</span>    \n            <span class="token comment">// 判断item是否还是对象或数组</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">return</span> n\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> newPerson <span class="token operator">=</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span>\nperson<span class="token punctuation">.</span>like<span class="token punctuation">.</span>sport <span class="token operator">=</span> <span class="token string">\'swimming\'</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newPerson<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// { name: \'小明\', age: 18, like: { sport: \'running\', food: \'beef\' } }</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// { name: \'小明\', age: 18, like: { sport: \'swimming\', food: \'beef\' } }</span>\n\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><h1 id="判断数据类型的方法" tabindex="-1"><a class="header-anchor" href="#判断数据类型的方法" aria-hidden="true">#</a> 判断数据类型的方法</h1>\n<h2 id="typeof方法" tabindex="-1"><a class="header-anchor" href="#typeof方法" aria-hidden="true">#</a> typeof方法</h2>\n<p>可以通过typeof检测基本类型和引用类型，不过检测出来的引用类型都是对象：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>\n    <span class="token keyword">typeof</span> <span class="token number">123</span><span class="token punctuation">,</span>     <span class="token comment">//number</span>\n    <span class="token keyword">typeof</span> <span class="token string">\'abc\'</span><span class="token punctuation">,</span>   <span class="token comment">//string</span>\n    <span class="token keyword">typeof</span> <span class="token boolean">false</span><span class="token punctuation">,</span>   <span class="token comment">//boolean</span>\n    <span class="token keyword">typeof</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token comment">//undefined</span>\n    <span class="token keyword">typeof</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token comment">//object</span>\n    <span class="token keyword">typeof</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'aaa\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// function</span>\n    <span class="token keyword">typeof</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">//object</span>\n    <span class="token keyword">typeof</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">//object</span>\n    <span class="token keyword">typeof</span> <span class="token punctuation">{</span><span class="token literal-property property">a</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token literal-property property">b</span><span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token literal-property property">c</span><span class="token operator">:</span><span class="token number">3</span><span class="token punctuation">}</span>   <span class="token comment">//object</span>\n<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>首先 <strong>typeof</strong> 能够正确的判断基本数据类型，但除了null, <strong>typeof null所输出的为object</strong>。\n但是对于对象来说，<code>typeof</code>也不能正确的判断其类型， 如<code>typeof</code>一个函数可以输出 <code>function</code>,而除此之外，输出的全是<code> object</code>,这种情况下，我们无法准确的知道对象的类型。</p>\n<h2 id="拓展-为什么null返回的是一个object呢" tabindex="-1"><a class="header-anchor" href="#拓展-为什么null返回的是一个object呢" aria-hidden="true">#</a> 拓展：为什么null返回的是一个object呢？</h2>\n<p>js 在底层存储变量的时候，会在变量的机器码的低位1-3位存储其类型信息</p>\n<ul>\n<li>000：对象</li>\n<li>010：浮点数</li>\n<li>100：字符串</li>\n<li>110：布尔</li>\n<li>1：整数\n在JS的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 <code>null</code> 表示为全零，所以typeof错误的将它判断为 <code>object</code> 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。</li>\n</ul>\n<h4 id="null-和-undefined-的区别" tabindex="-1"><a class="header-anchor" href="#null-和-undefined-的区别" aria-hidden="true">#</a> null 和 undefined 的区别：</h4>\n<ul>\n<li><code>null</code> 是 javascript 的关键字，表示一个特殊值，常用来描述&quot;空值&quot;，typeof 运算返回&quot;object&quot;。</li>\n<li><code>undefined</code> 是预定义的全局变量，他的值就是&quot;未定义&quot;， typeof 运算返回 &quot;undefined&quot;</li>\n<li><code>undefined</code> 这个值表示变量不含有值。可以通过将变量的值设置为 null 来清空变量。</li>\n<li>相对来说，null更接近其他语言的空、而undefined则是js特有的机制</li>\n</ul>\n<h2 id="instanceof方法" tabindex="-1"><a class="header-anchor" href="#instanceof方法" aria-hidden="true">#</a> instanceof方法</h2>\n<p>由上可知<code>typeof</code>来判断引用类型是不准确的，故想要检测引用类型可以通过 <strong>instanceof</strong></p>\n<pre><code>语法：object instanceof constructor（object为实例对象，constructor为构造函数）\n</code></pre>\n<p>关于<strong>instanceof</strong> 的实现原理的理解，可参考下面的代码：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">instance_of</span> <span class="token punctuation">(</span><span class="token parameter">left<span class="token punctuation">,</span> right</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token keyword">let</span> leftVal <span class="token operator">=</span> left<span class="token punctuation">.</span>__proto__\n    <span class="token keyword">let</span> rightVal <span class="token operator">=</span> right<span class="token punctuation">.</span>prototype\n    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token keyword">if</span><span class="token punctuation">(</span>leftVal <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span>\n        <span class="token keyword">if</span><span class="token punctuation">(</span>leftVal <span class="token operator">===</span> rightVal<span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token boolean">true</span>\n        leftVal <span class="token operator">=</span> leftVal<span class="token punctuation">.</span>__proto__\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">instance_of</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>Array<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// true</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>由此可知<code>instanceof</code>是顺着<strong>原型链</strong>去找，直到找到相同的原型对象，返回true，否则为false。</p>\n<p><strong>instanceof</strong>可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型</p>\n',date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:"/how-to-write-article.html",pathLocale:"/",permalink:null,routeMeta:{},slug:"how-to-write-article",filePath:"C:/Users/mi/Desktop/我的博客/docs/how-to-write-article.md",filePathRelative:"how-to-write-article.md",componentFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/how-to-write-article.html.vue",componentFilePathRelative:"pages/how-to-write-article.html.vue",componentFileChunkName:"v-245bbacd",dataFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/how-to-write-article.html.js",dataFilePathRelative:"pages/how-to-write-article.html.js",dataFileChunkName:"v-245bbacd",htmlFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/dist/how-to-write-article.html",htmlFilePathRelative:"how-to-write-article.html"},{data:{key:"v-3f77dce2",path:"/JS/%E5%8E%9F%E7%94%9FJS.html",title:"原生JavaScript灵魂拷问",lang:"zh-CN",frontmatter:{date:"2022/1/29 19:08",coverUrl:"http://cdn-ali-img-shstaticbz.shanhutech.cn/bizhi/staticwp/202107/30d8b12ad792deb0fb9e802bbc45113e--848443906.jpg",sticky:!0,keyword:"面试,原生JS",description:"原生JavaScript灵魂拷问",title:"原生JavaScript灵魂拷问",tag:["面试","JS"],categories:["Javascript"]},excerpt:"",headers:[{level:2,title:"前言",slug:"前言",children:[]},{level:2,title:"JS类型之问——概念与检测篇",slug:"js类型之问——概念与检测篇",children:[{level:3,title:"1.JS中的数据类型有哪些？",slug:"_1-js中的数据类型有哪些",children:[]},{level:3,title:"2.你真的懂typeof吗？",slug:"_2-你真的懂typeof吗",children:[]},{level:3,title:"3.什么是instanceof？你能模拟实现一个instanceof吗？",slug:"_3-什么是instanceof-你能模拟实现一个instanceof吗",children:[]},{level:3,title:"4.如何区分数组与对象？使用instanceof判断数组可靠吗？",slug:"_4-如何区分数组与对象-使用instanceof判断数组可靠吗",children:[]},{level:3,title:"5.如何判断一个数是否为NaN？",slug:"_5-如何判断一个数是否为nan",children:[]},{level:3,title:"6.如何实现一个功能完善的类型判断函数？",slug:"_6-如何实现一个功能完善的类型判断函数",children:[]}]},{level:2,title:"JS类型之问——类型转换篇",slug:"js类型之问——类型转换篇",children:[{level:3,title:"7.toString 和 valueOf 方法有什么区别？",slug:"_7-tostring-和-valueof-方法有什么区别",children:[]},{level:3,title:"8.你知道对象转换成原始值是什么流程吗 (ToPrimitive)？",slug:"_8-你知道对象转换成原始值是什么流程吗-toprimitive",children:[]},{level:3,title:"9.你能做出下面这个题吗？",slug:"_9-你能做出下面这个题吗",children:[]},{level:3,title:"10.你能理清类型转换吗？",slug:"_10-你能理清类型转换吗",children:[]},{level:3,title:"11.== 的隐式转换规则",slug:"_11-的隐式转换规则",children:[]},{level:3,title:"12.1 + {} 与 {} + 1的输出结果分别是什么？",slug:"_12-1-与-1的输出结果分别是什么",children:[]},{level:3,title:"13.[]与{}的相加的结果是多少？",slug:"_13-与-的相加的结果是多少",children:[]},{level:3,title:"14.你能灵活运用 parseInt 与 parseFloat 吗",slug:"_14-你能灵活运用-parseint-与-parsefloat-吗",children:[]},{level:3,title:"15.如何让 if(a == 1 && a == 2) 条件成立？",slug:"_15-如何让-if-a-1-a-2-条件成立",children:[]}]}],git:{updatedTime:null,contributors:[]}},key:"v-3f77dce2",path:"/JS/%E5%8E%9F%E7%94%9FJS.html",title:"原生JavaScript灵魂拷问",lang:"zh-CN",frontmatter:{date:"2022/1/29 19:08",coverUrl:"http://cdn-ali-img-shstaticbz.shanhutech.cn/bizhi/staticwp/202107/30d8b12ad792deb0fb9e802bbc45113e--848443906.jpg",sticky:!0,keyword:"面试,原生JS",description:"原生JavaScript灵魂拷问",title:"原生JavaScript灵魂拷问",tag:["面试","JS"],categories:["Javascript"]},excerpt:"",headers:[{level:2,title:"前言",slug:"前言",children:[]},{level:2,title:"JS类型之问——概念与检测篇",slug:"js类型之问——概念与检测篇",children:[{level:3,title:"1.JS中的数据类型有哪些？",slug:"_1-js中的数据类型有哪些",children:[]},{level:3,title:"2.你真的懂typeof吗？",slug:"_2-你真的懂typeof吗",children:[]},{level:3,title:"3.什么是instanceof？你能模拟实现一个instanceof吗？",slug:"_3-什么是instanceof-你能模拟实现一个instanceof吗",children:[]},{level:3,title:"4.如何区分数组与对象？使用instanceof判断数组可靠吗？",slug:"_4-如何区分数组与对象-使用instanceof判断数组可靠吗",children:[]},{level:3,title:"5.如何判断一个数是否为NaN？",slug:"_5-如何判断一个数是否为nan",children:[]},{level:3,title:"6.如何实现一个功能完善的类型判断函数？",slug:"_6-如何实现一个功能完善的类型判断函数",children:[]}]},{level:2,title:"JS类型之问——类型转换篇",slug:"js类型之问——类型转换篇",children:[{level:3,title:"7.toString 和 valueOf 方法有什么区别？",slug:"_7-tostring-和-valueof-方法有什么区别",children:[]},{level:3,title:"8.你知道对象转换成原始值是什么流程吗 (ToPrimitive)？",slug:"_8-你知道对象转换成原始值是什么流程吗-toprimitive",children:[]},{level:3,title:"9.你能做出下面这个题吗？",slug:"_9-你能做出下面这个题吗",children:[]},{level:3,title:"10.你能理清类型转换吗？",slug:"_10-你能理清类型转换吗",children:[]},{level:3,title:"11.== 的隐式转换规则",slug:"_11-的隐式转换规则",children:[]},{level:3,title:"12.1 + {} 与 {} + 1的输出结果分别是什么？",slug:"_12-1-与-1的输出结果分别是什么",children:[]},{level:3,title:"13.[]与{}的相加的结果是多少？",slug:"_13-与-的相加的结果是多少",children:[]},{level:3,title:"14.你能灵活运用 parseInt 与 parseFloat 吗",slug:"_14-你能灵活运用-parseint-与-parsefloat-吗",children:[]},{level:3,title:"15.如何让 if(a == 1 && a == 2) 条件成立？",slug:"_15-如何让-if-a-1-a-2-条件成立",children:[]}]}],content:"\r\n\r\n\r\n## 前言\r\n\r\n当下的前端开发，三大框架三分天下，框架的简单、强大让我们欲罢不能，使用原生 `JavaScript` 越来越少。\r\n\r\n但我认为 `JavaScript` 作为每一个前端工程师的立身之本，不止要学会，还要学好、学精，学再多遍都不为过。\r\n\r\n另一方面，前端面试中，越来越重视原生 `JavaScript` 的考察，其所占比例也越来越高。\r\n\r\n我抓取了牛客上今年的线上面试题和面经，大约 `500` 左右道题，原生 `JavaScript` 的难点(闭包，`eventLoop，this`，手撕原生JS)考察的频率非常高。\r\n\r\n> 完整的分析我还正在赶工中，希望大家到时候可以来支持一下。\r\n\r\n因此我决定整理`JavaScript`中容易忽视或者混淆的知识点，写一系列篇文章，以灵魂拷问的方式，系统且完整的带大家遨游原生 `JavaScript` 的世界，希望能给大家带来一些收获。\r\n\r\n## JS类型之问——概念与检测篇\r\n\r\n### 1.JS中的数据类型有哪些？\r\n\r\n1. 基本数据类型：共有7种\r\n\r\n```js\r\nBoolean Number String undefined null Bigint Symbol\r\n复制代码\r\n```\r\n\r\n`Symbol` ： `ES6` 引入的一种新的原始值，表示独一无二的值，主要为了解决属性名冲突问题。\r\n\r\n`Bigint` ：`ES2020` 新增加，是比 `Number` 类型的整数范围更大。\r\n\r\n1. 引用数据类型：1种\r\n\r\n```js\r\nObject对象(包括普通Object、Function、Array、Date、RegExp、Math)\r\n复制代码\r\n```\r\n\r\n### 2.你真的懂typeof吗？\r\n\r\n1. `typeof`的作用？\r\n\r\n   区分数据类型，可以返回7种数据类型：`number、string、boolean、undefined、object、function` ，以及 `ES6` 新增的 `symbol`\r\n\r\n2. `typeof` 能正确区分数据类型吗？\r\n\r\n   不能。对于原始类型，除 `null` 都可以正确判断；对于引用类型，除 `function` 外，都会返回 `\"object\"`\r\n\r\n3. `typeof` 注意事项\r\n\r\n   - `typeof` 返回值为 `string` 格式，注意类似这种考题: `typeof(typeof(undefined)) -> \"string\"`\r\n   - `typeof` 未定义的变量不会报错，返回 `\"undefiend\"`\r\n   - `typeof(null) -> \"object\"`: 遗留已久的 `bug`\r\n   - `typeof`无法区别数组与普通对象: `typeof([]) -> \"object\"`\r\n   - `typeof(NaN) -> \"number\"`\r\n\r\n4. 习题\r\n\r\n```js\r\nconsole.log(typeof(b));\r\nconsole.log(typeof(undefined)); \r\nconsole.log(typeof(NaN)); \r\nconsole.log(typeof(null)); \r\nvar a = '123abc'; \r\nconsole.log(typeof(+a)); \r\nconsole.log(typeof(!!a)); \r\nconsole.log(typeof(a + \"\")); \r\nconsole.log(typeof(typeof(null)));\r\nconsole.log(typeof(typeof({})));\r\n复制代码\r\n```\r\n\r\n**答案**\r\n\r\n```js\r\nundefined // b未定义，返回undefined\r\nundefined\r\nnumber // NaN 为number类型\r\nobject\r\nnumber // +a 类型转换为NaN\r\nboolean\r\nstring\r\nstring // typeof(null) -> \"object\"; typeof(\"object\") -> \"string\"\r\nstring\r\n复制代码\r\n```\r\n\r\n### 3.什么是instanceof？你能模拟实现一个instanceof吗？\r\n\r\n1. `instanceof` 判断对象的原型链上是否存在构造函数的原型。只能判断引用类型。\r\n2. `instanceof` 常用来判断 `A` 是否为 `B` 的实例\r\n\r\n```js\r\n// A是B的实例，返回true，否则返回false\r\n// 判断A的原型链上是否有B的原型\r\nA instaceof B\r\n复制代码\r\n```\r\n\r\n1. 模拟实现 `instanceof`\r\n\r\n思想：沿原型链往上查找\r\n\r\n```js\r\nfunction instance_of(Case, Constructor) {\r\n    // 基本数据类型返回false\r\n    // 兼容一下函数对象\r\n    if ((typeof(Case) != 'object' && typeof(Case) != 'function') || Case == 'null') return false;\r\n    let CaseProto = Object.getPrototypeOf(Case);\r\n    while (true) {\r\n        // 查到原型链顶端，仍未查到，返回false\r\n        if (CaseProto == null) return false;\r\n        // 找到相同的原型\r\n        if (CaseProto === Constructor.prototype) return true;\r\n        CaseProto = Object.getPrototypeOf(CaseProto);\r\n    }\r\n}\r\n复制代码\r\n```\r\n\r\n测试：\r\n\r\n```js\r\nconsole.log(instance_of(Array, Object)) // true\r\nfunction User(name){\r\n    this.name = name;\r\n}\r\nconst user = new User('zc');\r\nconst vipUser = Object.create(user);\r\nconsole.log(instance_of(vipUser, User)) // true\r\n复制代码\r\n```\r\n\r\n### 4.如何区分数组与对象？使用instanceof判断数组可靠吗？\r\n\r\n1. `ES6` 提供的新方法 `Array.isArray()`\r\n2. 如果不存在`Array.isArray()`呢？可以借助`Object.prototype.toString.call()` 进行判断，此方式兼容性最好\r\n\r\n```js\r\nif (!Array.isArray) {\r\n    Array.isArray = function(o) {\r\n        return typeof(o) === 'object' \r\n               && Object.prototype.toString.call(o) === '[object Array]';\r\n    }\r\n}\r\n复制代码\r\n```\r\n\r\n1. `instanceof` 判断\r\n\r\n判断方式\r\n\r\n```js\r\n// 如果为true，则arr为数组\r\narr instanceof Array\r\n复制代码\r\n```\r\n\r\n`instanceof` 判断数组类型如此之简单，为何不推荐使用那？\r\n\r\n`instanceof` 操作符的问题在于，如果网页中存在多个 `iframe` ，那便会存在多个 `Array` 构造函数，此时判断是否是数组会存在问题。\r\n\r\n更详细的内容可以参考博文：[JavaScript为啥不用instanceof检测数组 ](https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fweixin_42467709%2Farticle%2Fdetails%2F105302852)\r\n\r\n### 5.如何判断一个数是否为NaN？\r\n\r\n`NaN` 有个非常特殊的特性， `NaN` 与任何值都不相等，包括它自身\r\n\r\n```js\r\nNaN === NaN // false\r\nNaN == NaN // false\r\n复制代码\r\n```\r\n\r\n鉴于这个独特的特性，可以手撕一个比较简单的判断函数\r\n\r\n```js\r\nfunction isNaN(x) {\r\n    return x != x;\r\n}\r\n复制代码\r\n```\r\n\r\n- 全局函数 `isNaN` 方法：不推荐使用。`MDN` 对它的介绍是：`isNaN` 函数内包含一些非常有趣的规则。\r\n\r\n但为了避免一些面试官出一些冷门题目，咱们来稍微了解一下 `isNaN` 的有趣机制：会先判断参数是不是 `Number` 类型，如果不是 `Number` 类型会尝试将这个参数转换为 `Number` 类型，之后再去判断是不是 `NaN` 。\r\n\r\n举个例子：\r\n\r\n```js\r\n// 为什么对象会带来三种不同的结果\r\n// 是不是很有趣\r\n// 具体原因可以参考类型转换篇\r\nconsole.log(isNaN([])) // false\r\nconsole.log(isNaN([1])) // false\r\nconsole.log(isNaN([1, 2])) // true \r\nconsole.log(isNaN(null)) // false\r\nconsole.log(isNaN(undefined)) // true\r\n复制代码\r\n```\r\n\r\n`isNaN` 的结果很大程度上取决于 `Number()` 类型转换的结果，关于 `Number` 的转换结果，后面会专门有一部分来介绍。\r\n\r\n- `Number.isNaN` (推荐使用)\r\n\r\n与 `isNaN()` 相比，`Number.isNaN()` 不会自行将参数转换成数字，只有在参数是值为 ` NaN` 的数字时，才会返回 `true`。\r\n\r\n### 6.如何实现一个功能完善的类型判断函数？\r\n\r\n`Object.prototype.toString.call([value])` ，可以精准判断数据类型，因此可以根据这个原理封装一个自己的 `type` 方法。\r\n\r\n```js\r\ntoString.call(()=>{})       // [object Function]\r\ntoString.call({})           // [object Object]\r\ntoString.call([])           // [object Array]\r\ntoString.call('')           // [object String]\r\ntoString.call(22)           // [object Number]\r\ntoString.call(undefined)    // [object undefined]\r\ntoString.call(null)         // [object null]\r\ntoString.call(new Date)     // [object Date]\r\ntoString.call(Math)         // [object Math]\r\ntoString.call(window)       // [object Window]\r\n复制代码\r\n```\r\n\r\n## JS类型之问——类型转换篇\r\n\r\n### 7.toString 和 valueOf 方法有什么区别？\r\n\r\n1. 基础：这两个方法属于 `Object` 对象，是为了解决 `JavaScript` 值运算与显示的问题。为了更适合自身功能，很多 `JavaScript` 内置对象都重写了这两个方法。\r\n2. `toString()`: 返回当前对象的字符串形式；`valueOf()` : 返回该对象的原始值\r\n3. 各个类型下两个方法返回值情况对比\r\n\r\n| 类型         | valueOf           | toString                |\r\n| ------------ | ----------------- | ----------------------- |\r\n| Array[1,2,3] | 数组本身[1, 2, 3] | 1,2,3                   |\r\n| Object       | 对象本身          | [object Object]         |\r\n| Boolean类型  | Boolean值         | \"true\"或\"false\"         |\r\n| Function     | 函数本身          | function fnName(){code} |\r\n| Number       | 数值              | 数值的字符换表示        |\r\n| Date         | 毫米格式时间戳    | GMT格式时间字符串       |\r\n\r\n1. 调用优先级\r\n\r\n   **隐式转换时会自动调用 `toString` 和 `valueOf` 方法**，两者优先级如下：\r\n\r\n   - 强制转化为字符串类型时，优先调用 `toString` 方法\r\n   - 强制转换为数值类型时，优先调用 `valueOf` 方法\r\n   - 使用运算符操作符情况下，`valueOf` 优先级高于 `toStirng`\r\n   - 对象的类型转换见下一问。\r\n\r\n### 8.你知道对象转换成原始值是什么流程吗 (ToPrimitive)？\r\n\r\n对象转换成原始类型，会调用内置的 `[ToPrimitive]`函数\r\n\r\n(参考博客: [从ECMA规范彻底理解 JavaScript 类型转换](https://juejin.cn/post/6988387082536222734#heading-8))\r\n\r\n- ```\r\n  ToPrimitive\r\n  ```\r\n\r\n   方法接受两个参数，一个是输入的值 \r\n\r\n  ```\r\n  input\r\n  ```\r\n\r\n  ，一个是期望转换的类型 \r\n\r\n  ```\r\n  PreferredType\r\n  ```\r\n\r\n  1. 如果未传入 `PreferredType` 参数，让 `hint` 等于 `'default'`，后面会将 `hint` 修改为 `'number'`\r\n  2. 如果 `PreferredType` 是 `hint String`，让 `hint` 等于 `'string'`\r\n  3. 如果 `PreferredType` 是 `hint Number`，让 `hint` 等于 `'number'`\r\n  4. 返回 `OrdinaryToPrimitive(input, hint)`\r\n\r\n- ```\r\n  OrdinaryToPrimitive(input, hint)\r\n  ```\r\n\r\n  1. 如果 `hint` 是 `'string'`，那么就将 `methodNames` 设置为 `toString、valueOf`\r\n  2. 如果 `hint` 是 `'number'`，那么就将 `methodNames` 设置为 `valueOf、toString`\r\n\r\n> `methodName` 存储的就是当前 `preferredType` 下的调用优先级，如果全部调用完毕仍然未转化为原始值，会发生报错。\r\n\r\n### 9.你能做出下面这个题吗？\r\n\r\n```js\r\nconst a = {x:1};\r\nconst b = {x:2};\r\nconst obj = {};\r\nobj[a] = 100;\r\nobj[b] = 200;\r\n\r\nconsole.log(obj[a]);\r\nconsole.log(obj[b]);\r\n复制代码\r\n```\r\n\r\n有了第七问和第八问的知识，这个题目就不难了。 `JavaScript` 对象的键必须是字符串，因此分别需要将对象 `a` 和 `b` 转换为 `string` 类型。具体转换流程：\r\n\r\n```js\r\n// 1.执行ToPrimitive\r\n// hint 为 string\r\nToPrimitive(a, 'hint String')\r\n// 2.执行OrdinaryToPrimitive\r\nOrdinaryToPrimitive(a, 'string')\r\n// 3.返回methodNames\r\nmethodNames = ['toString', 'valueOf']\r\n// 4.调用methodNames里方法\r\n// 调用toString\r\na.toString() // 返回[object Object]\r\n复制代码\r\n```\r\n\r\n对象 `a` 和 `b` 转换后的结果都是 `[object Object]`，`obj` 对象上只添加了一个属性 `[object Object]`。\r\n\r\n**答案**\r\n\r\n```js\r\n200\r\n200\r\n复制代码\r\n```\r\n\r\n### 10.你能理清类型转换吗？\r\n\r\n首先需要知道：在`JavaScript`中，只有**三种类型**的转换\r\n\r\n- 转换为`Number`类型: `Number() / parseFloat() / parseInt()`\r\n- 转化为`String`类型:` String() / toString()`\r\n- 转化为`Boolean`类型: `Boolean()`\r\n\r\n因此遇到类型转换问题，只需要弄清楚在**什么场景**之下转换成**那种类型**即可。\r\n\r\n#### 转换为boolean\r\n\r\n- 显式：`Boolean` 方法可以显式将值转换为布尔类型\r\n- 隐式：通常在逻辑判断或者有逻辑运算符时触发（`|| && !`）\r\n\r\n```js\r\nBoolean(1)   // 显式类型转换\r\nif (1) {}    // 逻辑判断类型触发隐式转换\r\n!!1          // 逻辑运算符触发隐式转换\r\n1 || 'hello' // 逻辑运算符触发隐式转换\r\n复制代码\r\n```\r\n\r\n`boolean` 类型只有 `true` 和 `false` 两种值。\r\n\r\n除值 **0,-0,null,NaN,undefined,或空字符串（\"\"）** 为 `false` 外，其余全为 `true`\r\n\r\n#### 转化为string\r\n\r\n- 显式：`String` 方法可以显式将值转换为字符串\r\n- 隐式：`+` 运算符有一侧操作数为 `string` 类型时\r\n\r\n转化为 `string` 类型的本质：**需要转换为string的部分调用自身的toString方法(null/undefined返回字符串格式的null和undefined)**\r\n\r\n> 当被转换值为对象时，相当于执行 `ToPrimitive(input, 'hint String')`\r\n\r\n```js\r\nString([1,2,3]) // 1,2,3\r\nString({x:1}) // [object Object]\r\n\r\n1 + '1' // 11\r\n1 + {} // 1[object Object]\r\n复制代码\r\n```\r\n\r\n#### 转化为number\r\n\r\n- 显式：`Number` 方法可以显式将值转化为数字类型\r\n\r\n`Number` 的具体规则，`ES5` 规范中给了一个[对应的结果表](https://link.juejin.cn?target=http%3A%2F%2Fes5.github.io%2F%23x9.3)\r\n\r\n| 类型      | 结果                                        |\r\n| --------- | ------------------------------------------- |\r\n| undefined | NaN                                         |\r\n| null      | +0                                          |\r\n| Boolean   | NaN                                         |\r\n| undefined | 参数为true返回1；false返回+0                |\r\n| Number    | 返回与之相等的值                            |\r\n| String    | 有些复杂，举例说明                          |\r\n| Object    | 先执行ToPrimitive方法，在执行Number类型转换 |\r\n\r\n1. `String`: 空字符串返回 `0`，出现任何一个非有效数字字符，返回 `NaN`\r\n\r\n```js\r\nconsole.log(Number(\"1 3\")) // NaN\r\nconsole.log(Number(\"abc\")) // NaN\r\nconsole.log(Number(\"1a\")) // NaN\r\nconsole.log(Number(\"0x11\")) // 17\r\nconsole.log(Number(\"123\")) // 123\r\nconsole.log(Number(\"-123\")) // -123\r\nconsole.log(Number(\"1.2\")) // 1.2\r\n复制代码\r\n```\r\n\r\n- 隐式：\r\n\r\n  ```\r\n  number\r\n  ```\r\n\r\n  的隐式类型转换比较复杂，对需要隐式转换的部分执行 \r\n\r\n  ```\r\n  Number\r\n  ```\r\n\r\n  ：\r\n\r\n  - 比较操作(`<, >, <=, >=`)\r\n  - 按位操作(`| & ^ ~`)\r\n  - 算数操作(`+ - * / %`) 注意：**+的操作数存在字符串时，为string转换**\r\n  - 一元 `+-` 操作\r\n\r\n### 11.== 的隐式转换规则\r\n\r\n1. `==`: 只需要值相等，无需类型相等；`null, undefined` 在 `==` 下互相等且自身等\r\n2. `==` 的转换规则:\r\n\r\n| 被比较数B |                     |                            |                                  |                               |        |\r\n| --------- | ------------------- | -------------------------- | -------------------------------- | ----------------------------- | ------ |\r\n|           |                     | Number                     | String                           | Boolean                       | Object |\r\n| 比较数A   |                     |                            |                                  |                               |        |\r\n| Number    | A == B              | A == ToNumber(B)           | A == ToNumber(B)                 | A == ToPrimitive(B)           |        |\r\n| String    | ToNumber(A) == B    | A == B                     | ToNumber(A) == ToNumber(B)       | ToPrimitive(B) == A           |        |\r\n| Boolean   | ToNumber(A) == B    | ToNumber(A) == ToNumber(B) | ToNumber(A) == ToNumber(B)       | ToNumber(A) == ToPrimitive(B) |        |\r\n| Object    | ToPrimitive(A) == B | ToPrimitive(A) == B        | ToPrimitive(A) == ToPrimitive(B) | A === B                       |        |\r\n\r\n在上面的表格中，`ToNumber(A)` 尝试在比较前将参数 `A` 转换为数字。`ToPrimitive(A)` 将参数 `A` 转换为原始值( `Primitive` )。\r\n\r\n### 12.`1 + {}` 与 `{} + 1`的输出结果分别是什么？\r\n\r\n通过上面的学习，当对象与其他元素相加时，对象会调用 `toPrimitive` 转化为原始值：\r\n\r\n1. 执行 `toPrimitive`，未传入 `PreferredType`，`methodNames` 为 `[valueOf, toString]`\r\n2. 执行 `({}).valueOf`，返回对象本身 `{}`，不是原始值\r\n3. 继续执行 `({}).toString()`，返回 `\"[object Object]\"`，返回结果为原始值，转换结束\r\n\r\n此时 `1 + {}`，右侧为 `string` 类型，将 `1` 进行 `ToString()` 转化为 `\"1\"` ，最后字符串连接，结果为 `\"1[object Object]\"`\r\n\r\n**注意**： `{} + 1` 输出的结果会和 `1 + {}` 一样吗？\r\n\r\n```\r\n{}` 在 `JavaScript` 中，不止可以作为对象定义，也可以作为代码块的定义。`js` 引擎会把 `{} + 1` 解析成**1个代码块和1个+1**，最终输出结果为 `1\r\n```\r\n\r\n**答案**\r\n\r\n```js\r\n1[object Object]\r\n1\r\n复制代码\r\n```\r\n\r\n### 13.[]与{}的相加的结果是多少？\r\n\r\n#### `[] + {}`\r\n\r\n数组是特殊的对象，需要调用 `toPrimitive`，转换为原始值\r\n\r\n- 执行 `toPrimitive`，未传入 `PreferredType`，`methodNames` 为 `[valueOf, toString]`\r\n- 执行 `[].valueOf`，返回数组本身\r\n- 执行 `[].toString`，返回空字符串 `''`\r\n\r\n空对象不做赘述。\r\n\r\n**答案**\r\n\r\n```js\r\n\"[object Object]\"\r\n复制代码\r\n```\r\n\r\n#### `[] + []`\r\n\r\n类似 `1` 两个空数组都执行 `toPrimitive`，返回两个空字符串。\r\n\r\n**答案**\r\n\r\n```js\r\n\"\"\r\n复制代码\r\n```\r\n\r\n#### `{} + []`\r\n\r\n类似于 `{} + 1`，`{} + []` 相当于 `{}; + []`，一元 `+` 强制将 `\"\"` 隐式转换为`0`，最终结果为`0`\r\n\r\n**答案**\r\n\r\n```js\r\n0\r\n复制代码\r\n```\r\n\r\n#### `{} + {}`\r\n\r\n对于这个题，我先公布一下答案，之后说一下我的疑问。\r\n\r\n**答案**\r\n\r\n```js\r\n[object Object][object Object]\r\n复制代码\r\n```\r\n\r\n**疑问**\r\n\r\n为什么 `JavaScript` 引擎没有将前面的 `{}` 解释成代码块？\r\n\r\n> 友情提示：由于 `{}` 可以解释为代码块的形式，有些需要注意的地方，举个栗子:\r\n>\r\n> - 空对象调用方法时：`{}.toString()` 会报错\r\n> - 箭头函数返回对象时：`let getTempItem = id => { id: id, name: \"Temp\" }` 会报错\r\n\r\n### 14.你能灵活运用 parseInt 与 parseFloat 吗\r\n\r\n1. `parseInt`：从数字类开始看，看到非数字类为止，返回原来的数。(小数点也属于非有效数字)\r\n\r\n```js\r\nparseInt('123x') -> 123\r\nparseInt('-023x') -> -23\r\nparseInt('1.1') -> 1\r\nparseInt('-abc') -> NaN\r\nparseInt('x123') -> NaN\r\n复制代码\r\n```\r\n\r\n1. `parseInt(string, radix)` 还有第二个参数 `radix` 表示要解析数字的基数，取值为 `2~36` (默认值为`10`)\r\n2. `parseFloat` 与 `parseInt` 类似，只不过它返回浮点数。从数字类开始看，看到除了第一个点以外的非数字类为截止，返回前面的数。\r\n\r\n#### 网红题：['1','2','3'].map(parseInt)\r\n\r\n这个网红题考察的就是 `parseInt` 有两个参数。 `map` 传入的函数可执行三个参数：\r\n\r\n```js\r\n// ele   遍历的元素\r\n// index 遍历的元素索引\r\n// arr   数组\r\narr.map(function(ele, index, arr){})\r\n复制代码\r\n```\r\n\r\n['1','2','3'].map(parseInt)相当于执行了以下三次过程：\r\n\r\n```js\r\nparseInt('1', 0, ['1','2','3'])\r\nparseInt('2', 1, ['1','2','3'])\r\nparseInt('3', 2, ['1','2','3'])\r\n复制代码\r\n```\r\n\r\n- `parseInt('1', 0, ['1','2','3'])`: radix为0时，默认取10，最后返回1\r\n- `parseInt('2', 1, ['1','2','3'])`: radix取值为2~36，返回NaN\r\n- `parseInt('3', 2, ['1','2','3'])`: radix取值为2，二进制只包括0，1，返回NaN\r\n\r\n### 15.如何让 if(a == 1 && a == 2) 条件成立？\r\n\r\n`valueOf` 的应用\r\n\r\n```js\r\nvar a = {\r\n    value: 0,\r\n    valueOf: function() {\r\n        this.value++;\r\n        return this.value;\r\n    }\r\n};\r\nconsole.log(a == 1 && a == 2); //true\r\n```\r\n\r\n关于本文\r\n\r\nhttps://juejin.cn/post/7021750693262262308",contentRendered:'<h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言" aria-hidden="true">#</a> 前言</h2>\n<p>当下的前端开发，三大框架三分天下，框架的简单、强大让我们欲罢不能，使用原生 <code>JavaScript</code> 越来越少。</p>\n<p>但我认为 <code>JavaScript</code> 作为每一个前端工程师的立身之本，不止要学会，还要学好、学精，学再多遍都不为过。</p>\n<p>另一方面，前端面试中，越来越重视原生 <code>JavaScript</code> 的考察，其所占比例也越来越高。</p>\n<p>我抓取了牛客上今年的线上面试题和面经，大约 <code>500</code> 左右道题，原生 <code>JavaScript</code> 的难点(闭包，<code>eventLoop，this</code>，手撕原生JS)考察的频率非常高。</p>\n<blockquote>\n<p>完整的分析我还正在赶工中，希望大家到时候可以来支持一下。</p>\n</blockquote>\n<p>因此我决定整理<code>JavaScript</code>中容易忽视或者混淆的知识点，写一系列篇文章，以灵魂拷问的方式，系统且完整的带大家遨游原生 <code>JavaScript</code> 的世界，希望能给大家带来一些收获。</p>\n<h2 id="js类型之问——概念与检测篇" tabindex="-1"><a class="header-anchor" href="#js类型之问——概念与检测篇" aria-hidden="true">#</a> JS类型之问——概念与检测篇</h2>\n<h3 id="_1-js中的数据类型有哪些" tabindex="-1"><a class="header-anchor" href="#_1-js中的数据类型有哪些" aria-hidden="true">#</a> 1.JS中的数据类型有哪些？</h3>\n<ol>\n<li>基本数据类型：共有7种</li>\n</ol>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code>Boolean Number String <span class="token keyword">undefined</span> <span class="token keyword">null</span> Bigint Symbol\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><code>Symbol</code> ： <code>ES6</code> 引入的一种新的原始值，表示独一无二的值，主要为了解决属性名冲突问题。</p>\n<p><code>Bigint</code> ：<code>ES2020</code> 新增加，是比 <code>Number</code> 类型的整数范围更大。</p>\n<ol>\n<li>引用数据类型：1种</li>\n</ol>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token function">Object对象</span><span class="token punctuation">(</span>包括普通Object、Function、Array、Date、RegExp、Math<span class="token punctuation">)</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="_2-你真的懂typeof吗" tabindex="-1"><a class="header-anchor" href="#_2-你真的懂typeof吗" aria-hidden="true">#</a> 2.你真的懂typeof吗？</h3>\n<ol>\n<li>\n<p><code>typeof</code>的作用？</p>\n<p>区分数据类型，可以返回7种数据类型：<code>number、string、boolean、undefined、object、function</code> ，以及 <code>ES6</code> 新增的 <code>symbol</code></p>\n</li>\n<li>\n<p><code>typeof</code> 能正确区分数据类型吗？</p>\n<p>不能。对于原始类型，除 <code>null</code> 都可以正确判断；对于引用类型，除 <code>function</code> 外，都会返回 <code>&quot;object&quot;</code></p>\n</li>\n<li>\n<p><code>typeof</code> 注意事项</p>\n<ul>\n<li><code>typeof</code> 返回值为 <code>string</code> 格式，注意类似这种考题: <code>typeof(typeof(undefined)) -&gt; &quot;string&quot;</code></li>\n<li><code>typeof</code> 未定义的变量不会报错，返回 <code>&quot;undefiend&quot;</code></li>\n<li><code>typeof(null) -&gt; &quot;object&quot;</code>: 遗留已久的 <code>bug</code></li>\n<li><code>typeof</code>无法区别数组与普通对象: <code>typeof([]) -&gt; &quot;object&quot;</code></li>\n<li><code>typeof(NaN) -&gt; &quot;number&quot;</code></li>\n</ul>\n</li>\n<li>\n<p>习题</p>\n</li>\n</ol>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> \nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> \nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> \n<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">\'123abc\'</span><span class="token punctuation">;</span> \nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token operator">+</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> \nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> \nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span>a <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> \nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p><strong>答案</strong></p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">undefined</span> <span class="token comment">// b未定义，返回undefined</span>\n<span class="token keyword">undefined</span>\nnumber <span class="token comment">// NaN 为number类型</span>\nobject\nnumber <span class="token comment">// +a 类型转换为NaN</span>\nboolean\nstring\nstring <span class="token comment">// typeof(null) -> "object"; typeof("object") -> "string"</span>\nstring\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h3 id="_3-什么是instanceof-你能模拟实现一个instanceof吗" tabindex="-1"><a class="header-anchor" href="#_3-什么是instanceof-你能模拟实现一个instanceof吗" aria-hidden="true">#</a> 3.什么是instanceof？你能模拟实现一个instanceof吗？</h3>\n<ol>\n<li><code>instanceof</code> 判断对象的原型链上是否存在构造函数的原型。只能判断引用类型。</li>\n<li><code>instanceof</code> 常用来判断 <code>A</code> 是否为 <code>B</code> 的实例</li>\n</ol>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token comment">// A是B的实例，返回true，否则返回false</span>\n<span class="token comment">// 判断A的原型链上是否有B的原型</span>\n<span class="token constant">A</span> instaceof <span class="token constant">B</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ol>\n<li>模拟实现 <code>instanceof</code></li>\n</ol>\n<p>思想：沿原型链往上查找</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">instance_of</span><span class="token punctuation">(</span><span class="token parameter">Case<span class="token punctuation">,</span> Constructor</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 基本数据类型返回false</span>\n    <span class="token comment">// 兼容一下函数对象</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span>Case<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token string">\'object\'</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span><span class="token punctuation">(</span>Case<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token string">\'function\'</span><span class="token punctuation">)</span> <span class="token operator">||</span> Case <span class="token operator">==</span> <span class="token string">\'null\'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n    <span class="token keyword">let</span> CaseProto <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>Case<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 查到原型链顶端，仍未查到，返回false</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>CaseProto <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n        <span class="token comment">// 找到相同的原型</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>CaseProto <span class="token operator">===</span> <span class="token class-name">Constructor</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n        CaseProto <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>CaseProto<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>测试：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">instance_of</span><span class="token punctuation">(</span>Array<span class="token punctuation">,</span> Object<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true</span>\n<span class="token keyword">function</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">\'zc\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> vipUser <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">instance_of</span><span class="token punctuation">(</span>vipUser<span class="token punctuation">,</span> User<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="_4-如何区分数组与对象-使用instanceof判断数组可靠吗" tabindex="-1"><a class="header-anchor" href="#_4-如何区分数组与对象-使用instanceof判断数组可靠吗" aria-hidden="true">#</a> 4.如何区分数组与对象？使用instanceof判断数组可靠吗？</h3>\n<ol>\n<li><code>ES6</code> 提供的新方法 <code>Array.isArray()</code></li>\n<li>如果不存在<code>Array.isArray()</code>呢？可以借助<code>Object.prototype.toString.call()</code> 进行判断，此方式兼容性最好</li>\n</ol>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Array<span class="token punctuation">.</span>isArray<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    Array<span class="token punctuation">.</span><span class="token function-variable function">isArray</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token keyword">typeof</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">\'object\'</span> \n               <span class="token operator">&amp;&amp;</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">\'[object Array]\'</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ol>\n<li><code>instanceof</code> 判断</li>\n</ol>\n<p>判断方式</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token comment">// 如果为true，则arr为数组</span>\narr <span class="token keyword">instanceof</span> <span class="token class-name">Array</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><code>instanceof</code> 判断数组类型如此之简单，为何不推荐使用那？</p>\n<p><code>instanceof</code> 操作符的问题在于，如果网页中存在多个 <code>iframe</code> ，那便会存在多个 <code>Array</code> 构造函数，此时判断是否是数组会存在问题。</p>\n<p>更详细的内容可以参考博文：<a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fweixin_42467709%2Farticle%2Fdetails%2F105302852" target="_blank" rel="noopener noreferrer">JavaScript为啥不用instanceof检测数组 <ExternalLinkIcon/></a></p>\n<h3 id="_5-如何判断一个数是否为nan" tabindex="-1"><a class="header-anchor" href="#_5-如何判断一个数是否为nan" aria-hidden="true">#</a> 5.如何判断一个数是否为NaN？</h3>\n<p><code>NaN</code> 有个非常特殊的特性， <code>NaN</code> 与任何值都不相等，包括它自身</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token number">NaN</span> <span class="token operator">===</span> <span class="token number">NaN</span> <span class="token comment">// false</span>\n<span class="token number">NaN</span> <span class="token operator">==</span> <span class="token number">NaN</span> <span class="token comment">// false</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>鉴于这个独特的特性，可以手撕一个比较简单的判断函数</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> x <span class="token operator">!=</span> x<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul>\n<li>全局函数 <code>isNaN</code> 方法：不推荐使用。<code>MDN</code> 对它的介绍是：<code>isNaN</code> 函数内包含一些非常有趣的规则。</li>\n</ul>\n<p>但为了避免一些面试官出一些冷门题目，咱们来稍微了解一下 <code>isNaN</code> 的有趣机制：会先判断参数是不是 <code>Number</code> 类型，如果不是 <code>Number</code> 类型会尝试将这个参数转换为 <code>Number</code> 类型，之后再去判断是不是 <code>NaN</code> 。</p>\n<p>举个例子：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token comment">// 为什么对象会带来三种不同的结果</span>\n<span class="token comment">// 是不是很有趣</span>\n<span class="token comment">// 具体原因可以参考类型转换篇</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// false</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// false</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true </span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// false</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><code>isNaN</code> 的结果很大程度上取决于 <code>Number()</code> 类型转换的结果，关于 <code>Number</code> 的转换结果，后面会专门有一部分来介绍。</p>\n<ul>\n<li><code>Number.isNaN</code> (推荐使用)</li>\n</ul>\n<p>与 <code>isNaN()</code> 相比，<code>Number.isNaN()</code> 不会自行将参数转换成数字，只有在参数是值为 <code> NaN</code> 的数字时，才会返回 <code>true</code>。</p>\n<h3 id="_6-如何实现一个功能完善的类型判断函数" tabindex="-1"><a class="header-anchor" href="#_6-如何实现一个功能完善的类型判断函数" aria-hidden="true">#</a> 6.如何实现一个功能完善的类型判断函数？</h3>\n<p><code>Object.prototype.toString.call([value])</code> ，可以精准判断数据类型，因此可以根据这个原理封装一个自己的 <code>type</code> 方法。</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>       <span class="token comment">// [object Function]</span>\n<span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>           <span class="token comment">// [object Object]</span>\n<span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>           <span class="token comment">// [object Array]</span>\n<span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">\'\'</span><span class="token punctuation">)</span>           <span class="token comment">// [object String]</span>\n<span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token number">22</span><span class="token punctuation">)</span>           <span class="token comment">// [object Number]</span>\n<span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">)</span>    <span class="token comment">// [object undefined]</span>\n<span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>         <span class="token comment">// [object null]</span>\n<span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">)</span>     <span class="token comment">// [object Date]</span>\n<span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>Math<span class="token punctuation">)</span>         <span class="token comment">// [object Math]</span>\n<span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span>       <span class="token comment">// [object Window]</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="js类型之问——类型转换篇" tabindex="-1"><a class="header-anchor" href="#js类型之问——类型转换篇" aria-hidden="true">#</a> JS类型之问——类型转换篇</h2>\n<h3 id="_7-tostring-和-valueof-方法有什么区别" tabindex="-1"><a class="header-anchor" href="#_7-tostring-和-valueof-方法有什么区别" aria-hidden="true">#</a> 7.toString 和 valueOf 方法有什么区别？</h3>\n<ol>\n<li>基础：这两个方法属于 <code>Object</code> 对象，是为了解决 <code>JavaScript</code> 值运算与显示的问题。为了更适合自身功能，很多 <code>JavaScript</code> 内置对象都重写了这两个方法。</li>\n<li><code>toString()</code>: 返回当前对象的字符串形式；<code>valueOf()</code> : 返回该对象的原始值</li>\n<li>各个类型下两个方法返回值情况对比</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>valueOf</th>\n<th>toString</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Array[1,2,3]</td>\n<td>数组本身[1, 2, 3]</td>\n<td>1,2,3</td>\n</tr>\n<tr>\n<td>Object</td>\n<td>对象本身</td>\n<td>[object Object]</td>\n</tr>\n<tr>\n<td>Boolean类型</td>\n<td>Boolean值</td>\n<td>&quot;true&quot;或&quot;false&quot;</td>\n</tr>\n<tr>\n<td>Function</td>\n<td>函数本身</td>\n<td>function fnName(){code}</td>\n</tr>\n<tr>\n<td>Number</td>\n<td>数值</td>\n<td>数值的字符换表示</td>\n</tr>\n<tr>\n<td>Date</td>\n<td>毫米格式时间戳</td>\n<td>GMT格式时间字符串</td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li>\n<p>调用优先级</p>\n<p><strong>隐式转换时会自动调用 <code>toString</code> 和 <code>valueOf</code> 方法</strong>，两者优先级如下：</p>\n<ul>\n<li>强制转化为字符串类型时，优先调用 <code>toString</code> 方法</li>\n<li>强制转换为数值类型时，优先调用 <code>valueOf</code> 方法</li>\n<li>使用运算符操作符情况下，<code>valueOf</code> 优先级高于 <code>toStirng</code></li>\n<li>对象的类型转换见下一问。</li>\n</ul>\n</li>\n</ol>\n<h3 id="_8-你知道对象转换成原始值是什么流程吗-toprimitive" tabindex="-1"><a class="header-anchor" href="#_8-你知道对象转换成原始值是什么流程吗-toprimitive" aria-hidden="true">#</a> 8.你知道对象转换成原始值是什么流程吗 (ToPrimitive)？</h3>\n<p>对象转换成原始类型，会调用内置的 <code>[ToPrimitive]</code>函数</p>\n<p>(参考博客: <a href="https://juejin.cn/post/6988387082536222734#heading-8" target="_blank" rel="noopener noreferrer">从ECMA规范彻底理解 JavaScript 类型转换<ExternalLinkIcon/></a>)</p>\n<ul>\n<li>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>ToPrimitive\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>方法接受两个参数，一个是输入的值</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>input\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>，一个是期望转换的类型</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>PreferredType\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><ol>\n<li>如果未传入 <code>PreferredType</code> 参数，让 <code>hint</code> 等于 <code>\'default\'</code>，后面会将 <code>hint</code> 修改为 <code>\'number\'</code></li>\n<li>如果 <code>PreferredType</code> 是 <code>hint String</code>，让 <code>hint</code> 等于 <code>\'string\'</code></li>\n<li>如果 <code>PreferredType</code> 是 <code>hint Number</code>，让 <code>hint</code> 等于 <code>\'number\'</code></li>\n<li>返回 <code>OrdinaryToPrimitive(input, hint)</code></li>\n</ol>\n</li>\n<li>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>OrdinaryToPrimitive(input, hint)\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><ol>\n<li>如果 <code>hint</code> 是 <code>\'string\'</code>，那么就将 <code>methodNames</code> 设置为 <code>toString、valueOf</code></li>\n<li>如果 <code>hint</code> 是 <code>\'number\'</code>，那么就将 <code>methodNames</code> 设置为 <code>valueOf、toString</code></li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p><code>methodName</code> 存储的就是当前 <code>preferredType</code> 下的调用优先级，如果全部调用完毕仍然未转化为原始值，会发生报错。</p>\n</blockquote>\n<h3 id="_9-你能做出下面这个题吗" tabindex="-1"><a class="header-anchor" href="#_9-你能做出下面这个题吗" aria-hidden="true">#</a> 9.你能做出下面这个题吗？</h3>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">x</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">x</span><span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\nobj<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>\nobj<span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>有了第七问和第八问的知识，这个题目就不难了。 <code>JavaScript</code> 对象的键必须是字符串，因此分别需要将对象 <code>a</code> 和 <code>b</code> 转换为 <code>string</code> 类型。具体转换流程：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token comment">// 1.执行ToPrimitive</span>\n<span class="token comment">// hint 为 string</span>\n<span class="token function">ToPrimitive</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token string">\'hint String\'</span><span class="token punctuation">)</span>\n<span class="token comment">// 2.执行OrdinaryToPrimitive</span>\n<span class="token function">OrdinaryToPrimitive</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token string">\'string\'</span><span class="token punctuation">)</span>\n<span class="token comment">// 3.返回methodNames</span>\nmethodNames <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">\'toString\'</span><span class="token punctuation">,</span> <span class="token string">\'valueOf\'</span><span class="token punctuation">]</span>\n<span class="token comment">// 4.调用methodNames里方法</span>\n<span class="token comment">// 调用toString</span>\na<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 返回[object Object]</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>对象 <code>a</code> 和 <code>b</code> 转换后的结果都是 <code>[object Object]</code>，<code>obj</code> 对象上只添加了一个属性 <code>[object Object]</code>。</p>\n<p><strong>答案</strong></p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token number">200</span>\n<span class="token number">200</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="_10-你能理清类型转换吗" tabindex="-1"><a class="header-anchor" href="#_10-你能理清类型转换吗" aria-hidden="true">#</a> 10.你能理清类型转换吗？</h3>\n<p>首先需要知道：在<code>JavaScript</code>中，只有<strong>三种类型</strong>的转换</p>\n<ul>\n<li>转换为<code>Number</code>类型: <code>Number() / parseFloat() / parseInt()</code></li>\n<li>转化为<code>String</code>类型:<code> String() / toString()</code></li>\n<li>转化为<code>Boolean</code>类型: <code>Boolean()</code></li>\n</ul>\n<p>因此遇到类型转换问题，只需要弄清楚在<strong>什么场景</strong>之下转换成<strong>那种类型</strong>即可。</p>\n<h4 id="转换为boolean" tabindex="-1"><a class="header-anchor" href="#转换为boolean" aria-hidden="true">#</a> 转换为boolean</h4>\n<ul>\n<li>显式：<code>Boolean</code> 方法可以显式将值转换为布尔类型</li>\n<li>隐式：通常在逻辑判断或者有逻辑运算符时触发（<code>|| &amp;&amp; !</code>）</li>\n</ul>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>   <span class="token comment">// 显式类型转换</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment">// 逻辑判断类型触发隐式转换</span>\n<span class="token operator">!</span><span class="token operator">!</span><span class="token number">1</span>          <span class="token comment">// 逻辑运算符触发隐式转换</span>\n<span class="token number">1</span> <span class="token operator">||</span> <span class="token string">\'hello\'</span> <span class="token comment">// 逻辑运算符触发隐式转换</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><code>boolean</code> 类型只有 <code>true</code> 和 <code>false</code> 两种值。</p>\n<p>除值 <strong>0,-0,null,NaN,undefined,或空字符串（&quot;&quot;）</strong> 为 <code>false</code> 外，其余全为 <code>true</code></p>\n<h4 id="转化为string" tabindex="-1"><a class="header-anchor" href="#转化为string" aria-hidden="true">#</a> 转化为string</h4>\n<ul>\n<li>显式：<code>String</code> 方法可以显式将值转换为字符串</li>\n<li>隐式：<code>+</code> 运算符有一侧操作数为 <code>string</code> 类型时</li>\n</ul>\n<p>转化为 <code>string</code> 类型的本质：<strong>需要转换为string的部分调用自身的toString方法(null/undefined返回字符串格式的null和undefined)</strong></p>\n<blockquote>\n<p>当被转换值为对象时，相当于执行 <code>ToPrimitive(input, \'hint String\')</code></p>\n</blockquote>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 1,2,3</span>\n<span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">x</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// [object Object]</span>\n\n<span class="token number">1</span> <span class="token operator">+</span> <span class="token string">\'1\'</span> <span class="token comment">// 11</span>\n<span class="token number">1</span> <span class="token operator">+</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 1[object Object]</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h4 id="转化为number" tabindex="-1"><a class="header-anchor" href="#转化为number" aria-hidden="true">#</a> 转化为number</h4>\n<ul>\n<li>显式：<code>Number</code> 方法可以显式将值转化为数字类型</li>\n</ul>\n<p><code>Number</code> 的具体规则，<code>ES5</code> 规范中给了一个<a href="https://link.juejin.cn?target=http%3A%2F%2Fes5.github.io%2F%23x9.3" target="_blank" rel="noopener noreferrer">对应的结果表<ExternalLinkIcon/></a></p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>结果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>undefined</td>\n<td>NaN</td>\n</tr>\n<tr>\n<td>null</td>\n<td>+0</td>\n</tr>\n<tr>\n<td>Boolean</td>\n<td>NaN</td>\n</tr>\n<tr>\n<td>undefined</td>\n<td>参数为true返回1；false返回+0</td>\n</tr>\n<tr>\n<td>Number</td>\n<td>返回与之相等的值</td>\n</tr>\n<tr>\n<td>String</td>\n<td>有些复杂，举例说明</td>\n</tr>\n<tr>\n<td>Object</td>\n<td>先执行ToPrimitive方法，在执行Number类型转换</td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li><code>String</code>: 空字符串返回 <code>0</code>，出现任何一个非有效数字字符，返回 <code>NaN</code></li>\n</ol>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">"1 3"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// NaN</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// NaN</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">"1a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// NaN</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">"0x11"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 17</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 123</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">"-123"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// -123</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">"1.2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 1.2</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ul>\n<li>\n<p>隐式：</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>number\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>的隐式类型转换比较复杂，对需要隐式转换的部分执行</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>Number\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>：</p>\n<ul>\n<li>比较操作(<code>&lt;, &gt;, &lt;=, &gt;=</code>)</li>\n<li>按位操作(<code>| &amp; ^ ~</code>)</li>\n<li>算数操作(<code>+ - * / %</code>) 注意：<strong>+的操作数存在字符串时，为string转换</strong></li>\n<li>一元 <code>+-</code> 操作</li>\n</ul>\n</li>\n</ul>\n<h3 id="_11-的隐式转换规则" tabindex="-1"><a class="header-anchor" href="#_11-的隐式转换规则" aria-hidden="true">#</a> 11.== 的隐式转换规则</h3>\n<ol>\n<li><code>==</code>: 只需要值相等，无需类型相等；<code>null, undefined</code> 在 <code>==</code> 下互相等且自身等</li>\n<li><code>==</code> 的转换规则:</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>被比较数B</th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td></td>\n<td></td>\n<td>Number</td>\n<td>String</td>\n<td>Boolean</td>\n<td>Object</td>\n</tr>\n<tr>\n<td>比较数A</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Number</td>\n<td>A == B</td>\n<td>A == ToNumber(B)</td>\n<td>A == ToNumber(B)</td>\n<td>A == ToPrimitive(B)</td>\n<td></td>\n</tr>\n<tr>\n<td>String</td>\n<td>ToNumber(A) == B</td>\n<td>A == B</td>\n<td>ToNumber(A) == ToNumber(B)</td>\n<td>ToPrimitive(B) == A</td>\n<td></td>\n</tr>\n<tr>\n<td>Boolean</td>\n<td>ToNumber(A) == B</td>\n<td>ToNumber(A) == ToNumber(B)</td>\n<td>ToNumber(A) == ToNumber(B)</td>\n<td>ToNumber(A) == ToPrimitive(B)</td>\n<td></td>\n</tr>\n<tr>\n<td>Object</td>\n<td>ToPrimitive(A) == B</td>\n<td>ToPrimitive(A) == B</td>\n<td>ToPrimitive(A) == ToPrimitive(B)</td>\n<td>A === B</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>在上面的表格中，<code>ToNumber(A)</code> 尝试在比较前将参数 <code>A</code> 转换为数字。<code>ToPrimitive(A)</code> 将参数 <code>A</code> 转换为原始值( <code>Primitive</code> )。</p>\n<h3 id="_12-1-与-1的输出结果分别是什么" tabindex="-1"><a class="header-anchor" href="#_12-1-与-1的输出结果分别是什么" aria-hidden="true">#</a> 12.<code>1 + {}</code> 与 <code>{} + 1</code>的输出结果分别是什么？</h3>\n<p>通过上面的学习，当对象与其他元素相加时，对象会调用 <code>toPrimitive</code> 转化为原始值：</p>\n<ol>\n<li>执行 <code>toPrimitive</code>，未传入 <code>PreferredType</code>，<code>methodNames</code> 为 <code>[valueOf, toString]</code></li>\n<li>执行 <code>({}).valueOf</code>，返回对象本身 <code>{}</code>，不是原始值</li>\n<li>继续执行 <code>({}).toString()</code>，返回 <code>&quot;[object Object]&quot;</code>，返回结果为原始值，转换结束</li>\n</ol>\n<p>此时 <code>1 + {}</code>，右侧为 <code>string</code> 类型，将 <code>1</code> 进行 <code>ToString()</code> 转化为 <code>&quot;1&quot;</code> ，最后字符串连接，结果为 <code>&quot;1[object Object]&quot;</code></p>\n<p><strong>注意</strong>： <code>{} + 1</code> 输出的结果会和 <code>1 + {}</code> 一样吗？</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>{}` 在 `JavaScript` 中，不止可以作为对象定义，也可以作为代码块的定义。`js` 引擎会把 `{} + 1` 解析成**1个代码块和1个+1**，最终输出结果为 `1\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p><strong>答案</strong></p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token number">1</span><span class="token punctuation">[</span>object Object<span class="token punctuation">]</span>\n<span class="token number">1</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="_13-与-的相加的结果是多少" tabindex="-1"><a class="header-anchor" href="#_13-与-的相加的结果是多少" aria-hidden="true">#</a> 13.[]与{}的相加的结果是多少？</h3>\n<h4 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a> <code>[] + {}</code></h4>\n<p>数组是特殊的对象，需要调用 <code>toPrimitive</code>，转换为原始值</p>\n<ul>\n<li>执行 <code>toPrimitive</code>，未传入 <code>PreferredType</code>，<code>methodNames</code> 为 <code>[valueOf, toString]</code></li>\n<li>执行 <code>[].valueOf</code>，返回数组本身</li>\n<li>执行 <code>[].toString</code>，返回空字符串 <code>\'\'</code></li>\n</ul>\n<p>空对象不做赘述。</p>\n<p><strong>答案</strong></p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token string">"[object Object]"</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="-1" tabindex="-1"><a class="header-anchor" href="#-1" aria-hidden="true">#</a> <code>[] + []</code></h4>\n<p>类似 <code>1</code> 两个空数组都执行 <code>toPrimitive</code>，返回两个空字符串。</p>\n<p><strong>答案</strong></p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token string">""</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="-2" tabindex="-1"><a class="header-anchor" href="#-2" aria-hidden="true">#</a> <code>{} + []</code></h4>\n<p>类似于 <code>{} + 1</code>，<code>{} + []</code> 相当于 <code>{}; + []</code>，一元 <code>+</code> 强制将 <code>&quot;&quot;</code> 隐式转换为<code>0</code>，最终结果为<code>0</code></p>\n<p><strong>答案</strong></p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token number">0</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="-3" tabindex="-1"><a class="header-anchor" href="#-3" aria-hidden="true">#</a> <code>{} + {}</code></h4>\n<p>对于这个题，我先公布一下答案，之后说一下我的疑问。</p>\n<p><strong>答案</strong></p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token punctuation">[</span>object Object<span class="token punctuation">]</span><span class="token punctuation">[</span>object Object<span class="token punctuation">]</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>疑问</strong></p>\n<p>为什么 <code>JavaScript</code> 引擎没有将前面的 <code>{}</code> 解释成代码块？</p>\n<blockquote>\n<p>友情提示：由于 <code>{}</code> 可以解释为代码块的形式，有些需要注意的地方，举个栗子:</p>\n<ul>\n<li>空对象调用方法时：<code>{}.toString()</code> 会报错</li>\n<li>箭头函数返回对象时：<code>let getTempItem = id =&gt; { id: id, name: &quot;Temp&quot; }</code> 会报错</li>\n</ul>\n</blockquote>\n<h3 id="_14-你能灵活运用-parseint-与-parsefloat-吗" tabindex="-1"><a class="header-anchor" href="#_14-你能灵活运用-parseint-与-parsefloat-吗" aria-hidden="true">#</a> 14.你能灵活运用 parseInt 与 parseFloat 吗</h3>\n<ol>\n<li><code>parseInt</code>：从数字类开始看，看到非数字类为止，返回原来的数。(小数点也属于非有效数字)</li>\n</ol>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">\'123x\'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token number">123</span>\n<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">\'-023x\'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token operator">-</span><span class="token number">23</span>\n<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">\'1.1\'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token number">1</span>\n<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">\'-abc\'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token number">NaN</span>\n<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">\'x123\'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token number">NaN</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ol>\n<li><code>parseInt(string, radix)</code> 还有第二个参数 <code>radix</code> 表示要解析数字的基数，取值为 <code>2~36</code> (默认值为<code>10</code>)</li>\n<li><code>parseFloat</code> 与 <code>parseInt</code> 类似，只不过它返回浮点数。从数字类开始看，看到除了第一个点以外的非数字类为截止，返回前面的数。</li>\n</ol>\n<h4 id="网红题-1-2-3-map-parseint" tabindex="-1"><a class="header-anchor" href="#网红题-1-2-3-map-parseint" aria-hidden="true">#</a> 网红题：[\'1\',\'2\',\'3\'].map(parseInt)</h4>\n<p>这个网红题考察的就是 <code>parseInt</code> 有两个参数。 <code>map</code> 传入的函数可执行三个参数：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token comment">// ele   遍历的元素</span>\n<span class="token comment">// index 遍历的元素索引</span>\n<span class="token comment">// arr   数组</span>\narr<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">ele<span class="token punctuation">,</span> index<span class="token punctuation">,</span> arr</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>[\'1\',\'2\',\'3\'].map(parseInt)相当于执行了以下三次过程：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">\'1\'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">\'1\'</span><span class="token punctuation">,</span><span class="token string">\'2\'</span><span class="token punctuation">,</span><span class="token string">\'3\'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">\'2\'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">\'1\'</span><span class="token punctuation">,</span><span class="token string">\'2\'</span><span class="token punctuation">,</span><span class="token string">\'3\'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">\'3\'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">\'1\'</span><span class="token punctuation">,</span><span class="token string">\'2\'</span><span class="token punctuation">,</span><span class="token string">\'3\'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul>\n<li><code>parseInt(\'1\', 0, [\'1\',\'2\',\'3\'])</code>: radix为0时，默认取10，最后返回1</li>\n<li><code>parseInt(\'2\', 1, [\'1\',\'2\',\'3\'])</code>: radix取值为2~36，返回NaN</li>\n<li><code>parseInt(\'3\', 2, [\'1\',\'2\',\'3\'])</code>: radix取值为2，二进制只包括0，1，返回NaN</li>\n</ul>\n<h3 id="_15-如何让-if-a-1-a-2-条件成立" tabindex="-1"><a class="header-anchor" href="#_15-如何让-if-a-1-a-2-条件成立" aria-hidden="true">#</a> 15.如何让 if(a == 1 &amp;&amp; a == 2) 条件成立？</h3>\n<p><code>valueOf</code> 的应用</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>\n    <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>\n    <span class="token function-variable function">valueOf</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token operator">++</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>关于本文</p>\n<p>https://juejin.cn/post/7021750693262262308</p>\n',date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:"/JS/原生JS.html",pathLocale:"/",permalink:null,routeMeta:{},slug:"原生JS",filePath:"C:/Users/mi/Desktop/我的博客/docs/JS/原生JS.md",filePathRelative:"JS/原生JS.md",componentFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/JS/原生JS.html.vue",componentFilePathRelative:"pages/JS/原生JS.html.vue",componentFileChunkName:"v-3f77dce2",dataFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/JS/原生JS.html.js",dataFilePathRelative:"pages/JS/原生JS.html.js",dataFileChunkName:"v-3f77dce2",htmlFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/dist/JS/原生JS.html",htmlFilePathRelative:"JS/原生JS.html"},{data:{key:"v-39cc4c5a",path:"/Navigation/interview.html",title:"interview-1",lang:"zh-CN",frontmatter:{date:"2022/2/4 11:08",coverUrl:"http://cdn-ali-img-shstaticbz.shanhutech.cn/bizhi/staticwp/202111/bf510fc53ed6ffc5c5a215992c7c8f60--761544518.jpg",sticky:!0,keyword:"面试表达",description:"interview expression",title:"interview-1",tag:["笔记"],categories:["面试表达"]},excerpt:"",headers:[{level:2,title:"一、事件循环",slug:"一、事件循环",children:[{level:3,title:"EventLoop",slug:"eventloop",children:[]}]},{level:2,title:"二、this是什么",slug:"二、this是什么",children:[{level:3,title:"关于this指针的指向问题",slug:"关于this指针的指向问题",children:[]}]},{level:2,title:"三、闭包相关问题",slug:"三、闭包相关问题",children:[]},{level:2,title:"四、vue的生命周期",slug:"四、vue的生命周期",children:[]},{level:2,title:"五、web前端开发技术的优化策略",slug:"五、web前端开发技术的优化策略",children:[{level:3,title:"减少页面加载时间的方式",slug:"减少页面加载时间的方式",children:[]}]},{level:2,title:"六、回流和重绘",slug:"六、回流和重绘",children:[{level:3,title:"何时发生回流重绘",slug:"何时发生回流重绘",children:[]},{level:3,title:"减少重排重绘的方法",slug:"减少重排重绘的方法",children:[]},{level:3,title:"浏览器的优化机制",slug:"浏览器的优化机制",children:[]}]},{level:2,title:"七、常见的HTTP状态码",slug:"七、常见的http状态码",children:[{level:3,title:"状态码分类：",slug:"状态码分类",children:[]},{level:3,title:"常见的HTTP状态码列表:",slug:"常见的http状态码列表",children:[]}]},{level:2,title:"八、Ajax如何使用",slug:"八、ajax如何使用",children:[]},{level:2,title:"九、下面代码中 a 在什么情况下会打印 1？",slug:"九、下面代码中-a-在什么情况下会打印-1",children:[]},{level:2,title:"十、介绍下 BFC 及其应用",slug:"十、介绍下-bfc-及其应用",children:[]},{level:2,title:"十一、对sort()的理解",slug:"十一、对sort-的理解",children:[]},{level:2,title:"十二、call、apply、bind的区别",slug:"十二、call、apply、bind的区别",children:[]},{level:2,title:"十三、分析比较 opacity: 0、visibility: hidden、display: none 优劣和适用场景。",slug:"十三、分析比较-opacity-0、visibility-hidden、display-none-优劣和适用场景。",children:[]},{level:2,title:"十四、ES6 代码转成 ES5 代码的实现思路是什么",slug:"十四、es6-代码转成-es5-代码的实现思路是什么",children:[]},{level:2,title:"十五、数组里面有10万个数据，取第一个元素和第10万个元素的时间相差多少",slug:"十五、数组里面有10万个数据-取第一个元素和第10万个元素的时间相差多少",children:[]},{level:2,title:"十六、Vue 的父组件和子组件生命周期钩子执行顺序是什么",slug:"十六、vue-的父组件和子组件生命周期钩子执行顺序是什么",children:[]},{level:2,title:"十七、import导入的模块",slug:"十七、import导入的模块",children:[]},{level:2,title:"十八、var、let 和 const",slug:"十八、var、let-和-const",children:[]},{level:2,title:"十九、 Object.steal()和Object.freezze()",slug:"十九、-object-steal-和object-freezze",children:[]}],git:{updatedTime:null,contributors:[]}},key:"v-39cc4c5a",path:"/Navigation/interview.html",title:"interview-1",lang:"zh-CN",frontmatter:{date:"2022/2/4 11:08",coverUrl:"http://cdn-ali-img-shstaticbz.shanhutech.cn/bizhi/staticwp/202111/bf510fc53ed6ffc5c5a215992c7c8f60--761544518.jpg",sticky:!0,keyword:"面试表达",description:"interview expression",title:"interview-1",tag:["笔记"],categories:["面试表达"]},excerpt:"",headers:[{level:2,title:"一、事件循环",slug:"一、事件循环",children:[{level:3,title:"EventLoop",slug:"eventloop",children:[]}]},{level:2,title:"二、this是什么",slug:"二、this是什么",children:[{level:3,title:"关于this指针的指向问题",slug:"关于this指针的指向问题",children:[]}]},{level:2,title:"三、闭包相关问题",slug:"三、闭包相关问题",children:[]},{level:2,title:"四、vue的生命周期",slug:"四、vue的生命周期",children:[]},{level:2,title:"五、web前端开发技术的优化策略",slug:"五、web前端开发技术的优化策略",children:[{level:3,title:"减少页面加载时间的方式",slug:"减少页面加载时间的方式",children:[]}]},{level:2,title:"六、回流和重绘",slug:"六、回流和重绘",children:[{level:3,title:"何时发生回流重绘",slug:"何时发生回流重绘",children:[]},{level:3,title:"减少重排重绘的方法",slug:"减少重排重绘的方法",children:[]},{level:3,title:"浏览器的优化机制",slug:"浏览器的优化机制",children:[]}]},{level:2,title:"七、常见的HTTP状态码",slug:"七、常见的http状态码",children:[{level:3,title:"状态码分类：",slug:"状态码分类",children:[]},{level:3,title:"常见的HTTP状态码列表:",slug:"常见的http状态码列表",children:[]}]},{level:2,title:"八、Ajax如何使用",slug:"八、ajax如何使用",children:[]},{level:2,title:"九、下面代码中 a 在什么情况下会打印 1？",slug:"九、下面代码中-a-在什么情况下会打印-1",children:[]},{level:2,title:"十、介绍下 BFC 及其应用",slug:"十、介绍下-bfc-及其应用",children:[]},{level:2,title:"十一、对sort()的理解",slug:"十一、对sort-的理解",children:[]},{level:2,title:"十二、call、apply、bind的区别",slug:"十二、call、apply、bind的区别",children:[]},{level:2,title:"十三、分析比较 opacity: 0、visibility: hidden、display: none 优劣和适用场景。",slug:"十三、分析比较-opacity-0、visibility-hidden、display-none-优劣和适用场景。",children:[]},{level:2,title:"十四、ES6 代码转成 ES5 代码的实现思路是什么",slug:"十四、es6-代码转成-es5-代码的实现思路是什么",children:[]},{level:2,title:"十五、数组里面有10万个数据，取第一个元素和第10万个元素的时间相差多少",slug:"十五、数组里面有10万个数据-取第一个元素和第10万个元素的时间相差多少",children:[]},{level:2,title:"十六、Vue 的父组件和子组件生命周期钩子执行顺序是什么",slug:"十六、vue-的父组件和子组件生命周期钩子执行顺序是什么",children:[]},{level:2,title:"十七、import导入的模块",slug:"十七、import导入的模块",children:[]},{level:2,title:"十八、var、let 和 const",slug:"十八、var、let-和-const",children:[]},{level:2,title:"十九、 Object.steal()和Object.freezze()",slug:"十九、-object-steal-和object-freezze",children:[]}],content:"## 一、事件循环\r\n> Javascript是一门单线程语言，只有前一个任务执行完毕才会运行下一个任务，为了规避掉资源分配的浪费，所以将Javascript的任务分为同步任务和异步任务 \r\n>\r\n> > 异步任务又分为宏任务和微任务\r\n### EventLoop\r\n> 先执行同步操作，异步操作排在事件队列里\r\n1. 先判断是同步还是异步，同步任务进入主线程，异步任务进入Event Table(任务队列)\r\n2. 异步任务在Event Table中注册事件，当满足促发条件的时候，会被推入到Event Queue(事件队列)\r\n3. 主线程空闲时，才会在Event Queue中看是否又需要执行的异步任务，如果有，就推入主线程中执行\r\n>异步任务执行顺序为先执行微任务，在执行宏任务\r\n\r\n---\r\n\r\n## 二、this是什么\r\n  当一个函数被调用时,会创建一个执行上下文,这个执行上下文包含函数在哪里调用(调用栈),函数的调用方法,传入的参数等,**this**就是用来记录当前这个执行上下文信息的一个属性\r\n### 关于this指针的指向问题\r\n1. **this**始终会指向一个对象,是根据函数的执行环境来决定的,函数作为一个对象的方法被调用的话,**this**就指向这个对象\r\n2. 如果是new的话,**this**就指向new出来的这个实例化对象\r\n3. 因为匿名函数和自执行函数的执行环境具有全局性,所以它的this一般指向window\r\n4. 箭头函数没有自己的this,它里面的**this**的指向跟外部作用域中**this**指向一致\r\n\r\n---\r\n\r\n## 三、闭包相关问题\r\n> 当内部函数被保存到外部时,将会产生闭包\r\n\r\n***定义***:在JavaScript中,根据词法作用域的规则,内部函数总是可以访问其外部函数中申明的变量,当通过调用一个外部函数返回一个内部函数后,即使该外部函数已经执行结束,但是内部函数引用外部函数的变量,依然保存在内存中,我们把这些变量的集合称为闭包\r\n\r\n***缺点***:闭包会导致原有的作用域链不释放,造成内存泄漏\\\r\n***优点***:\r\n1. 实现公有化变量 (企业的模块开发) \r\n2. 做缓存 \r\n3. 实现属性的私有化\r\n4. 模块化开发，防止污染全局变量\r\n> 变量长期驻扎在内存中,避免全局变量的污染,私有成员的存在\r\n\r\n---\r\n\r\n## 四、vue的生命周期\r\n\r\n>Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、销毁等一系列过程，我们称这是Vue的生命周期。通俗说就是Vue实例从创建到销毁的过程，就是生命周期。\r\n\r\n每一个组件或者实例都会经历一个完整的生命周期，总共分为三个阶段：初始化、运行中、销毁。\r\n1. 实例、组件通过new Vue() 创建出来之后会初始化事件和生命周期，然后就会执行**beforeCreate**钩子函数，这个时候，数据还没有挂载呢，只是一个空壳，无法访问到数据和真实的dom，一般不做操作\r\n2. 挂载数据，绑定事件等等，然后执行**created**函数，这个时候已经可以使用到数据，也可以更改数据,在这里更改数据不会触发updated函数，在这里可以在渲染前倒数第二次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取\r\n3. 接下来开始找实例或者组件对应的模板，编译模板为虚拟dom放入到render函数中准备渲染，然后执行**beforeMount**钩子函数，在这个函数中虚拟dom已经创建完成，马上就要渲染,在这里也可以更改数据，不会触发**updated**，在这里可以在渲染前最后一次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取\r\n4. 接下来开始render，渲染出真实dom，然后执行**mounted**钩子函数，此时，组件已经出现在页面中，数据、真实dom都已经处理好了,事件都已经挂载好了，可以在这里操作真实dom等事情...\r\n5. 当组件或实例的数据更改之后，会立即执行**beforeUpdate**，然后vue的虚拟dom机制会重新构建虚拟dom与上一次的虚拟dom树利用diff算法进行对比之后重新渲染，一般不做什么事儿\r\n6. 当更新完成后，执行**updated**，数据已经更改完成，dom也重新render完成，可以操作更新后的虚拟dom\r\n7. 当经过某种途径调用$destroy方法后，立即执行**beforeDestroy**，一般在这里做一些善后工作，例如清除计时器、清除非指令绑定的事件等等\r\n8. 组件的数据绑定、监听...去掉后只剩下dom空壳，这个时候，执行**destroyed**，在这里做善后工作也可以\r\n\r\n---\r\n\r\n## 五、web前端开发技术的优化策略\r\n[web前端开发技术的优化策略](https://blog.csdn.net/smell201611010513/article/details/103784242)\r\n1. 减少HTTP请求数\r\n2. 优化文件的规模\r\n3. 减少DNS查找\r\n4. 杜绝无用响应\r\n5. 有效避免重定向\r\n6. 优化网页内容\r\n\r\n### 减少页面加载时间的方式\r\n1. 优化图片 \r\n2. 图像格式的选择（GIF：提供的颜色较少，可用在一些对颜色要求不高的地方） \r\n3. 优化CSS（压缩合并css，如 margin-top, margin-left...) \r\n4. 网址后加斜杠（如www.campr.com/目录，会判断这个目录是什么文件类型，或者是目录。） \r\n5. cdn托管 \r\n6. 标明高度和宽度（如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小，如果图片很多，浏览器需要不断地调整页面。这不但影响速度，也影响浏览体验。\\\r\n当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加 载后面的内容。从而加载时间快了，浏览体验也更好了）\r\n7. 减少http请求（合并文件，合并图片）\r\n\r\n---\r\n## 六、回流和重绘\r\n**回流**：当render tree中的一部分或者全部因为元素的规模尺寸，布局，隐藏等改变而需要重新构建，这就叫回流\r\n>每个页面至少需要一次回流，就是在页面第一次加载的时候，这时候一定会发生回流，因为要构建render tree\r\n\r\n**重绘**:在回流的时候，浏览器会使渲染树中收到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏 览器会重新绘制受影响的部分到屏幕中，这就是重绘\r\n>当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，不会影响布局，就叫重绘\r\n\r\n### 何时发生回流重绘\r\n- 回流这一阶段主要是计算节点的位置和几何信息，那么当页面布局和几何信息发生变化的时候，就需要回流。比如以下情况：\r\n- 添加或删除可见的DOM元素\r\n- 元素的位置发生变化\r\n- 元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）\r\n- 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。\r\n- 页面一开始渲染的时候（这肯定避免不了）\r\n- 浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）\r\n\r\n**注意：回流一定会触发重绘，而重绘不一定会回流**\r\n\r\n### 减少重排重绘的方法\r\n[减少重排重绘的方法](https://github.com/chenjigeng/blog/issues/4)\r\n### 浏览器的优化机制\r\n目前大多数浏览器，都会通过队列化来批量的修改重排的过程，浏览器会将修改操作放到队列中，直到一段时间后，队列的存储达到阈值，才会一次性全部重排，清空队列；**但是！当你获取布局信息的操作的时候，会强制队列刷新**\r\n- offsetTop、offsetLeft、offsetWidth、offsetHeight\r\n- scrollTop、scrollLeft、scrollWidth、scrollHeight\r\n- clientTop、clientLeft、clientWidth、clientHeight\r\n- getComputedStyle()\r\n- getBoundingClientRect\r\n>以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。因此，我们在修改样式的时候，**最好避免使用上面列出的属性，他们都会刷新渲染队列**如果要使用它们，最好将值缓存起来。\r\n\r\n---\r\n\r\n## 七、常见的HTTP状态码\r\n\r\n### 状态码分类：\r\n\r\n| 分类      | \t分类描述                                       |\r\n| --------- | ------------------------------------------- |\r\n| 1**       | 信息，服务器收到请求，需要请求者继续执行操作    |\r\n| 2**       | 成功，操作被成功接收并处理                     |\r\n| 3**       | 重定向，需要进一步的操作以完成请求              |\r\n| 4**       | 客户端错误，请求包含语法错误或无法完成请求       |\r\n| 5**       | 服务器错误，服务器在处理请求的过程中发生了错误   |\r\n\r\n\r\n### 常见的HTTP状态码列表:\r\n| 状态码 |     描述                                      |\r\n| --------- | ------------------------------------------- |\r\n| ***100*** | 这个状态码告诉客户应该继续发送请求，这个临时响应是用来通知客户端的，部分的请求服务器已经接受，但是客户端应该继续发送请求的剩余部分，如果请求已经完成，就忽略这个响应，而且服务器会在请求完成后向客户发送一个最终的结果。|\r\n| ***200*** | 这个是最常见的http状态码，表示服务器已经成功接受请求，并将返回客户端所请求的最终结果。|\r\n| ***202*** | 表示服务器已经接受了请求，但是还没有处理，而且这个请求最终会不会处理还不确定。|\r\n| ***204*** | 服务器成功处理了请求，但没有返回任何实体内容，可能会返回新的头部元信息。|\r\n| ***301*** | 客户端请求的页面已经永久移动到新的位置，当链接发生变化时，返回301代码告诉客户端连接的变化，客户端保存新的链接，并向新的链接发出请求，已返回请求结果。|\r\n| ***404*** | 请求失败，客户端请求的资源没有找到或者是不存在。|\r\n| ***500*** | 服务器遇到未知的错误，导致无法完成客户端当前的请求。|\r\n| ***503*** | 服务器由于临时的服务器过载或者是维护，无法解决当前的请求。|\r\n\r\n[参考](https://www.runoob.com/http/http-status-codes.html)\r\n\r\n\r\n---\r\n\r\n## 八、Ajax如何使用\r\n一个完整的AJAX请求包括五个步骤：\r\n具体来说，AJAX 包括以下几个步骤。\r\n\r\n1. 创建 XMLHttpRequest 对象，也就是创建一个异步调用对象\r\n\r\n2. 创建一个新的 HTTP 请求，并指定该 HTTP 请求的方法、URL 及验证信息\r\n\r\n3. 设置响应 HTTP 请求状态变化的函数\r\n\r\n4. 发送 HTTP 请求\r\n\r\n5. 获取异步调用返回的数据\r\n\r\n6. 使用 JavaScript 和 DOM 实现局部刷新\r\n\r\n\r\n```js\r\n// 创建可以请求的实例对象\r\nvar myAjax = new XMLHttpRequest()\r\n// 设置请求的url参数，这是准备工作\r\nmyAjax.open('GET', 'https://autumnfish.cn/search?keywords=\"我们俩\"' )\r\n// 发送请求\r\nmyAjax.send()\r\n// 接收\r\nmyAjax.onreadystatechange = function() {\r\n  if (myAjax.readyState == 4 && myAjax.status == 200) {\r\n    console.log(JSON.parse(myAjax.responseText));  // JSON将字符串转换为对象\r\n  }\r\n}\r\n```\r\n[参考链接](https://juejin.cn/post/6992525007716876325#heading-54)\r\n\r\n\r\n---\r\n\r\n## 九、下面代码中 a 在什么情况下会打印 1？\r\n```js\r\nvar a = ?;\r\nif(a == 1 && a == 2 && a == 3){\r\n \tconso.log(1);\r\n}\r\n```\r\n>答案解析 因为==会进行隐式类型转换 所以我们重写toString方法就可以了\r\n```js\r\nvar a = {\r\n  i: 1,\r\n  toString() {\r\n    return a.i++;\r\n  }\r\n}\r\n\r\nif( a == 1 && a == 2 && a == 3 ) {\r\n  console.log(1);\r\n}\r\n```\r\n\r\n---\r\n\r\n## 十、介绍下 BFC 及其应用\r\n\r\nBFC 就是块级格式上下文，是页面盒模型布局中的一种 CSS 渲染模式，相当于一个独立的容器，里面的元素和外部的元素相互不影响。\\\r\n创建BFC 的方式有：\r\n\r\n下列方式会创建块格式化上下文：\r\n\r\n- html根元素（）\r\n\r\n- float浮动（元素的 float 不是 none）\r\n\r\n- 绝对定位元素（元素的 position 为 absolute 或 fixed）\r\n\r\n- 行内块元素（元素的 display 为 inline-block）\r\n\r\n- display 为表格布局、弹性元素（flex、inline-flex）、网格元素（grid、inline-grid）\r\n\r\n- overflow 计算值(Computed)不为 visible 的块元素\r\n- 等。。。\r\n\r\nBFC 主要的作用是：\r\n1. 清除浮动\r\n3. 防止同一 BFC 容器中的相邻元素间的外边距重叠问题\r\n\r\nBFC特性:\r\n- BFC元素的垂直方向上会发生边距重叠。\r\n\r\n- BFC元素和浮动元素不会发生重叠。\r\n\r\n- BFC在计算高度时会把浮动元素计算进去。\r\n\r\n- BFC在页面是个独立的容器，里外元素互不影响。\r\n\r\n--- \r\n\r\n## 十一、对sort()的理解\r\n>使用 sort() 对数组 [3, 15, 8, 29, 102, 22] 进行排序，输出结果\r\n\r\n答案:**[102, 15, 22, 29, 3, 8]**\r\n\r\n解析:\r\n>根据MDN上对Array.sort()的解释，***默认的排序方法会将数组元素转换为字符串，然后比较字符串中字符的UTF-16编码顺序来进行排序***。所以'102' 会排在 '15' 前面。\r\n\r\n如果要对数值进行升序排列：\r\n```js\r\n[3, 15, 8, 29, 102, 22].sort((a, b) => a - b) \r\n// [3, 8, 15, 22, 29, 102]\r\n```\r\n\r\n---\r\n\r\n## 十二、call、apply、bind的区别\r\n作用：\r\n> 改变函数执行时的上下文,其中call和apply是立即调用的\r\n1. cal、apply、bind必须通过函数来调用，第一个参数为对象，若第一个参数为null或者undefined，则指向window\r\n2. call和bind方法可以接收多个参数，apply方法只能接收2个参数，且第二个参数为数组或者伪数组\r\n3. call、apply、bind方法的调用：\r\n    1. call和apply方法没有返回值（即返回undefined）\r\n    2. bind方法返回一个原函数的拷贝，并具有指定的this值和初始参数\r\n4. call、apply、bind方法的调用：\r\n    1. call和apply是立即执行的 \r\n    2. bind返回值是一个函数，需要稍后再调用一下，才会执行。\r\n\r\n[参考](参考：https://segmentfault.com/a/1190000018017796)\r\n\r\n---\r\n\r\n## 十三、分析比较 opacity: 0、visibility: hidden、display: none 优劣和适用场景。\r\n\r\n总结一下：\\\r\n***结构***：\r\n- display:none: 会让元素完全从渲染树中消失，渲染的时候不占据任何空间, 不能点击，\r\n- visibility: hidden:不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，不能点击\r\n- opacity: 0: 不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，可以点击\r\n\r\n***继承***：\r\n- display: none和opacity: 0：是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示。\r\n- visibility: hidden：是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显式。\r\n\r\n***性能***：\r\n- displaynone : 修改元素会造成文档回流,读屏器不会读取display: none元素内容，性能消耗较大\r\n- visibility:hidden: 修改元素只会造成本元素的重绘,性能消耗较少读屏器读取visibility: hidden元素内容\r\n- opacity: 0 ： 修改元素会造成重绘，性能消耗较少\r\n\r\n***联系***：它们都能让元素不可见\r\n\r\n[参考](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/100)\r\n\r\n---\r\n\r\n## 十四、ES6 代码转成 ES5 代码的实现思路是什么\r\nBabel 是如何把 ES6 转成 ES5 呢\\\r\n其大致分为三步：\r\n1. 将代码字符串解析成抽象语法树，即所谓的 AST\r\n2. 对 AST 进行处理，在这个阶段可以对 ES6 代码进行相应转换，即转成 ES5 代码\r\n3. 根据处理后的 AST 再生成代码字符串\r\n\r\n>将ES6的代码转换为AST语法树，然后再将ES6 AST转为ES5 AST，再将AST转为代码\r\n\r\n--- \r\n\r\n## 十五、数组里面有10万个数据，取第一个元素和第10万个元素的时间相差多少\r\n\r\n1. 脚本里面的数组不是真正的数组，用的Hash算法，所以读取时间是一致的；\r\n2. 即便真正的数组，读取时间也是一致的，连续内存直接读就好了；\r\n3. 只有对单向链表才有差异；\r\n\r\n---\r\n\r\n## 十六、Vue 的父组件和子组件生命周期钩子执行顺序是什么\r\n\r\n1. 加载渲染过程\\\r\n**父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted**\r\n2. 子组件更新过程\\\r\n**父beforeUpdate->子beforeUpdate->子updated->父updated**\r\n3. 父组件更新过程\\\r\n**父beforeUpdate->父updated**\r\n4. 销毁过程\\\r\n**父beforeDestroy->子beforeDestroy->子destroyed->父destroyed**\r\n\r\n***总结***：从外到内，再从内到外\r\n\r\n---\r\n\r\n## 十七、import导入的模块\r\n> import导入的模块是只读的：您不能修改导入的模块。只有导出它们的模块才能更改其值\r\n\r\n[例题](https://github.com/lydiahallie/javascript-questions#57-whats-the-output)\r\n\r\n---\r\n\r\n## 十八、var、let 和 const \r\n\r\n- **var**的话会直接在栈内存里预分配内存空间，然后等到实际语句执行的时候，再存储对应的变量，如果传的是引用类型，那么会在堆内存里开辟一个内存空间存储实际内容，栈内存会存储一个指向堆内存的指针\r\n\r\n- **let**的话，是不会在栈内存里预分配内存空间，而且在栈内存分配变量时，做一个检查，如果已经有相同变量名存在就会报错\r\n\r\n- **const**的话，也不会预分配内存空间，在栈内存分配变量时也会做同样的检查。不过const存储的变量是不可修改的，对于基本类型来说你无法修改定义的值，对于引用类型来说你无法修改栈内存里分配的指针，但是你可以修改指针指向的对象里面的属性\r\n\r\n---\r\n\r\n## 十九、 Object.steal()和Object.freezze()\r\n1. O**bject.steal()**\r\n    1. 防止对象添加新属性或删除现有属性\r\n\r\n    2. 但仍可以修改现有属性的值\r\n\r\n[例题](https://github.com/lydiahallie/javascript-questions#136-which-of-the-following-will-modify-the-person-object)\r\n\r\n\r\n2. **Object.freeze()**\r\n    1. 冻结一个对象，不可添加、修改、删除任何属性\r\n\r\n    2. 但只是浅冻结对象，只是对对象的直接属性进行了冻结，若属性中又另一个对象，则可对这个对象进行修改\r\n\r\n[例题](https://github.com/lydiahallie/javascript-questions#137-which-of-the-following-will-modify-the-person-object)\r\n\r\n\r\n\r\n---\r\n\r\n<div style=\"font-weight:700; text-align:center; padding-top:20px;\">最后更新时间：2022.02.12</div>",contentRendered:'<h2 id="一、事件循环" tabindex="-1"><a class="header-anchor" href="#一、事件循环" aria-hidden="true">#</a> 一、事件循环</h2>\n<blockquote>\n<p>Javascript是一门单线程语言，只有前一个任务执行完毕才会运行下一个任务，为了规避掉资源分配的浪费，所以将Javascript的任务分为同步任务和异步任务</p>\n<blockquote>\n<p>异步任务又分为宏任务和微任务</p>\n</blockquote>\n</blockquote>\n<h3 id="eventloop" tabindex="-1"><a class="header-anchor" href="#eventloop" aria-hidden="true">#</a> EventLoop</h3>\n<blockquote>\n<p>先执行同步操作，异步操作排在事件队列里</p>\n</blockquote>\n<ol>\n<li>先判断是同步还是异步，同步任务进入主线程，异步任务进入Event Table(任务队列)</li>\n<li>异步任务在Event Table中注册事件，当满足促发条件的时候，会被推入到Event Queue(事件队列)</li>\n<li>主线程空闲时，才会在Event Queue中看是否又需要执行的异步任务，如果有，就推入主线程中执行</li>\n</ol>\n<blockquote>\n<p>异步任务执行顺序为先执行微任务，在执行宏任务</p>\n</blockquote>\n<hr>\n<h2 id="二、this是什么" tabindex="-1"><a class="header-anchor" href="#二、this是什么" aria-hidden="true">#</a> 二、this是什么</h2>\n<p>当一个函数被调用时,会创建一个执行上下文,这个执行上下文包含函数在哪里调用(调用栈),函数的调用方法,传入的参数等,<strong>this</strong>就是用来记录当前这个执行上下文信息的一个属性</p>\n<h3 id="关于this指针的指向问题" tabindex="-1"><a class="header-anchor" href="#关于this指针的指向问题" aria-hidden="true">#</a> 关于this指针的指向问题</h3>\n<ol>\n<li><strong>this</strong>始终会指向一个对象,是根据函数的执行环境来决定的,函数作为一个对象的方法被调用的话,<strong>this</strong>就指向这个对象</li>\n<li>如果是new的话,<strong>this</strong>就指向new出来的这个实例化对象</li>\n<li>因为匿名函数和自执行函数的执行环境具有全局性,所以它的this一般指向window</li>\n<li>箭头函数没有自己的this,它里面的<strong>this</strong>的指向跟外部作用域中<strong>this</strong>指向一致</li>\n</ol>\n<hr>\n<h2 id="三、闭包相关问题" tabindex="-1"><a class="header-anchor" href="#三、闭包相关问题" aria-hidden="true">#</a> 三、闭包相关问题</h2>\n<blockquote>\n<p>当内部函数被保存到外部时,将会产生闭包</p>\n</blockquote>\n<p><em><strong>定义</strong></em>:在JavaScript中,根据词法作用域的规则,内部函数总是可以访问其外部函数中申明的变量,当通过调用一个外部函数返回一个内部函数后,即使该外部函数已经执行结束,但是内部函数引用外部函数的变量,依然保存在内存中,我们把这些变量的集合称为闭包</p>\n<p><em><strong>缺点</strong></em>:闭包会导致原有的作用域链不释放,造成内存泄漏<br>\n<em><strong>优点</strong></em>:</p>\n<ol>\n<li>实现公有化变量 (企业的模块开发)</li>\n<li>做缓存</li>\n<li>实现属性的私有化</li>\n<li>模块化开发，防止污染全局变量</li>\n</ol>\n<blockquote>\n<p>变量长期驻扎在内存中,避免全局变量的污染,私有成员的存在</p>\n</blockquote>\n<hr>\n<h2 id="四、vue的生命周期" tabindex="-1"><a class="header-anchor" href="#四、vue的生命周期" aria-hidden="true">#</a> 四、vue的生命周期</h2>\n<blockquote>\n<p>Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、销毁等一系列过程，我们称这是Vue的生命周期。通俗说就是Vue实例从创建到销毁的过程，就是生命周期。</p>\n</blockquote>\n<p>每一个组件或者实例都会经历一个完整的生命周期，总共分为三个阶段：初始化、运行中、销毁。</p>\n<ol>\n<li>实例、组件通过new Vue() 创建出来之后会初始化事件和生命周期，然后就会执行<strong>beforeCreate</strong>钩子函数，这个时候，数据还没有挂载呢，只是一个空壳，无法访问到数据和真实的dom，一般不做操作</li>\n<li>挂载数据，绑定事件等等，然后执行<strong>created</strong>函数，这个时候已经可以使用到数据，也可以更改数据,在这里更改数据不会触发updated函数，在这里可以在渲染前倒数第二次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取</li>\n<li>接下来开始找实例或者组件对应的模板，编译模板为虚拟dom放入到render函数中准备渲染，然后执行<strong>beforeMount</strong>钩子函数，在这个函数中虚拟dom已经创建完成，马上就要渲染,在这里也可以更改数据，不会触发<strong>updated</strong>，在这里可以在渲染前最后一次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取</li>\n<li>接下来开始render，渲染出真实dom，然后执行<strong>mounted</strong>钩子函数，此时，组件已经出现在页面中，数据、真实dom都已经处理好了,事件都已经挂载好了，可以在这里操作真实dom等事情...</li>\n<li>当组件或实例的数据更改之后，会立即执行<strong>beforeUpdate</strong>，然后vue的虚拟dom机制会重新构建虚拟dom与上一次的虚拟dom树利用diff算法进行对比之后重新渲染，一般不做什么事儿</li>\n<li>当更新完成后，执行<strong>updated</strong>，数据已经更改完成，dom也重新render完成，可以操作更新后的虚拟dom</li>\n<li>当经过某种途径调用$destroy方法后，立即执行<strong>beforeDestroy</strong>，一般在这里做一些善后工作，例如清除计时器、清除非指令绑定的事件等等</li>\n<li>组件的数据绑定、监听...去掉后只剩下dom空壳，这个时候，执行<strong>destroyed</strong>，在这里做善后工作也可以</li>\n</ol>\n<hr>\n<h2 id="五、web前端开发技术的优化策略" tabindex="-1"><a class="header-anchor" href="#五、web前端开发技术的优化策略" aria-hidden="true">#</a> 五、web前端开发技术的优化策略</h2>\n<p><a href="https://blog.csdn.net/smell201611010513/article/details/103784242" target="_blank" rel="noopener noreferrer">web前端开发技术的优化策略<ExternalLinkIcon/></a></p>\n<ol>\n<li>减少HTTP请求数</li>\n<li>优化文件的规模</li>\n<li>减少DNS查找</li>\n<li>杜绝无用响应</li>\n<li>有效避免重定向</li>\n<li>优化网页内容</li>\n</ol>\n<h3 id="减少页面加载时间的方式" tabindex="-1"><a class="header-anchor" href="#减少页面加载时间的方式" aria-hidden="true">#</a> 减少页面加载时间的方式</h3>\n<ol>\n<li>优化图片</li>\n<li>图像格式的选择（GIF：提供的颜色较少，可用在一些对颜色要求不高的地方）</li>\n<li>优化CSS（压缩合并css，如 margin-top, margin-left...)</li>\n<li>网址后加斜杠（如www.campr.com/目录，会判断这个目录是什么文件类型，或者是目录。）</li>\n<li>cdn托管</li>\n<li>标明高度和宽度（如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小，如果图片很多，浏览器需要不断地调整页面。这不但影响速度，也影响浏览体验。<br>\n当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加 载后面的内容。从而加载时间快了，浏览体验也更好了）</li>\n<li>减少http请求（合并文件，合并图片）</li>\n</ol>\n<hr>\n<h2 id="六、回流和重绘" tabindex="-1"><a class="header-anchor" href="#六、回流和重绘" aria-hidden="true">#</a> 六、回流和重绘</h2>\n<p><strong>回流</strong>：当render tree中的一部分或者全部因为元素的规模尺寸，布局，隐藏等改变而需要重新构建，这就叫回流</p>\n<blockquote>\n<p>每个页面至少需要一次回流，就是在页面第一次加载的时候，这时候一定会发生回流，因为要构建render tree</p>\n</blockquote>\n<p><strong>重绘</strong>:在回流的时候，浏览器会使渲染树中收到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏 览器会重新绘制受影响的部分到屏幕中，这就是重绘</p>\n<blockquote>\n<p>当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，不会影响布局，就叫重绘</p>\n</blockquote>\n<h3 id="何时发生回流重绘" tabindex="-1"><a class="header-anchor" href="#何时发生回流重绘" aria-hidden="true">#</a> 何时发生回流重绘</h3>\n<ul>\n<li>回流这一阶段主要是计算节点的位置和几何信息，那么当页面布局和几何信息发生变化的时候，就需要回流。比如以下情况：</li>\n<li>添加或删除可见的DOM元素</li>\n<li>元素的位置发生变化</li>\n<li>元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）</li>\n<li>内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。</li>\n<li>页面一开始渲染的时候（这肯定避免不了）</li>\n<li>浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）</li>\n</ul>\n<p><strong>注意：回流一定会触发重绘，而重绘不一定会回流</strong></p>\n<h3 id="减少重排重绘的方法" tabindex="-1"><a class="header-anchor" href="#减少重排重绘的方法" aria-hidden="true">#</a> 减少重排重绘的方法</h3>\n<p><a href="https://github.com/chenjigeng/blog/issues/4" target="_blank" rel="noopener noreferrer">减少重排重绘的方法<ExternalLinkIcon/></a></p>\n<h3 id="浏览器的优化机制" tabindex="-1"><a class="header-anchor" href="#浏览器的优化机制" aria-hidden="true">#</a> 浏览器的优化机制</h3>\n<p>目前大多数浏览器，都会通过队列化来批量的修改重排的过程，浏览器会将修改操作放到队列中，直到一段时间后，队列的存储达到阈值，才会一次性全部重排，清空队列；<strong>但是！当你获取布局信息的操作的时候，会强制队列刷新</strong></p>\n<ul>\n<li>offsetTop、offsetLeft、offsetWidth、offsetHeight</li>\n<li>scrollTop、scrollLeft、scrollWidth、scrollHeight</li>\n<li>clientTop、clientLeft、clientWidth、clientHeight</li>\n<li>getComputedStyle()</li>\n<li>getBoundingClientRect</li>\n</ul>\n<blockquote>\n<p>以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。因此，我们在修改样式的时候，<strong>最好避免使用上面列出的属性，他们都会刷新渲染队列</strong>如果要使用它们，最好将值缓存起来。</p>\n</blockquote>\n<hr>\n<h2 id="七、常见的http状态码" tabindex="-1"><a class="header-anchor" href="#七、常见的http状态码" aria-hidden="true">#</a> 七、常见的HTTP状态码</h2>\n<h3 id="状态码分类" tabindex="-1"><a class="header-anchor" href="#状态码分类" aria-hidden="true">#</a> 状态码分类：</h3>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>分类描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1**</td>\n<td>信息，服务器收到请求，需要请求者继续执行操作</td>\n</tr>\n<tr>\n<td>2**</td>\n<td>成功，操作被成功接收并处理</td>\n</tr>\n<tr>\n<td>3**</td>\n<td>重定向，需要进一步的操作以完成请求</td>\n</tr>\n<tr>\n<td>4**</td>\n<td>客户端错误，请求包含语法错误或无法完成请求</td>\n</tr>\n<tr>\n<td>5**</td>\n<td>服务器错误，服务器在处理请求的过程中发生了错误</td>\n</tr>\n</tbody>\n</table>\n<h3 id="常见的http状态码列表" tabindex="-1"><a class="header-anchor" href="#常见的http状态码列表" aria-hidden="true">#</a> 常见的HTTP状态码列表:</h3>\n<table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><em><strong>100</strong></em></td>\n<td>这个状态码告诉客户应该继续发送请求，这个临时响应是用来通知客户端的，部分的请求服务器已经接受，但是客户端应该继续发送请求的剩余部分，如果请求已经完成，就忽略这个响应，而且服务器会在请求完成后向客户发送一个最终的结果。</td>\n</tr>\n<tr>\n<td><em><strong>200</strong></em></td>\n<td>这个是最常见的http状态码，表示服务器已经成功接受请求，并将返回客户端所请求的最终结果。</td>\n</tr>\n<tr>\n<td><em><strong>202</strong></em></td>\n<td>表示服务器已经接受了请求，但是还没有处理，而且这个请求最终会不会处理还不确定。</td>\n</tr>\n<tr>\n<td><em><strong>204</strong></em></td>\n<td>服务器成功处理了请求，但没有返回任何实体内容，可能会返回新的头部元信息。</td>\n</tr>\n<tr>\n<td><em><strong>301</strong></em></td>\n<td>客户端请求的页面已经永久移动到新的位置，当链接发生变化时，返回301代码告诉客户端连接的变化，客户端保存新的链接，并向新的链接发出请求，已返回请求结果。</td>\n</tr>\n<tr>\n<td><em><strong>404</strong></em></td>\n<td>请求失败，客户端请求的资源没有找到或者是不存在。</td>\n</tr>\n<tr>\n<td><em><strong>500</strong></em></td>\n<td>服务器遇到未知的错误，导致无法完成客户端当前的请求。</td>\n</tr>\n<tr>\n<td><em><strong>503</strong></em></td>\n<td>服务器由于临时的服务器过载或者是维护，无法解决当前的请求。</td>\n</tr>\n</tbody>\n</table>\n<p><a href="https://www.runoob.com/http/http-status-codes.html" target="_blank" rel="noopener noreferrer">参考<ExternalLinkIcon/></a></p>\n<hr>\n<h2 id="八、ajax如何使用" tabindex="-1"><a class="header-anchor" href="#八、ajax如何使用" aria-hidden="true">#</a> 八、Ajax如何使用</h2>\n<p>一个完整的AJAX请求包括五个步骤：\n具体来说，AJAX 包括以下几个步骤。</p>\n<ol>\n<li>\n<p>创建 XMLHttpRequest 对象，也就是创建一个异步调用对象</p>\n</li>\n<li>\n<p>创建一个新的 HTTP 请求，并指定该 HTTP 请求的方法、URL 及验证信息</p>\n</li>\n<li>\n<p>设置响应 HTTP 请求状态变化的函数</p>\n</li>\n<li>\n<p>发送 HTTP 请求</p>\n</li>\n<li>\n<p>获取异步调用返回的数据</p>\n</li>\n<li>\n<p>使用 JavaScript 和 DOM 实现局部刷新</p>\n</li>\n</ol>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token comment">// 创建可以请求的实例对象</span>\n<span class="token keyword">var</span> myAjax <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token comment">// 设置请求的url参数，这是准备工作</span>\nmyAjax<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">\'GET\'</span><span class="token punctuation">,</span> <span class="token string">\'https://autumnfish.cn/search?keywords="我们俩"\'</span> <span class="token punctuation">)</span>\n<span class="token comment">// 发送请求</span>\nmyAjax<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token comment">// 接收</span>\nmyAjax<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>myAjax<span class="token punctuation">.</span>readyState <span class="token operator">==</span> <span class="token number">4</span> <span class="token operator">&amp;&amp;</span> myAjax<span class="token punctuation">.</span>status <span class="token operator">==</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>myAjax<span class="token punctuation">.</span>responseText<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// JSON将字符串转换为对象</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p><a href="https://juejin.cn/post/6992525007716876325#heading-54" target="_blank" rel="noopener noreferrer">参考链接<ExternalLinkIcon/></a></p>\n<hr>\n<h2 id="九、下面代码中-a-在什么情况下会打印-1" tabindex="-1"><a class="header-anchor" href="#九、下面代码中-a-在什么情况下会打印-1" aria-hidden="true">#</a> 九、下面代码中 a 在什么情况下会打印 1？</h2>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token operator">?</span><span class="token punctuation">;</span>\n<span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n \tconso<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><blockquote>\n<p>答案解析 因为==会进行隐式类型转换 所以我们重写toString方法就可以了</p>\n</blockquote>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">i</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>\n  <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> a<span class="token punctuation">.</span>i<span class="token operator">++</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">if</span><span class="token punctuation">(</span> a <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">==</span> <span class="token number">3</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><hr>\n<h2 id="十、介绍下-bfc-及其应用" tabindex="-1"><a class="header-anchor" href="#十、介绍下-bfc-及其应用" aria-hidden="true">#</a> 十、介绍下 BFC 及其应用</h2>\n<p>BFC 就是块级格式上下文，是页面盒模型布局中的一种 CSS 渲染模式，相当于一个独立的容器，里面的元素和外部的元素相互不影响。<br>\n创建BFC 的方式有：</p>\n<p>下列方式会创建块格式化上下文：</p>\n<ul>\n<li>\n<p>html根元素（）</p>\n</li>\n<li>\n<p>float浮动（元素的 float 不是 none）</p>\n</li>\n<li>\n<p>绝对定位元素（元素的 position 为 absolute 或 fixed）</p>\n</li>\n<li>\n<p>行内块元素（元素的 display 为 inline-block）</p>\n</li>\n<li>\n<p>display 为表格布局、弹性元素（flex、inline-flex）、网格元素（grid、inline-grid）</p>\n</li>\n<li>\n<p>overflow 计算值(Computed)不为 visible 的块元素</p>\n</li>\n<li>\n<p>等。。。</p>\n</li>\n</ul>\n<p>BFC 主要的作用是：</p>\n<ol>\n<li>清除浮动</li>\n<li>防止同一 BFC 容器中的相邻元素间的外边距重叠问题</li>\n</ol>\n<p>BFC特性:</p>\n<ul>\n<li>\n<p>BFC元素的垂直方向上会发生边距重叠。</p>\n</li>\n<li>\n<p>BFC元素和浮动元素不会发生重叠。</p>\n</li>\n<li>\n<p>BFC在计算高度时会把浮动元素计算进去。</p>\n</li>\n<li>\n<p>BFC在页面是个独立的容器，里外元素互不影响。</p>\n</li>\n</ul>\n<hr>\n<h2 id="十一、对sort-的理解" tabindex="-1"><a class="header-anchor" href="#十一、对sort-的理解" aria-hidden="true">#</a> 十一、对sort()的理解</h2>\n<blockquote>\n<p>使用 sort() 对数组 [3, 15, 8, 29, 102, 22] 进行排序，输出结果</p>\n</blockquote>\n<p>答案:<strong>[102, 15, 22, 29, 3, 8]</strong></p>\n<p>解析:</p>\n<blockquote>\n<p>根据MDN上对Array.sort()的解释，<em><strong>默认的排序方法会将数组元素转换为字符串，然后比较字符串中字符的UTF-16编码顺序来进行排序</strong></em>。所以\'102\' 会排在 \'15\' 前面。</p>\n</blockquote>\n<p>如果要对数值进行升序排列：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">,</span> <span class="token number">102</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=></span> a <span class="token operator">-</span> b<span class="token punctuation">)</span> \n<span class="token comment">// [3, 8, 15, 22, 29, 102]</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><hr>\n<h2 id="十二、call、apply、bind的区别" tabindex="-1"><a class="header-anchor" href="#十二、call、apply、bind的区别" aria-hidden="true">#</a> 十二、call、apply、bind的区别</h2>\n<p>作用：</p>\n<blockquote>\n<p>改变函数执行时的上下文,其中call和apply是立即调用的</p>\n</blockquote>\n<ol>\n<li>cal、apply、bind必须通过函数来调用，第一个参数为对象，若第一个参数为null或者undefined，则指向window</li>\n<li>call和bind方法可以接收多个参数，apply方法只能接收2个参数，且第二个参数为数组或者伪数组</li>\n<li>call、apply、bind方法的调用：\n<ol>\n<li>call和apply方法没有返回值（即返回undefined）</li>\n<li>bind方法返回一个原函数的拷贝，并具有指定的this值和初始参数</li>\n</ol>\n</li>\n<li>call、apply、bind方法的调用：\n<ol>\n<li>call和apply是立即执行的</li>\n<li>bind返回值是一个函数，需要稍后再调用一下，才会执行。</li>\n</ol>\n</li>\n</ol>\n<p><a href="%E5%8F%82%E8%80%83%EF%BC%9Ahttps://segmentfault.com/a/1190000018017796">参考</a></p>\n<hr>\n<h2 id="十三、分析比较-opacity-0、visibility-hidden、display-none-优劣和适用场景。" tabindex="-1"><a class="header-anchor" href="#十三、分析比较-opacity-0、visibility-hidden、display-none-优劣和适用场景。" aria-hidden="true">#</a> 十三、分析比较 opacity: 0、visibility: hidden、display: none 优劣和适用场景。</h2>\n<p>总结一下：<br>\n<em><strong>结构</strong></em>：</p>\n<ul>\n<li>display:none: 会让元素完全从渲染树中消失，渲染的时候不占据任何空间, 不能点击，</li>\n<li>visibility: hidden:不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，不能点击</li>\n<li>opacity: 0: 不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，可以点击</li>\n</ul>\n<p><em><strong>继承</strong></em>：</p>\n<ul>\n<li>display: none和opacity: 0：是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示。</li>\n<li>visibility: hidden：是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显式。</li>\n</ul>\n<p><em><strong>性能</strong></em>：</p>\n<ul>\n<li>displaynone : 修改元素会造成文档回流,读屏器不会读取display: none元素内容，性能消耗较大</li>\n<li>visibility:hidden: 修改元素只会造成本元素的重绘,性能消耗较少读屏器读取visibility: hidden元素内容</li>\n<li>opacity: 0 ： 修改元素会造成重绘，性能消耗较少</li>\n</ul>\n<p><em><strong>联系</strong></em>：它们都能让元素不可见</p>\n<p><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/100" target="_blank" rel="noopener noreferrer">参考<ExternalLinkIcon/></a></p>\n<hr>\n<h2 id="十四、es6-代码转成-es5-代码的实现思路是什么" tabindex="-1"><a class="header-anchor" href="#十四、es6-代码转成-es5-代码的实现思路是什么" aria-hidden="true">#</a> 十四、ES6 代码转成 ES5 代码的实现思路是什么</h2>\n<p>Babel 是如何把 ES6 转成 ES5 呢<br>\n其大致分为三步：</p>\n<ol>\n<li>将代码字符串解析成抽象语法树，即所谓的 AST</li>\n<li>对 AST 进行处理，在这个阶段可以对 ES6 代码进行相应转换，即转成 ES5 代码</li>\n<li>根据处理后的 AST 再生成代码字符串</li>\n</ol>\n<blockquote>\n<p>将ES6的代码转换为AST语法树，然后再将ES6 AST转为ES5 AST，再将AST转为代码</p>\n</blockquote>\n<hr>\n<h2 id="十五、数组里面有10万个数据-取第一个元素和第10万个元素的时间相差多少" tabindex="-1"><a class="header-anchor" href="#十五、数组里面有10万个数据-取第一个元素和第10万个元素的时间相差多少" aria-hidden="true">#</a> 十五、数组里面有10万个数据，取第一个元素和第10万个元素的时间相差多少</h2>\n<ol>\n<li>脚本里面的数组不是真正的数组，用的Hash算法，所以读取时间是一致的；</li>\n<li>即便真正的数组，读取时间也是一致的，连续内存直接读就好了；</li>\n<li>只有对单向链表才有差异；</li>\n</ol>\n<hr>\n<h2 id="十六、vue-的父组件和子组件生命周期钩子执行顺序是什么" tabindex="-1"><a class="header-anchor" href="#十六、vue-的父组件和子组件生命周期钩子执行顺序是什么" aria-hidden="true">#</a> 十六、Vue 的父组件和子组件生命周期钩子执行顺序是什么</h2>\n<ol>\n<li>加载渲染过程<br>\n<strong>父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted</strong></li>\n<li>子组件更新过程<br>\n<strong>父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</strong></li>\n<li>父组件更新过程<br>\n<strong>父beforeUpdate-&gt;父updated</strong></li>\n<li>销毁过程<br>\n<strong>父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</strong></li>\n</ol>\n<p><em><strong>总结</strong></em>：从外到内，再从内到外</p>\n<hr>\n<h2 id="十七、import导入的模块" tabindex="-1"><a class="header-anchor" href="#十七、import导入的模块" aria-hidden="true">#</a> 十七、import导入的模块</h2>\n<blockquote>\n<p>import导入的模块是只读的：您不能修改导入的模块。只有导出它们的模块才能更改其值</p>\n</blockquote>\n<p><a href="https://github.com/lydiahallie/javascript-questions#57-whats-the-output" target="_blank" rel="noopener noreferrer">例题<ExternalLinkIcon/></a></p>\n<hr>\n<h2 id="十八、var、let-和-const" tabindex="-1"><a class="header-anchor" href="#十八、var、let-和-const" aria-hidden="true">#</a> 十八、var、let 和 const</h2>\n<ul>\n<li>\n<p><strong>var</strong>的话会直接在栈内存里预分配内存空间，然后等到实际语句执行的时候，再存储对应的变量，如果传的是引用类型，那么会在堆内存里开辟一个内存空间存储实际内容，栈内存会存储一个指向堆内存的指针</p>\n</li>\n<li>\n<p><strong>let</strong>的话，是不会在栈内存里预分配内存空间，而且在栈内存分配变量时，做一个检查，如果已经有相同变量名存在就会报错</p>\n</li>\n<li>\n<p><strong>const</strong>的话，也不会预分配内存空间，在栈内存分配变量时也会做同样的检查。不过const存储的变量是不可修改的，对于基本类型来说你无法修改定义的值，对于引用类型来说你无法修改栈内存里分配的指针，但是你可以修改指针指向的对象里面的属性</p>\n</li>\n</ul>\n<hr>\n<h2 id="十九、-object-steal-和object-freezze" tabindex="-1"><a class="header-anchor" href="#十九、-object-steal-和object-freezze" aria-hidden="true">#</a> 十九、 Object.steal()和Object.freezze()</h2>\n<ol>\n<li>O<strong>bject.steal()</strong>\n<ol>\n<li>\n<p>防止对象添加新属性或删除现有属性</p>\n</li>\n<li>\n<p>但仍可以修改现有属性的值</p>\n</li>\n</ol>\n</li>\n</ol>\n<p><a href="https://github.com/lydiahallie/javascript-questions#136-which-of-the-following-will-modify-the-person-object" target="_blank" rel="noopener noreferrer">例题<ExternalLinkIcon/></a></p>\n<ol start="2">\n<li><strong>Object.freeze()</strong>\n<ol>\n<li>\n<p>冻结一个对象，不可添加、修改、删除任何属性</p>\n</li>\n<li>\n<p>但只是浅冻结对象，只是对对象的直接属性进行了冻结，若属性中又另一个对象，则可对这个对象进行修改</p>\n</li>\n</ol>\n</li>\n</ol>\n<p><a href="https://github.com/lydiahallie/javascript-questions#137-which-of-the-following-will-modify-the-person-object" target="_blank" rel="noopener noreferrer">例题<ExternalLinkIcon/></a></p>\n<hr>\n<div style="font-weight:700; text-align:center; padding-top:20px;">最后更新时间：2022.02.12</div>',date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:"/Navigation/interview.html",pathLocale:"/",permalink:null,routeMeta:{},slug:"interview",filePath:"C:/Users/mi/Desktop/我的博客/docs/Navigation/interview.md",filePathRelative:"Navigation/interview.md",componentFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/Navigation/interview.html.vue",componentFilePathRelative:"pages/Navigation/interview.html.vue",componentFileChunkName:"v-39cc4c5a",dataFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/Navigation/interview.html.js",dataFilePathRelative:"pages/Navigation/interview.html.js",dataFileChunkName:"v-39cc4c5a",htmlFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/dist/Navigation/interview.html",htmlFilePathRelative:"Navigation/interview.html"},{data:{key:"v-0359f486",path:"/Navigation/interview2.html",title:"interview-2",lang:"zh-CN",frontmatter:{date:"2022/2/13 11:08",coverUrl:"http://cdn-ali-img-shstaticbz.shanhutech.cn/bizhi/staticwp/202107/0ee3a54e877205a6bd29ca2d23f44b43--2771443509.jpg",sticky:!0,keyword:"面试表达",description:"interview expression",title:"interview-2",tag:["笔记"],categories:["面试表达"]},excerpt:"",headers:[{level:2,title:"一、什么是 Data URL",slug:"一、什么是-data-url",children:[]},{level:2,title:"二、伪类与伪元素有什么区别",slug:"二、伪类与伪元素有什么区别",children:[]},{level:2,title:"三、如何实现表格单双行条纹样式",slug:"三、如何实现表格单双行条纹样式",children:[]},{level:2,title:"四、prefetch 与 preload 的区别是什么",slug:"四、prefetch-与-preload-的区别是什么",children:[]},{level:2,title:"五、如何实现页面文本不可复制",slug:"五、如何实现页面文本不可复制",children:[]},{level:2,title:"六、js 代码压缩",slug:"六、js-代码压缩",children:[]},{level:2,title:"七、package.json 指南",slug:"七、package-json-指南",children:[]},{level:2,title:"八、CSS 选择器优先级特异性权重",slug:"八、css-选择器优先级特异性权重",children:[]}],git:{updatedTime:null,contributors:[]}},key:"v-0359f486",path:"/Navigation/interview2.html",title:"interview-2",lang:"zh-CN",frontmatter:{date:"2022/2/13 11:08",coverUrl:"http://cdn-ali-img-shstaticbz.shanhutech.cn/bizhi/staticwp/202107/0ee3a54e877205a6bd29ca2d23f44b43--2771443509.jpg",sticky:!0,keyword:"面试表达",description:"interview expression",title:"interview-2",tag:["笔记"],categories:["面试表达"]},excerpt:"",headers:[{level:2,title:"一、什么是 Data URL",slug:"一、什么是-data-url",children:[]},{level:2,title:"二、伪类与伪元素有什么区别",slug:"二、伪类与伪元素有什么区别",children:[]},{level:2,title:"三、如何实现表格单双行条纹样式",slug:"三、如何实现表格单双行条纹样式",children:[]},{level:2,title:"四、prefetch 与 preload 的区别是什么",slug:"四、prefetch-与-preload-的区别是什么",children:[]},{level:2,title:"五、如何实现页面文本不可复制",slug:"五、如何实现页面文本不可复制",children:[]},{level:2,title:"六、js 代码压缩",slug:"六、js-代码压缩",children:[]},{level:2,title:"七、package.json 指南",slug:"七、package-json-指南",children:[]},{level:2,title:"八、CSS 选择器优先级特异性权重",slug:"八、css-选择器优先级特异性权重",children:[]}],content:'\r\n## 一、什么是 Data URL\r\n\r\n[参考链接](https://q.shanyue.tech/fe/html/478.html)\r\n\r\n---\r\n\r\n## 二、伪类与伪元素有什么区别\r\n1. 伪类使用单冒号，而伪元素使用双冒号。如 **:hover** 是伪类，**::before** 是伪元素\r\n2. 伪元素会在文档流生成一个新的元素，并且可以使用 content 属性设置内容\r\n\r\n[参考链接](https://www.cnblogs.com/ammyben/p/8012747.html)\r\n\r\n---\r\n\r\n## 三、如何实现表格单双行条纹样式\r\n\r\n[参考链接](https://q.shanyue.tech/fe/css/309.html)\r\n\r\n---\r\n\r\n## 四、prefetch 与 preload 的区别是什么\r\n\r\n[参考链接](https://q.shanyue.tech/fe/dom/286.html)\r\n\r\n---\r\n\r\n## 五、如何实现页面文本不可复制\r\n\r\n[参考链接](https://q.shanyue.tech/fe/dom/454.html)\r\n\r\n---\r\n\r\n## 六、js 代码压缩\r\n\r\n[参考链接](https://q.shanyue.tech/engineering/138.html)\r\n\r\n---\r\n\r\n## 七、package.json 指南\r\n\r\n[参考链接](http://nodejs.cn/learn/the-package-json-guide)\r\n\r\n---\r\n\r\n## 八、CSS 选择器优先级特异性权重\r\n\r\n[参考链接](https://zxuqian.cn/css-selector-specificity/)\r\n\r\n---\r\n\r\n<div style="font-weight:700; text-align:center; padding-top:20px;">最后更新时间：2022.02.13</div>',contentRendered:'<h2 id="一、什么是-data-url" tabindex="-1"><a class="header-anchor" href="#一、什么是-data-url" aria-hidden="true">#</a> 一、什么是 Data URL</h2>\n<p><a href="https://q.shanyue.tech/fe/html/478.html" target="_blank" rel="noopener noreferrer">参考链接<ExternalLinkIcon/></a></p>\n<hr>\n<h2 id="二、伪类与伪元素有什么区别" tabindex="-1"><a class="header-anchor" href="#二、伪类与伪元素有什么区别" aria-hidden="true">#</a> 二、伪类与伪元素有什么区别</h2>\n<ol>\n<li>伪类使用单冒号，而伪元素使用双冒号。如 <strong>:hover</strong> 是伪类，<strong>::before</strong> 是伪元素</li>\n<li>伪元素会在文档流生成一个新的元素，并且可以使用 content 属性设置内容</li>\n</ol>\n<p><a href="https://www.cnblogs.com/ammyben/p/8012747.html" target="_blank" rel="noopener noreferrer">参考链接<ExternalLinkIcon/></a></p>\n<hr>\n<h2 id="三、如何实现表格单双行条纹样式" tabindex="-1"><a class="header-anchor" href="#三、如何实现表格单双行条纹样式" aria-hidden="true">#</a> 三、如何实现表格单双行条纹样式</h2>\n<p><a href="https://q.shanyue.tech/fe/css/309.html" target="_blank" rel="noopener noreferrer">参考链接<ExternalLinkIcon/></a></p>\n<hr>\n<h2 id="四、prefetch-与-preload-的区别是什么" tabindex="-1"><a class="header-anchor" href="#四、prefetch-与-preload-的区别是什么" aria-hidden="true">#</a> 四、prefetch 与 preload 的区别是什么</h2>\n<p><a href="https://q.shanyue.tech/fe/dom/286.html" target="_blank" rel="noopener noreferrer">参考链接<ExternalLinkIcon/></a></p>\n<hr>\n<h2 id="五、如何实现页面文本不可复制" tabindex="-1"><a class="header-anchor" href="#五、如何实现页面文本不可复制" aria-hidden="true">#</a> 五、如何实现页面文本不可复制</h2>\n<p><a href="https://q.shanyue.tech/fe/dom/454.html" target="_blank" rel="noopener noreferrer">参考链接<ExternalLinkIcon/></a></p>\n<hr>\n<h2 id="六、js-代码压缩" tabindex="-1"><a class="header-anchor" href="#六、js-代码压缩" aria-hidden="true">#</a> 六、js 代码压缩</h2>\n<p><a href="https://q.shanyue.tech/engineering/138.html" target="_blank" rel="noopener noreferrer">参考链接<ExternalLinkIcon/></a></p>\n<hr>\n<h2 id="七、package-json-指南" tabindex="-1"><a class="header-anchor" href="#七、package-json-指南" aria-hidden="true">#</a> 七、package.json 指南</h2>\n<p><a href="http://nodejs.cn/learn/the-package-json-guide" target="_blank" rel="noopener noreferrer">参考链接<ExternalLinkIcon/></a></p>\n<hr>\n<h2 id="八、css-选择器优先级特异性权重" tabindex="-1"><a class="header-anchor" href="#八、css-选择器优先级特异性权重" aria-hidden="true">#</a> 八、CSS 选择器优先级特异性权重</h2>\n<p><a href="https://zxuqian.cn/css-selector-specificity/" target="_blank" rel="noopener noreferrer">参考链接<ExternalLinkIcon/></a></p>\n<hr>\n<div style="font-weight:700; text-align:center; padding-top:20px;">最后更新时间：2022.02.13</div>',date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:"/Navigation/interview2.html",pathLocale:"/",permalink:null,routeMeta:{},slug:"interview2",filePath:"C:/Users/mi/Desktop/我的博客/docs/Navigation/interview2.md",filePathRelative:"Navigation/interview2.md",componentFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/Navigation/interview2.html.vue",componentFilePathRelative:"pages/Navigation/interview2.html.vue",componentFileChunkName:"v-0359f486",dataFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/Navigation/interview2.html.js",dataFilePathRelative:"pages/Navigation/interview2.html.js",dataFileChunkName:"v-0359f486",htmlFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/dist/Navigation/interview2.html",htmlFilePathRelative:"Navigation/interview2.html"},{data:{key:"v-d40e49ba",path:"/Navigation/navigation.html",title:"面试知识导航",lang:"zh-CN",frontmatter:{date:"2022/1/29 20:08",coverUrl:"http://cdn-ali-img-shstaticbz.shanhutech.cn/bizhi/staticwp/202201/bb2418e08b46b481c0788d639b762b83--2124794725.jpg",sticky:!0,keyword:"导航,回流重绘",description:"面试知识导航",title:"面试知识导航",tag:["笔记"],categories:["面试知识导航"]},excerpt:"",headers:[{level:2,title:"一、你真的了解回流和重绘吗",slug:"一、你真的了解回流和重绘吗",children:[]},{level:2,title:"二、重新认识构造函数、原型和原型链",slug:"二、重新认识构造函数、原型和原型链",children:[]},{level:2,title:"三、改造下面的代码，使之输出0 - 9，写出你能想到的所有解法。",slug:"三、改造下面的代码-使之输出0-9-写出你能想到的所有解法。",children:[]},{level:2,title:"四、怎么让一个 div 水平垂直居中",slug:"四、怎么让一个-div-水平垂直居中",children:[]},{level:2,title:"五、箭头函数与普通函数（function）的区别是什么？构造函数（function）可以使用 new 生成实例，那么箭头函数可以吗？为什么？",slug:"五、箭头函数与普通函数-function-的区别是什么-构造函数-function-可以使用-new-生成实例-那么箭头函数可以吗-为什么",children:[]},{level:2,title:"六、介绍下 BFC、IFC、GFC 和 FFC",slug:"六、介绍下-bfc、ifc、gfc-和-ffc",children:[]},{level:2,title:"七、常见的DOM操作",slug:"七、常见的dom操作",children:[]},{level:2,title:"八、前端项目中常见的报错类型汇总",slug:"八、前端项目中常见的报错类型汇总",children:[]},{level:2,title:"九、分清splice、slice和split",slug:"九、分清splice、slice和split",children:[]},{level:2,title:"十、flex 的三个参数 flex:1 0 auto",slug:"十、flex-的三个参数-flex-1-0-auto",children:[]},{level:2,title:"十一、防抖和节流",slug:"十一、防抖和节流",children:[]},{level:2,title:"十二、数组扁平化",slug:"十二、数组扁平化",children:[]}],git:{updatedTime:null,contributors:[]}},key:"v-d40e49ba",path:"/Navigation/navigation.html",title:"面试知识导航",lang:"zh-CN",frontmatter:{date:"2022/1/29 20:08",coverUrl:"http://cdn-ali-img-shstaticbz.shanhutech.cn/bizhi/staticwp/202201/bb2418e08b46b481c0788d639b762b83--2124794725.jpg",sticky:!0,keyword:"导航,回流重绘",description:"面试知识导航",title:"面试知识导航",tag:["笔记"],categories:["面试知识导航"]},excerpt:"",headers:[{level:2,title:"一、你真的了解回流和重绘吗",slug:"一、你真的了解回流和重绘吗",children:[]},{level:2,title:"二、重新认识构造函数、原型和原型链",slug:"二、重新认识构造函数、原型和原型链",children:[]},{level:2,title:"三、改造下面的代码，使之输出0 - 9，写出你能想到的所有解法。",slug:"三、改造下面的代码-使之输出0-9-写出你能想到的所有解法。",children:[]},{level:2,title:"四、怎么让一个 div 水平垂直居中",slug:"四、怎么让一个-div-水平垂直居中",children:[]},{level:2,title:"五、箭头函数与普通函数（function）的区别是什么？构造函数（function）可以使用 new 生成实例，那么箭头函数可以吗？为什么？",slug:"五、箭头函数与普通函数-function-的区别是什么-构造函数-function-可以使用-new-生成实例-那么箭头函数可以吗-为什么",children:[]},{level:2,title:"六、介绍下 BFC、IFC、GFC 和 FFC",slug:"六、介绍下-bfc、ifc、gfc-和-ffc",children:[]},{level:2,title:"七、常见的DOM操作",slug:"七、常见的dom操作",children:[]},{level:2,title:"八、前端项目中常见的报错类型汇总",slug:"八、前端项目中常见的报错类型汇总",children:[]},{level:2,title:"九、分清splice、slice和split",slug:"九、分清splice、slice和split",children:[]},{level:2,title:"十、flex 的三个参数 flex:1 0 auto",slug:"十、flex-的三个参数-flex-1-0-auto",children:[]},{level:2,title:"十一、防抖和节流",slug:"十一、防抖和节流",children:[]},{level:2,title:"十二、数组扁平化",slug:"十二、数组扁平化",children:[]}],content:'# 面试知识导航\r\n\r\n## 一、你真的了解回流和重绘吗\r\n- [参考链接](https://github.com/chenjigeng/blog/issues/4)\r\n\r\n---\r\n\r\n## 二、重新认识构造函数、原型和原型链\r\n- [参考链接](https://github.com/yygmind/blog/issues/32)\r\n\r\n---\r\n\r\n## 三、改造下面的代码，使之输出0 - 9，写出你能想到的所有解法。\r\n\r\n```js\r\nfor (var i = 0; i< 10; i++){\r\n\tsetTimeout(() => {\r\n\t\tconsole.log(i);\r\n    }, 1000)\r\n}\r\n```\r\n- [解决办法汇总](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/43)\r\n\r\n---\r\n\r\n## 四、怎么让一个 div 水平垂直居中\r\n[参考链接](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/92)\r\n\r\n---\r\n\r\n## 五、箭头函数与普通函数（function）的区别是什么？构造函数（function）可以使用 new 生成实例，那么箭头函数可以吗？为什么？\r\n\r\n[参考链接](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/101)\r\n\r\n---\r\n\r\n## 六、介绍下 BFC、IFC、GFC 和 FFC\r\n[参考链接](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/122)\r\n\r\n---\r\n\r\n##  七、常见的DOM操作\r\n[参考链接](https://juejin.cn/post/6940945178899251230#heading-67)\r\n\r\n---\r\n\r\n## 八、前端项目中常见的报错类型汇总\r\n[参考链接](https://juejin.cn/post/6844903893432795149)\r\n\r\n---\r\n\r\n## 九、分清splice、slice和split\r\n[参考链接](https://juejin.cn/post/7025089834620452894)\r\n[代码](https://www.iewganfil.top/A/PDF/splice.pdf)\r\n\r\n--- \r\n\r\n## 十、flex 的三个参数 flex:1 0 auto\r\n[参考链接](https://www.jianshu.com/p/d064282ec5cd)\r\n\r\n---\r\n\r\n## 十一、防抖和节流\r\n[参考链接](https://juejin.cn/post/7050105366931046436)\r\n\r\n---\r\n\r\n## 十二、数组扁平化\r\n[参考链接](https://juejin.cn/post/7051944992700858382)\r\n\r\n---\r\n\r\n<div style="font-weight:700; text-align:center; padding-top:20px;">最后更新时间：2022.02.13</div>\r\n',contentRendered:'<h1 id="面试知识导航" tabindex="-1"><a class="header-anchor" href="#面试知识导航" aria-hidden="true">#</a> 面试知识导航</h1>\n<h2 id="一、你真的了解回流和重绘吗" tabindex="-1"><a class="header-anchor" href="#一、你真的了解回流和重绘吗" aria-hidden="true">#</a> 一、你真的了解回流和重绘吗</h2>\n<ul>\n<li><a href="https://github.com/chenjigeng/blog/issues/4" target="_blank" rel="noopener noreferrer">参考链接<ExternalLinkIcon/></a></li>\n</ul>\n<hr>\n<h2 id="二、重新认识构造函数、原型和原型链" tabindex="-1"><a class="header-anchor" href="#二、重新认识构造函数、原型和原型链" aria-hidden="true">#</a> 二、重新认识构造函数、原型和原型链</h2>\n<ul>\n<li><a href="https://github.com/yygmind/blog/issues/32" target="_blank" rel="noopener noreferrer">参考链接<ExternalLinkIcon/></a></li>\n</ul>\n<hr>\n<h2 id="三、改造下面的代码-使之输出0-9-写出你能想到的所有解法。" tabindex="-1"><a class="header-anchor" href="#三、改造下面的代码-使之输出0-9-写出你能想到的所有解法。" aria-hidden="true">#</a> 三、改造下面的代码，使之输出0 - 9，写出你能想到的所有解法。</h2>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n\t<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n\t\tconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul>\n<li><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/43" target="_blank" rel="noopener noreferrer">解决办法汇总<ExternalLinkIcon/></a></li>\n</ul>\n<hr>\n<h2 id="四、怎么让一个-div-水平垂直居中" tabindex="-1"><a class="header-anchor" href="#四、怎么让一个-div-水平垂直居中" aria-hidden="true">#</a> 四、怎么让一个 div 水平垂直居中</h2>\n<p><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/92" target="_blank" rel="noopener noreferrer">参考链接<ExternalLinkIcon/></a></p>\n<hr>\n<h2 id="五、箭头函数与普通函数-function-的区别是什么-构造函数-function-可以使用-new-生成实例-那么箭头函数可以吗-为什么" tabindex="-1"><a class="header-anchor" href="#五、箭头函数与普通函数-function-的区别是什么-构造函数-function-可以使用-new-生成实例-那么箭头函数可以吗-为什么" aria-hidden="true">#</a> 五、箭头函数与普通函数（function）的区别是什么？构造函数（function）可以使用 new 生成实例，那么箭头函数可以吗？为什么？</h2>\n<p><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/101" target="_blank" rel="noopener noreferrer">参考链接<ExternalLinkIcon/></a></p>\n<hr>\n<h2 id="六、介绍下-bfc、ifc、gfc-和-ffc" tabindex="-1"><a class="header-anchor" href="#六、介绍下-bfc、ifc、gfc-和-ffc" aria-hidden="true">#</a> 六、介绍下 BFC、IFC、GFC 和 FFC</h2>\n<p><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/122" target="_blank" rel="noopener noreferrer">参考链接<ExternalLinkIcon/></a></p>\n<hr>\n<h2 id="七、常见的dom操作" tabindex="-1"><a class="header-anchor" href="#七、常见的dom操作" aria-hidden="true">#</a> 七、常见的DOM操作</h2>\n<p><a href="https://juejin.cn/post/6940945178899251230#heading-67" target="_blank" rel="noopener noreferrer">参考链接<ExternalLinkIcon/></a></p>\n<hr>\n<h2 id="八、前端项目中常见的报错类型汇总" tabindex="-1"><a class="header-anchor" href="#八、前端项目中常见的报错类型汇总" aria-hidden="true">#</a> 八、前端项目中常见的报错类型汇总</h2>\n<p><a href="https://juejin.cn/post/6844903893432795149" target="_blank" rel="noopener noreferrer">参考链接<ExternalLinkIcon/></a></p>\n<hr>\n<h2 id="九、分清splice、slice和split" tabindex="-1"><a class="header-anchor" href="#九、分清splice、slice和split" aria-hidden="true">#</a> 九、分清splice、slice和split</h2>\n<p><a href="https://juejin.cn/post/7025089834620452894" target="_blank" rel="noopener noreferrer">参考链接<ExternalLinkIcon/></a>\n<a href="https://www.iewganfil.top/A/PDF/splice.pdf" target="_blank" rel="noopener noreferrer">代码<ExternalLinkIcon/></a></p>\n<hr>\n<h2 id="十、flex-的三个参数-flex-1-0-auto" tabindex="-1"><a class="header-anchor" href="#十、flex-的三个参数-flex-1-0-auto" aria-hidden="true">#</a> 十、flex 的三个参数 flex:1 0 auto</h2>\n<p><a href="https://www.jianshu.com/p/d064282ec5cd" target="_blank" rel="noopener noreferrer">参考链接<ExternalLinkIcon/></a></p>\n<hr>\n<h2 id="十一、防抖和节流" tabindex="-1"><a class="header-anchor" href="#十一、防抖和节流" aria-hidden="true">#</a> 十一、防抖和节流</h2>\n<p><a href="https://juejin.cn/post/7050105366931046436" target="_blank" rel="noopener noreferrer">参考链接<ExternalLinkIcon/></a></p>\n<hr>\n<h2 id="十二、数组扁平化" tabindex="-1"><a class="header-anchor" href="#十二、数组扁平化" aria-hidden="true">#</a> 十二、数组扁平化</h2>\n<p><a href="https://juejin.cn/post/7051944992700858382" target="_blank" rel="noopener noreferrer">参考链接<ExternalLinkIcon/></a></p>\n<hr>\n<div style="font-weight:700; text-align:center; padding-top:20px;">最后更新时间：2022.02.13</div>\n',date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:"/Navigation/navigation.html",pathLocale:"/",permalink:null,routeMeta:{},slug:"navigation",filePath:"C:/Users/mi/Desktop/我的博客/docs/Navigation/navigation.md",filePathRelative:"Navigation/navigation.md",componentFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/Navigation/navigation.html.vue",componentFilePathRelative:"pages/Navigation/navigation.html.vue",componentFileChunkName:"v-d40e49ba",dataFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/Navigation/navigation.html.js",dataFilePathRelative:"pages/Navigation/navigation.html.js",dataFileChunkName:"v-d40e49ba",htmlFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/dist/Navigation/navigation.html",htmlFilePathRelative:"Navigation/navigation.html"},{data:{key:"v-af0475ae",path:"/Navigation/PDF.html",title:"PDF导航",lang:"zh-CN",frontmatter:{date:"2022/1/28 16:08",coverUrl:"http://cdn-ali-img-shstaticbz.shanhutech.cn/bizhi/staticwp/202107/0ee3a54e877205a6bd29ca2d23f44b43--2771443509.jpg",sticky:!0,keyword:null,description:"PDF导航",title:"PDF导航",tag:["PDF"],categories:["PDF"]},excerpt:"",headers:[{level:2,title:"前端js篇",slug:"前端js篇",children:[]},{level:2,title:"前端网络篇",slug:"前端网络篇",children:[]},{level:2,title:"前端面试小书",slug:"前端面试小书",children:[]},{level:2,title:"面试题精选大全",slug:"面试题精选大全",children:[]},{level:2,title:"算法",slug:"算法",children:[]}],git:{updatedTime:null,contributors:[]}},key:"v-af0475ae",path:"/Navigation/PDF.html",title:"PDF导航",lang:"zh-CN",frontmatter:{date:"2022/1/28 16:08",coverUrl:"http://cdn-ali-img-shstaticbz.shanhutech.cn/bizhi/staticwp/202107/0ee3a54e877205a6bd29ca2d23f44b43--2771443509.jpg",sticky:!0,keyword:null,description:"PDF导航",title:"PDF导航",tag:["PDF"],categories:["PDF"]},excerpt:"",headers:[{level:2,title:"前端js篇",slug:"前端js篇",children:[]},{level:2,title:"前端网络篇",slug:"前端网络篇",children:[]},{level:2,title:"前端面试小书",slug:"前端面试小书",children:[]},{level:2,title:"面试题精选大全",slug:"面试题精选大全",children:[]},{level:2,title:"算法",slug:"算法",children:[]}],content:'\r\n## 前端js篇\r\n[PDF链接](https://www.iewganfil.top/A/Books/%E5%89%8D%E7%AB%AFJS%E7%AF%87.pdf)\r\n\r\n---\r\n\r\n## 前端网络篇\r\n[PDF链接](https://www.iewganfil.top/A/Books/%E5%89%8D%E7%AB%AF%E7%BD%91%E7%BB%9C%E7%AF%87.pdf)\r\n\r\n---\r\n\r\n## 前端面试小书\r\n[PDF链接](https://www.iewganfil.top/A/Books/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%B0%8F%E4%B9%A6.pdf)\r\n\r\n---\r\n\r\n## 面试题精选大全\r\n[PDF链接](https://www.iewganfil.top/A/Books/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89%E5%A4%A7%E5%85%A8.pdf)\r\n\r\n---\r\n\r\n## 算法\r\n[PDF链接](https://www.iewganfil.top/A/Books/%E7%AE%97%E6%B3%95.pdf)\r\n\r\n--- \r\n\r\n<div style="font-weight:700; text-align:center; padding-top:20px;">最后更新时间：2022.02.14</div>\r\n',contentRendered:'<h2 id="前端js篇" tabindex="-1"><a class="header-anchor" href="#前端js篇" aria-hidden="true">#</a> 前端js篇</h2>\n<p><a href="https://www.iewganfil.top/A/Books/%E5%89%8D%E7%AB%AFJS%E7%AF%87.pdf" target="_blank" rel="noopener noreferrer">PDF链接<ExternalLinkIcon/></a></p>\n<hr>\n<h2 id="前端网络篇" tabindex="-1"><a class="header-anchor" href="#前端网络篇" aria-hidden="true">#</a> 前端网络篇</h2>\n<p><a href="https://www.iewganfil.top/A/Books/%E5%89%8D%E7%AB%AF%E7%BD%91%E7%BB%9C%E7%AF%87.pdf" target="_blank" rel="noopener noreferrer">PDF链接<ExternalLinkIcon/></a></p>\n<hr>\n<h2 id="前端面试小书" tabindex="-1"><a class="header-anchor" href="#前端面试小书" aria-hidden="true">#</a> 前端面试小书</h2>\n<p><a href="https://www.iewganfil.top/A/Books/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%B0%8F%E4%B9%A6.pdf" target="_blank" rel="noopener noreferrer">PDF链接<ExternalLinkIcon/></a></p>\n<hr>\n<h2 id="面试题精选大全" tabindex="-1"><a class="header-anchor" href="#面试题精选大全" aria-hidden="true">#</a> 面试题精选大全</h2>\n<p><a href="https://www.iewganfil.top/A/Books/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89%E5%A4%A7%E5%85%A8.pdf" target="_blank" rel="noopener noreferrer">PDF链接<ExternalLinkIcon/></a></p>\n<hr>\n<h2 id="算法" tabindex="-1"><a class="header-anchor" href="#算法" aria-hidden="true">#</a> 算法</h2>\n<p><a href="https://www.iewganfil.top/A/Books/%E7%AE%97%E6%B3%95.pdf" target="_blank" rel="noopener noreferrer">PDF链接<ExternalLinkIcon/></a></p>\n<hr>\n<div style="font-weight:700; text-align:center; padding-top:20px;">最后更新时间：2022.02.14</div>\n',date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:"/Navigation/PDF.html",pathLocale:"/",permalink:null,routeMeta:{},slug:"PDF",filePath:"C:/Users/mi/Desktop/我的博客/docs/Navigation/PDF.md",filePathRelative:"Navigation/PDF.md",componentFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/Navigation/PDF.html.vue",componentFilePathRelative:"pages/Navigation/PDF.html.vue",componentFileChunkName:"v-af0475ae",dataFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/Navigation/PDF.html.js",dataFilePathRelative:"pages/Navigation/PDF.html.js",dataFileChunkName:"v-af0475ae",htmlFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/dist/Navigation/PDF.html",htmlFilePathRelative:"Navigation/PDF.html"},{data:{key:"v-7ffc659c",path:"/study/study1.html",title:"扁平化",lang:"zh-CN",frontmatter:{date:"2022/1/20 20:23",coverUrl:"http://cdn-ali-img-shstaticbz.shanhutech.cn/bizhi/staticwp/202112/4df6635c747bc083c7f159628e545666--2426815410.jpg",sticky:!0,keyword:"设置keyword,设置keyword,设置keyword,设置keyword",description:"数组扁平化且删除重复数据",title:"扁平化",tag:["面试题"],categories:["Javascript"]},excerpt:"",headers:[{level:2,title:"实现方法",slug:"实现方法",children:[{level:3,title:"扩展：手写flat",slug:"扩展-手写flat",children:[]}]}],git:{updatedTime:1642771259e3,contributors:[{name:"iewgnafil",email:"1519467168@qq.com",commits:2}]}},key:"v-7ffc659c",path:"/study/study1.html",title:"扁平化",lang:"zh-CN",frontmatter:{date:"2022/1/20 20:23",coverUrl:"http://cdn-ali-img-shstaticbz.shanhutech.cn/bizhi/staticwp/202112/4df6635c747bc083c7f159628e545666--2426815410.jpg",sticky:!0,keyword:"设置keyword,设置keyword,设置keyword,设置keyword",description:"数组扁平化且删除重复数据",title:"扁平化",tag:["面试题"],categories:["Javascript"]},excerpt:"",headers:[{level:2,title:"实现方法",slug:"实现方法",children:[{level:3,title:"扩展：手写flat",slug:"扩展-手写flat",children:[]}]}],content:"\r\n# 题目示例：\r\n已知如下数组：\r\n\r\n\r\n```js\r\nvar arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];\r\n```\r\n编写一个程序将数组扁平化并去除其中重复部分数据，最终得到一个升序且不重复的数组。\r\n## 实现方法\r\n\r\n```js\r\nArray.from(new Set(arr.flat(`Infinity`))).sort((a,b)=>{ return a-b})\r\n```\r\n- ` flat()  ` 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。`flat`的语法：\r\n> var newArray = arr.flat([depth])\\\r\n> `depth` 指定要提取嵌套数组的结构深度，默认值为 1。\r\n- 全局属性 `Infinity` 是一个数值，表示无穷大。\r\n- `Set`中的元素只会**出现一次**，即 Set 中的元素是唯一的。\r\n- ` Array.from()  ` 方法对一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。\r\n- ` sort()  ` 对数组的元素进行排序，并返回数组。\r\n### 扩展：手写flat\r\n此处仅列举几种简单易懂的方法：\\\r\n\\\r\n`instanceof`递归实现：\r\n```js\r\nfunction myflat1(arr){\r\n    let res = []\r\n    function bp(arr)  {\r\n        let len = arr.length\r\n        for(let i = 0;i < len; i++){\r\n            if( arr[i] instanceof Array){     // 判断该元素是否为数组\r\n                let a = [...arr[i]]           // 如果是数组  对其进行结构  再进行递归\r\n                bp(a)\r\n            }else{\r\n                res.push(arr[i])            // 元素不为数组时 push到res数组里\r\n            }\r\n        }\r\n    }\r\n    bp(arr)\r\n    return res\r\n}\r\n```\r\n转字符串切割：\r\n\r\n```js\r\nfunction myflat2(arr){\r\n    arr = arr.toString()         // 将数组进行字符串转换\r\n    arr = arr.split(',')         // split()方法将字符串进行分割成子字符串数组，以一个指定的分割字串来决定每个拆分的位置。 \r\n    for(let i = 0,len = arr.length;i < len; i++){ \r\n        arr[i] = Number(arr[i])  // 将字符串数组的元素转换成Number类型\r\n    }\r\n    return arr\r\n}\r\n```\r\n基于`Array.isArray`的`while`循环\r\n\r\n```js\r\nfunction myflat3(arr) {\r\n    while (arr.some(Array.isArray)) {     \r\n        // Array.isArray() 用于确定传递的值是否是一个Array  \r\n        //some() 方法测试数组中是不是至少有1个元素通过了被提供的函数测试\r\n        arr = [].concat(...arr)  \r\n    }\r\n    return arr\r\n}\r\n```",contentRendered:'<h1 id="题目示例" tabindex="-1"><a class="header-anchor" href="#题目示例" aria-hidden="true">#</a> 题目示例：</h1>\n<p>已知如下数组：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">]</span> <span class="token punctuation">]</span> <span class="token punctuation">]</span> <span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>编写一个程序将数组扁平化并去除其中重复部分数据，最终得到一个升序且不重复的数组。</p>\n<h2 id="实现方法" tabindex="-1"><a class="header-anchor" href="#实现方法" aria-hidden="true">#</a> 实现方法</h2>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code>Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">flat</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Infinity</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span>b</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">{</span> <span class="token keyword">return</span> a<span class="token operator">-</span>b<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><ul>\n<li><code>flat() </code> 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。<code>flat</code>的语法：</li>\n</ul>\n<blockquote>\n<p>var newArray = arr.flat([depth])<br>\n<code>depth</code> 指定要提取嵌套数组的结构深度，默认值为 1。</p>\n</blockquote>\n<ul>\n<li>全局属性 <code>Infinity</code> 是一个数值，表示无穷大。</li>\n<li><code>Set</code>中的元素只会<strong>出现一次</strong>，即 Set 中的元素是唯一的。</li>\n<li><code>Array.from() </code> 方法对一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。</li>\n<li><code>sort() </code> 对数组的元素进行排序，并返回数组。</li>\n</ul>\n<h3 id="扩展-手写flat" tabindex="-1"><a class="header-anchor" href="#扩展-手写flat" aria-hidden="true">#</a> 扩展：手写flat</h3>\n<p>此处仅列举几种简单易懂的方法：<br>\n<br>\n<code>instanceof</code>递归实现：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">myflat1</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>\n    <span class="token keyword">function</span> <span class="token function">bp</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>\n        <span class="token keyword">let</span> len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length\n        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n            <span class="token keyword">if</span><span class="token punctuation">(</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token comment">// 判断该元素是否为数组</span>\n                <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span>           <span class="token comment">// 如果是数组  对其进行结构  再进行递归</span>\n                <span class="token function">bp</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>\n            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>\n                res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token comment">// 元素不为数组时 push到res数组里</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n    <span class="token function">bp</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>\n    <span class="token keyword">return</span> res\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>转字符串切割：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">myflat2</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    arr <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token comment">// 将数组进行字符串转换</span>\n    arr <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">\',\'</span><span class="token punctuation">)</span>         <span class="token comment">// split()方法将字符串进行分割成子字符串数组，以一个指定的分割字串来决定每个拆分的位置。 </span>\n    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span> \n        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">Number</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment">// 将字符串数组的元素转换成Number类型</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">return</span> arr\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>基于<code>Array.isArray</code>的<code>while</code>循环</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">myflat3</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">while</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">some</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span>isArray<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     \n        <span class="token comment">// Array.isArray() 用于确定传递的值是否是一个Array  </span>\n        <span class="token comment">//some() 方法测试数组中是不是至少有1个元素通过了被提供的函数测试</span>\n        arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token operator">...</span>arr<span class="token punctuation">)</span>  \n    <span class="token punctuation">}</span>\n    <span class="token keyword">return</span> arr\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div>',date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:"/study/study1.html",pathLocale:"/",permalink:null,routeMeta:{},slug:"study1",filePath:"C:/Users/mi/Desktop/我的博客/docs/study/study1.md",filePathRelative:"study/study1.md",componentFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/study/study1.html.vue",componentFilePathRelative:"pages/study/study1.html.vue",componentFileChunkName:"v-7ffc659c",dataFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/study/study1.html.js",dataFilePathRelative:"pages/study/study1.html.js",dataFileChunkName:"v-7ffc659c",htmlFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/dist/study/study1.html",htmlFilePathRelative:"study/study1.html"},{data:{key:"v-7c92b45e",path:"/study/study2.html",title:"防抖和节流",lang:"zh-CN",frontmatter:{date:"2022/1/20 20:23",coverUrl:"https://www.toopic.cn/public/uploads/small/1634265816194163426581671.jpg",sticky:!0,keyword:"设置keyword,设置keyword,设置keyword,设置keyword",description:"什么是防抖和节流？有什么区别？如何实现？",title:"防抖和节流",tag:["面试题"],categories:["Javascript"]},excerpt:"",headers:[],git:{updatedTime:16427402e5,contributors:[{name:"iewgnafil",email:"1519467168@qq.com",commits:1}]}},key:"v-7c92b45e",path:"/study/study2.html",title:"防抖和节流",lang:"zh-CN",frontmatter:{date:"2022/1/20 20:23",coverUrl:"https://www.toopic.cn/public/uploads/small/1634265816194163426581671.jpg",sticky:!0,keyword:"设置keyword,设置keyword,设置keyword,设置keyword",description:"什么是防抖和节流？有什么区别？如何实现？",title:"防抖和节流",tag:["面试题"],categories:["Javascript"]},excerpt:"",headers:[],content:"\r\n1.  **防抖**\r\n\r\n> 触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间\r\n\r\n-   思路：\r\n\r\n> 每次触发事件时都取消之前的延时调用方法\r\n\r\n```js\r\nfunction debounce(fn,delay) {\r\n      let timeout = null; // 创建一个标记用来存放定时器的返回值\r\n      return function () {\r\n        clearTimeout(timeout); // 每当用户输入的时候把前一个 setTimeout clear 掉\r\n        timeout = setTimeout(() => { // 然后又创建一个新的 setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数\r\n          fn.apply(this, arguments);  //加了apply，此时this为debounce的\r\n        }, delay);     // delay为事件触发时间间隔\r\n      };\r\n    }\r\n```\r\n2.  **节流**\r\n\r\n> 高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率\r\n\r\n-   思路：\r\n\r\n> 每次触发事件时都判断与前一次执行是否间隔事件大于n秒\r\n\r\n```js\r\nfunction throttle(fn, delay){\r\n    let time = 0\r\n    return function(){\r\n        let now = Date.now();     // 每次点击都记录此时的时间戳\r\n        //console.log(now);\r\n        if(now - time >= delay){ //点击时的时间相比较前一次点击  至少要相差delay时间  否则不执行\r\n            fn.apply(this,arguments) //加了apply，此时this为throttle的 \r\n        }\r\n        time = Date.now()     // 触发事件之后，更新此时的时间，用于下一次的判断\r\n    }\r\n}\r\n```",contentRendered:'<ol>\n<li><strong>防抖</strong></li>\n</ol>\n<blockquote>\n<p>触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间</p>\n</blockquote>\n<ul>\n<li>思路：</li>\n</ul>\n<blockquote>\n<p>每次触发事件时都取消之前的延时调用方法</p>\n</blockquote>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span>delay</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">let</span> timeout <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 创建一个标记用来存放定时器的返回值</span>\n      <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 每当用户输入的时候把前一个 setTimeout clear 掉</span>\n        timeout <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span> <span class="token comment">// 然后又创建一个新的 setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数</span>\n          <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//加了apply，此时this为debounce的</span>\n        <span class="token punctuation">}</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// delay为事件触发时间间隔</span>\n      <span class="token punctuation">}</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><ol start="2">\n<li><strong>节流</strong></li>\n</ol>\n<blockquote>\n<p>高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率</p>\n</blockquote>\n<ul>\n<li>思路：</li>\n</ul>\n<blockquote>\n<p>每次触发事件时都判断与前一次执行是否间隔事件大于n秒</p>\n</blockquote>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> delay</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token keyword">let</span> time <span class="token operator">=</span> <span class="token number">0</span>\n    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token keyword">let</span> now <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 每次点击都记录此时的时间戳</span>\n        <span class="token comment">//console.log(now);</span>\n        <span class="token keyword">if</span><span class="token punctuation">(</span>now <span class="token operator">-</span> time <span class="token operator">>=</span> delay<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">//点击时的时间相比较前一次点击  至少要相差delay时间  否则不执行</span>\n            <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>arguments<span class="token punctuation">)</span> <span class="token comment">//加了apply，此时this为throttle的 </span>\n        <span class="token punctuation">}</span>\n        time <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token comment">// 触发事件之后，更新此时的时间，用于下一次的判断</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div>',date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:"/study/study2.html",pathLocale:"/",permalink:null,routeMeta:{},slug:"study2",filePath:"C:/Users/mi/Desktop/我的博客/docs/study/study2.md",filePathRelative:"study/study2.md",componentFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/study/study2.html.vue",componentFilePathRelative:"pages/study/study2.html.vue",componentFileChunkName:"v-7c92b45e",dataFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/study/study2.html.js",dataFilePathRelative:"pages/study/study2.html.js",dataFileChunkName:"v-7c92b45e",htmlFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/dist/study/study2.html",htmlFilePathRelative:"study/study2.html"},{data:{key:"v-79290320",path:"/study/study3.html",title:"输出什么",lang:"zh-CN",frontmatter:{date:"2022/1/20 20:23",coverUrl:"http://cdn-ali-img-shstaticbz.shanhutech.cn/bizhi/staticwp/202109/ac3990b3d19dd512dd6f6a364e70848a--1897315302.jpg",sticky:!0,keyword:"设置keyword,设置keyword,设置keyword,设置keyword",description:"输出什么",title:"输出什么",tag:["面试题"],categories:["Javascript"]},excerpt:"",headers:[{level:3,title:"map",slug:"map",children:[]},{level:3,title:"parseInt",slug:"parseint",children:[]},{level:3,title:"回到真实的事例上",slug:"回到真实的事例上",children:[]}],git:{updatedTime:16427402e5,contributors:[{name:"iewgnafil",email:"1519467168@qq.com",commits:1}]}},key:"v-79290320",path:"/study/study3.html",title:"输出什么",lang:"zh-CN",frontmatter:{date:"2022/1/20 20:23",coverUrl:"http://cdn-ali-img-shstaticbz.shanhutech.cn/bizhi/staticwp/202109/ac3990b3d19dd512dd6f6a364e70848a--1897315302.jpg",sticky:!0,keyword:"设置keyword,设置keyword,设置keyword,设置keyword",description:"输出什么",title:"输出什么",tag:["面试题"],categories:["Javascript"]},excerpt:"",headers:[{level:3,title:"map",slug:"map",children:[]},{level:3,title:"parseInt",slug:"parseint",children:[]},{level:3,title:"回到真实的事例上",slug:"回到真实的事例上",children:[]}],content:"\r\n### map\r\n`map()` 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。\r\n\r\n\r\n```js\r\nvar new_array = arr.map(function callback(currentValue[,index[, array]]) {\r\n // Return element for new_array\r\n }[, thisArg])\r\n```\r\n可以看到`callback`回调函数需要三个参数, 我们通常只使用第一个参数 (其他两个参数是可选的)。\\\r\n`currentValue` 是callback 数组中正在处理的当前元素。\\\r\n`index`可选, 是callback 数组中正在处理的当前元素的索引。\\\r\n`array`可选, 是callback map 方法被调用的数组。\\\r\n另外还有`thisArg`可选, 执行 callback 函数时使用的this 值。\r\n\r\n```js\r\nconst arr = [1, 2, 3];\r\narr.map((num) => num + 1); // [2, 3, 4]\r\n```\r\n### parseInt\r\n`parseInt()` 函数解析一个字符串参数，并返回一个指定基数的整数 (数学系统的基础)。\r\n\r\n```js\r\nconst intValue = parseInt(string[, radix]);\r\n```\r\n`string` 要被解析的值。如果参数不是一个字符串，则将其转换为字符串(使用 ToString 抽象操作)。字符串开头的空白符将会被忽略。\r\n\r\n`radix` 一个介于2和36之间的整数(数学系统的基础)，表示上述字符串的基数。默认为10。\\\r\n`返回值` 返回一个整数或NaN\r\n\r\n```js\r\nparseInt(100); // 100\r\nparseInt(100, 10); // 100\r\nparseInt(100, 2); // 4 -> 将100视为2进制下的显示  则为4\r\n```\r\n\r\n### 回到真实的事例上\r\n\r\n回到我们真实的事例上\r\n\r\n```js\r\n['1', '2', '3'].map(parseInt)\r\n```\r\n对于每个迭代`map`, `parseInt()`传递两个参数: **字符串和基数**。\\\r\n所以实际执行的的代码是：\r\n\r\n```js\r\n['1', '2', '3'].map((item, index) => {\r\n\treturn parseInt(item, index)\r\n})\r\n```\r\n即返回的值分别为：\r\n\r\n```js\r\nparseInt('1', 0) // 1\r\nparseInt('2', 1) // NaN\r\nparseInt('3', 2) // NaN, 3 不是二进制\r\n```\r\n所以：\r\n\r\n```js\r\n['1', '2', '3'].map(parseInt)\r\n// 1, NaN, NaN\r\n```",contentRendered:'<h3 id="map" tabindex="-1"><a class="header-anchor" href="#map" aria-hidden="true">#</a> map</h3>\n<p><code>map()</code> 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">var</span> new_array <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token parameter">currentValue<span class="token punctuation">[</span><span class="token punctuation">,</span>index<span class="token punctuation">[</span><span class="token punctuation">,</span> array<span class="token punctuation">]</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n <span class="token comment">// Return element for new_array</span>\n <span class="token punctuation">}</span><span class="token punctuation">[</span><span class="token punctuation">,</span> thisArg<span class="token punctuation">]</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>可以看到<code>callback</code>回调函数需要三个参数, 我们通常只使用第一个参数 (其他两个参数是可选的)。<br>\n<code>currentValue</code> 是callback 数组中正在处理的当前元素。<br>\n<code>index</code>可选, 是callback 数组中正在处理的当前元素的索引。<br>\n<code>array</code>可选, 是callback map 方法被调用的数组。<br>\n另外还有<code>thisArg</code>可选, 执行 callback 函数时使用的this 值。</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\narr<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">num</span><span class="token punctuation">)</span> <span class="token operator">=></span> num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [2, 3, 4]</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="parseint" tabindex="-1"><a class="header-anchor" href="#parseint" aria-hidden="true">#</a> parseInt</h3>\n<p><code>parseInt()</code> 函数解析一个字符串参数，并返回一个指定基数的整数 (数学系统的基础)。</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">const</span> intValue <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>string<span class="token punctuation">[</span><span class="token punctuation">,</span> radix<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p><code>string</code> 要被解析的值。如果参数不是一个字符串，则将其转换为字符串(使用 ToString 抽象操作)。字符串开头的空白符将会被忽略。</p>\n<p><code>radix</code> 一个介于2和36之间的整数(数学系统的基础)，表示上述字符串的基数。默认为10。<br>\n<code>返回值</code> 返回一个整数或NaN</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 100</span>\n<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 100</span>\n<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 4 -> 将100视为2进制下的显示  则为4</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="回到真实的事例上" tabindex="-1"><a class="header-anchor" href="#回到真实的事例上" aria-hidden="true">#</a> 回到真实的事例上</h3>\n<p>回到我们真实的事例上</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token punctuation">[</span><span class="token string">\'1\'</span><span class="token punctuation">,</span> <span class="token string">\'2\'</span><span class="token punctuation">,</span> <span class="token string">\'3\'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>parseInt<span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>对于每个迭代<code>map</code>, <code>parseInt()</code>传递两个参数: <strong>字符串和基数</strong>。<br>\n所以实际执行的的代码是：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token punctuation">[</span><span class="token string">\'1\'</span><span class="token punctuation">,</span> <span class="token string">\'2\'</span><span class="token punctuation">,</span> <span class="token string">\'3\'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n\t<span class="token keyword">return</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> index<span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>即返回的值分别为：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">\'1\'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// 1</span>\n<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">\'2\'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// NaN</span>\n<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">\'3\'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// NaN, 3 不是二进制</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>所以：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token punctuation">[</span><span class="token string">\'1\'</span><span class="token punctuation">,</span> <span class="token string">\'2\'</span><span class="token punctuation">,</span> <span class="token string">\'3\'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>parseInt<span class="token punctuation">)</span>\n<span class="token comment">// 1, NaN, NaN</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div>',date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:"/study/study3.html",pathLocale:"/",permalink:null,routeMeta:{},slug:"study3",filePath:"C:/Users/mi/Desktop/我的博客/docs/study/study3.md",filePathRelative:"study/study3.md",componentFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/study/study3.html.vue",componentFilePathRelative:"pages/study/study3.html.vue",componentFileChunkName:"v-79290320",dataFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/study/study3.html.js",dataFilePathRelative:"pages/study/study3.html.js",dataFileChunkName:"v-79290320",htmlFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/dist/study/study3.html",htmlFilePathRelative:"study/study3.html"},{data:{key:"v-75bf51e2",path:"/study/study4.html",title:"跨域",lang:"zh-CN",frontmatter:{date:"2022/1/21 20:23",coverUrl:"http://cdn-ali-img-shstaticbz.shanhutech.cn/bizhi/staticwp/202201/ec75de816ec1a1e965b9604a936e5c3e--333631415.jpg",sticky:!0,keyword:"跨域,jsonp,cros,postMessage",description:"跨域",title:"跨域",tag:["跨域","面试题"],categories:["跨域"]},excerpt:"",headers:[{level:2,title:"常见的跨域场景",slug:"常见的跨域场景",children:[]},{level:2,title:"特别说明",slug:"特别说明",children:[]},{level:2,title:"跨域的解决方案",slug:"跨域的解决方案",children:[{level:3,title:"1. jsonp",slug:"_1-jsonp",children:[]},{level:3,title:"2. cors",slug:"_2-cors",children:[]},{level:3,title:"3. postMessage",slug:"_3-postmessage",children:[]}]}],git:{updatedTime:1642771259e3,contributors:[{name:"iewgnafil",email:"1519467168@qq.com",commits:2}]}},key:"v-75bf51e2",path:"/study/study4.html",title:"跨域",lang:"zh-CN",frontmatter:{date:"2022/1/21 20:23",coverUrl:"http://cdn-ali-img-shstaticbz.shanhutech.cn/bizhi/staticwp/202201/ec75de816ec1a1e965b9604a936e5c3e--333631415.jpg",sticky:!0,keyword:"跨域,jsonp,cros,postMessage",description:"跨域",title:"跨域",tag:["跨域","面试题"],categories:["跨域"]},excerpt:"",headers:[{level:2,title:"常见的跨域场景",slug:"常见的跨域场景",children:[]},{level:2,title:"特别说明",slug:"特别说明",children:[]},{level:2,title:"跨域的解决方案",slug:"跨域的解决方案",children:[{level:3,title:"1. jsonp",slug:"_1-jsonp",children:[]},{level:3,title:"2. cors",slug:"_2-cors",children:[]},{level:3,title:"3. postMessage",slug:"_3-postmessage",children:[]}]}],content:'\r\n# 什么是跨域\r\n浏览器都具有同源策略  --- 协议 + 域名 + 端口  都相同\r\n\r\nhttp://   www   .    abc.com  :    8080   /    detail   \\\r\n 协议    子域名       主域名        端口        请求资源地址\r\n\r\n\r\n - 同源策略限制了ajax请求\r\n\r\n - 没有被同源策略所影响的三个标签\r\n ```js\r\n   <img src="xxx> \r\n   <link href="xxx>\r\n   <script src="xxx">\r\n```\r\n   \r\n\r\n## 常见的跨域场景\r\nhttp://www.a.com/a.js   \\\r\nhttp://www.a.com/b.js      同一个域名，允许通信\r\n\r\n\r\nhttp://www.a.com/a.js     \\\r\nhttps://www.a.com/a.js     协议不同，跨域\r\n\r\n\r\nhttp://www.a.com/a.js      \\\r\nhttp://script.a.com/a.js\t 主域相同，子域不相同，跨域\r\n\r\n\r\n## 特别说明\r\n1. 如果是端口和协议照成的跨域，前端是没有办法解决的\r\n2. 跨域仅仅只是根据url的首部 来识别，不会根据这个首部对应得ip地址来判断\r\n3. 跨域并不是请求没有发出去，请求时能发出去得，服务器也是能响应的，只是响应结果被浏览器拦截了\r\n\r\n\r\n## 跨域的解决方案\r\n### 1. jsonp\r\n  原理：**利用script标签上的src属性不会被同源的策略所拦截的这一机制**，将我们要请求的url地址，添加到script的src属性中，且携带上前端全局下的函数名作为参数给到后端，后端获取到前端传递的函数名，然后返回该函数的调用语法，将要返回的数据放在该函数的调用中作为参数，当浏览器接收到全局下的函数被调用的后端响应，会自动执行该函数，从而从参数中获取到后端返回的数据\r\n\r\n  缺点：\r\n  1. 需要对方的服务器做支持才可以\r\n  2. 只支持**get** 请求，有局限性，可能会遭到 **XSS攻击**\r\n\r\n\r\n### 2. cors\r\n  cors是W3C的标准，它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求。也就是说浏览器发请求是不会被跨域的，跨域的核心是后端响应不了。\r\n\r\n  >要让后端响应内容能够补被浏览器拦截，关键在于后端。如果后端也能遵从CorS标准的话，后端的响应也可以跨源.\r\n\r\n分为简单请求和复杂请求两种：\r\n  - 简单请求\\\r\n    . 使用GET、POST、HEAD \\\r\n    . Content-Type的值仅限于:**text/plain || multipart/from-data || application/x-www-from-urlencoded**\r\n\r\n  - 复杂请求\\\r\n    .  不满足简单请求的条件的就是复杂请求\\\r\n    .  复杂请求的cors请求，会在正式通信之前，增加一次http查询请求，称为"预检"，预检是用来知道服务端是都允许跨域请求，预检请求发的是options方法\r\n\r\n### 3. postMessage\r\n  html5中的 xhr 提供的API，postMessage()方法允许来自不同源的脚本采用异步的方法进行有限通信，可以实现跨文本，多窗口，跨域消息传递 \\\r\n  可以解决这么几个问题：\r\n  - 页面和其他新的窗口的数据传递\r\n  - 多窗口之间的消息传递\r\n  - 页面与嵌套的iframe消息传递\r\n  - 上面三个场景的跨域数据传递\r\n\r\n\r\n  otherWindow.postMessage(message, targrtOrigin, [transfer])\r\n  - message: 要发送给其他window的数据\r\n  - targetOrigin: 目标窗口\r\n  - transfer(可选)和message一起传递的一个对象，这个对象的所有权限将移交给消息接收方\r\n\r\n  缺点: **场景比较简单**\r\n\r\n\r\n  [参考链接](https://juejin.cn/post/6992525007716876325#heading-59)',contentRendered:'<h1 id="什么是跨域" tabindex="-1"><a class="header-anchor" href="#什么是跨域" aria-hidden="true">#</a> 什么是跨域</h1>\n<p>浏览器都具有同源策略  --- 协议 + 域名 + 端口  都相同</p>\n<p>http://   www   .    abc.com  :    8080   /    detail   <br>\n协议    子域名       主域名        端口        请求资源地址</p>\n<ul>\n<li>\n<p>同源策略限制了ajax请求</p>\n</li>\n<li>\n<p>没有被同源策略所影响的三个标签</p>\n</li>\n</ul>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code>  <span class="token operator">&lt;</span>img src<span class="token operator">=</span>"xxx<span class="token operator">></span> \n  <span class="token operator">&lt;</span>link href<span class="token operator">=</span>"xxx<span class="token operator">></span>\n  <span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"xxx"</span><span class="token operator">></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="常见的跨域场景" tabindex="-1"><a class="header-anchor" href="#常见的跨域场景" aria-hidden="true">#</a> 常见的跨域场景</h2>\n<p>http://www.a.com/a.js   <br>\nhttp://www.a.com/b.js      同一个域名，允许通信</p>\n<p>http://www.a.com/a.js     <br>\nhttps://www.a.com/a.js     协议不同，跨域</p>\n<p>http://www.a.com/a.js      <br>\nhttp://script.a.com/a.js\t 主域相同，子域不相同，跨域</p>\n<h2 id="特别说明" tabindex="-1"><a class="header-anchor" href="#特别说明" aria-hidden="true">#</a> 特别说明</h2>\n<ol>\n<li>如果是端口和协议照成的跨域，前端是没有办法解决的</li>\n<li>跨域仅仅只是根据url的首部 来识别，不会根据这个首部对应得ip地址来判断</li>\n<li>跨域并不是请求没有发出去，请求时能发出去得，服务器也是能响应的，只是响应结果被浏览器拦截了</li>\n</ol>\n<h2 id="跨域的解决方案" tabindex="-1"><a class="header-anchor" href="#跨域的解决方案" aria-hidden="true">#</a> 跨域的解决方案</h2>\n<h3 id="_1-jsonp" tabindex="-1"><a class="header-anchor" href="#_1-jsonp" aria-hidden="true">#</a> 1. jsonp</h3>\n<p>原理：<strong>利用script标签上的src属性不会被同源的策略所拦截的这一机制</strong>，将我们要请求的url地址，添加到script的src属性中，且携带上前端全局下的函数名作为参数给到后端，后端获取到前端传递的函数名，然后返回该函数的调用语法，将要返回的数据放在该函数的调用中作为参数，当浏览器接收到全局下的函数被调用的后端响应，会自动执行该函数，从而从参数中获取到后端返回的数据</p>\n<p>缺点：</p>\n<ol>\n<li>需要对方的服务器做支持才可以</li>\n<li>只支持<strong>get</strong> 请求，有局限性，可能会遭到 <strong>XSS攻击</strong></li>\n</ol>\n<h3 id="_2-cors" tabindex="-1"><a class="header-anchor" href="#_2-cors" aria-hidden="true">#</a> 2. cors</h3>\n<p>cors是W3C的标准，它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求。也就是说浏览器发请求是不会被跨域的，跨域的核心是后端响应不了。</p>\n<blockquote>\n<p>要让后端响应内容能够补被浏览器拦截，关键在于后端。如果后端也能遵从CorS标准的话，后端的响应也可以跨源.</p>\n</blockquote>\n<p>分为简单请求和复杂请求两种：</p>\n<ul>\n<li>\n<p>简单请求<br>\n. 使用GET、POST、HEAD <br>\n. Content-Type的值仅限于:<strong>text/plain || multipart/from-data || application/x-www-from-urlencoded</strong></p>\n</li>\n<li>\n<p>复杂请求<br>\n.  不满足简单请求的条件的就是复杂请求<br>\n.  复杂请求的cors请求，会在正式通信之前，增加一次http查询请求，称为&quot;预检&quot;，预检是用来知道服务端是都允许跨域请求，预检请求发的是options方法</p>\n</li>\n</ul>\n<h3 id="_3-postmessage" tabindex="-1"><a class="header-anchor" href="#_3-postmessage" aria-hidden="true">#</a> 3. postMessage</h3>\n<p>html5中的 xhr 提供的API，postMessage()方法允许来自不同源的脚本采用异步的方法进行有限通信，可以实现跨文本，多窗口，跨域消息传递 <br>\n可以解决这么几个问题：</p>\n<ul>\n<li>页面和其他新的窗口的数据传递</li>\n<li>多窗口之间的消息传递</li>\n<li>页面与嵌套的iframe消息传递</li>\n<li>上面三个场景的跨域数据传递</li>\n</ul>\n<p>otherWindow.postMessage(message, targrtOrigin, [transfer])</p>\n<ul>\n<li>message: 要发送给其他window的数据</li>\n<li>targetOrigin: 目标窗口</li>\n<li>transfer(可选)和message一起传递的一个对象，这个对象的所有权限将移交给消息接收方</li>\n</ul>\n<p>缺点: <strong>场景比较简单</strong></p>\n<p><a href="https://juejin.cn/post/6992525007716876325#heading-59" target="_blank" rel="noopener noreferrer">参考链接<ExternalLinkIcon/></a></p>\n',date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:"/study/study4.html",pathLocale:"/",permalink:null,routeMeta:{},slug:"study4",filePath:"C:/Users/mi/Desktop/我的博客/docs/study/study4.md",filePathRelative:"study/study4.md",componentFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/study/study4.html.vue",componentFilePathRelative:"pages/study/study4.html.vue",componentFileChunkName:"v-75bf51e2",dataFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/study/study4.html.js",dataFilePathRelative:"pages/study/study4.html.js",dataFileChunkName:"v-75bf51e2",htmlFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/dist/study/study4.html",htmlFilePathRelative:"study/study4.html"},{data:{key:"v-3706649a",path:"/404.html",title:"",lang:"zh-CN",frontmatter:{layout:"404"},excerpt:"",headers:[],git:{}},key:"v-3706649a",path:"/404.html",title:"",lang:"zh-CN",frontmatter:{layout:"404"},excerpt:"",headers:[],content:"",contentRendered:"",date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:null,pathLocale:"/",permalink:null,routeMeta:{},slug:"",filePath:null,filePathRelative:null,componentFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/404.html.vue",componentFilePathRelative:"pages/404.html.vue",componentFileChunkName:"v-3706649a",dataFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/404.html.js",dataFilePathRelative:"pages/404.html.js",dataFileChunkName:"v-3706649a",htmlFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/dist/404.html",htmlFilePathRelative:"404.html"},{data:{key:"v-8daa1a0e",path:"/",title:"",lang:"zh-CN",frontmatter:{layout:"Layout",home:!0},excerpt:"",headers:[],git:{}},key:"v-8daa1a0e",path:"/",title:"",lang:"zh-CN",frontmatter:{layout:"Layout",home:!0},excerpt:"",headers:[],content:"",contentRendered:"",date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:null,pathLocale:"/",permalink:null,routeMeta:{},slug:"",filePath:null,filePathRelative:null,componentFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/index.html.vue",componentFilePathRelative:"pages/index.html.vue",componentFileChunkName:"v-8daa1a0e",dataFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/index.html.js",dataFilePathRelative:"pages/index.html.js",dataFileChunkName:"v-8daa1a0e",htmlFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/dist/index.html",htmlFilePathRelative:"index.html"},{data:{key:"v-74bc627b",path:"/about/",title:"",lang:"zh-CN",frontmatter:{layout:"About",slug:"aurora-about"},excerpt:"",headers:[],git:{}},key:"v-74bc627b",path:"/about/",title:"",lang:"zh-CN",frontmatter:{layout:"About",slug:"aurora-about"},excerpt:"",headers:[],content:"",contentRendered:"",date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:null,pathLocale:"/",permalink:null,routeMeta:{},slug:"",filePath:null,filePathRelative:null,componentFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/about/index.html.vue",componentFilePathRelative:"pages/about/index.html.vue",componentFileChunkName:"v-74bc627b",dataFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/about/index.html.js",dataFilePathRelative:"pages/about/index.html.js",dataFileChunkName:"v-74bc627b",htmlFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/dist/about/index.html",htmlFilePathRelative:"about/index.html"},{data:{key:"v-14f724bf",path:"/mood/",title:"",lang:"zh-CN",frontmatter:{layout:"Mood",slug:"aurora-mood"},excerpt:"",headers:[],git:{}},key:"v-14f724bf",path:"/mood/",title:"",lang:"zh-CN",frontmatter:{layout:"Mood",slug:"aurora-mood"},excerpt:"",headers:[],content:"",contentRendered:"",date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:null,pathLocale:"/",permalink:null,routeMeta:{},slug:"",filePath:null,filePathRelative:null,componentFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/mood/index.html.vue",componentFilePathRelative:"pages/mood/index.html.vue",componentFileChunkName:"v-14f724bf",dataFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/mood/index.html.js",dataFilePathRelative:"pages/mood/index.html.js",dataFileChunkName:"v-14f724bf",htmlFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/dist/mood/index.html",htmlFilePathRelative:"mood/index.html"},{data:{key:"v-14e6501c",path:"/link/",title:"",lang:"zh-CN",frontmatter:{layout:"Link",slug:"aurora-link"},excerpt:"",headers:[],git:{}},key:"v-14e6501c",path:"/link/",title:"",lang:"zh-CN",frontmatter:{layout:"Link",slug:"aurora-link"},excerpt:"",headers:[],content:"",contentRendered:"",date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:null,pathLocale:"/",permalink:null,routeMeta:{},slug:"",filePath:null,filePathRelative:null,componentFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/link/index.html.vue",componentFilePathRelative:"pages/link/index.html.vue",componentFileChunkName:"v-14e6501c",dataFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/link/index.html.js",dataFilePathRelative:"pages/link/index.html.js",dataFileChunkName:"v-14e6501c",htmlFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/dist/link/index.html",htmlFilePathRelative:"link/index.html"},{data:{key:"v-744d024e",path:"/tag/",title:"",lang:"zh-CN",frontmatter:{layout:"Tag",slug:"aurora-tag"},excerpt:"",headers:[],git:{}},key:"v-744d024e",path:"/tag/",title:"",lang:"zh-CN",frontmatter:{layout:"Tag",slug:"aurora-tag"},excerpt:"",headers:[],content:"",contentRendered:"",date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:null,pathLocale:"/",permalink:null,routeMeta:{},slug:"",filePath:null,filePathRelative:null,componentFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/tag/index.html.vue",componentFilePathRelative:"pages/tag/index.html.vue",componentFileChunkName:"v-744d024e",dataFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/tag/index.html.js",dataFilePathRelative:"pages/tag/index.html.js",dataFileChunkName:"v-744d024e",htmlFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/dist/tag/index.html",htmlFilePathRelative:"tag/index.html"},{data:{key:"v-705c21a6",path:"/archive/",title:"",lang:"zh-CN",frontmatter:{layout:"Archive",slug:"aurora-archive"},excerpt:"",headers:[],git:{}},key:"v-705c21a6",path:"/archive/",title:"",lang:"zh-CN",frontmatter:{layout:"Archive",slug:"aurora-archive"},excerpt:"",headers:[],content:"",contentRendered:"",date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:null,pathLocale:"/",permalink:null,routeMeta:{},slug:"",filePath:null,filePathRelative:null,componentFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/archive/index.html.vue",componentFilePathRelative:"pages/archive/index.html.vue",componentFileChunkName:"v-705c21a6",dataFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/archive/index.html.js",dataFilePathRelative:"pages/archive/index.html.js",dataFileChunkName:"v-705c21a6",htmlFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/dist/archive/index.html",htmlFilePathRelative:"archive/index.html"},{data:{key:"v-6629f178",path:"/aurora-coze/",title:"",lang:"zh-CN",frontmatter:{layout:"CozeMood",slug:"aurora-coze-mood"},excerpt:"",headers:[],git:{}},key:"v-6629f178",path:"/aurora-coze/",title:"",lang:"zh-CN",frontmatter:{layout:"CozeMood",slug:"aurora-coze-mood"},excerpt:"",headers:[],content:"",contentRendered:"",date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:null,pathLocale:"/",permalink:null,routeMeta:{},slug:"",filePath:null,filePathRelative:null,componentFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/aurora-coze/index.html.vue",componentFilePathRelative:"pages/aurora-coze/index.html.vue",componentFileChunkName:"v-6629f178",dataFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/aurora-coze/index.html.js",dataFilePathRelative:"pages/aurora-coze/index.html.js",dataFileChunkName:"v-6629f178",htmlFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/dist/aurora-coze/index.html",htmlFilePathRelative:"aurora-coze/index.html"},{data:{key:"v-f693f690",path:"/aurora-register/",title:"",lang:"zh-CN",frontmatter:{layout:"RegisterUser",slug:"aurora-coze-register"},excerpt:"",headers:[],git:{}},key:"v-f693f690",path:"/aurora-register/",title:"",lang:"zh-CN",frontmatter:{layout:"RegisterUser",slug:"aurora-coze-register"},excerpt:"",headers:[],content:"",contentRendered:"",date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:null,pathLocale:"/",permalink:null,routeMeta:{},slug:"",filePath:null,filePathRelative:null,componentFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/aurora-register/index.html.vue",componentFilePathRelative:"pages/aurora-register/index.html.vue",componentFileChunkName:"v-f693f690",dataFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/aurora-register/index.html.js",dataFilePathRelative:"pages/aurora-register/index.html.js",dataFileChunkName:"v-f693f690",htmlFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/dist/aurora-register/index.html",htmlFilePathRelative:"aurora-register/index.html"},{data:{key:"v-e2acc714",path:"/photo/",title:"",lang:"zh-CN",frontmatter:{layout:"CozePhoto",slug:"aurora-photo"},excerpt:"",headers:[],git:{}},key:"v-e2acc714",path:"/photo/",title:"",lang:"zh-CN",frontmatter:{layout:"CozePhoto",slug:"aurora-photo"},excerpt:"",headers:[],content:"",contentRendered:"",date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:null,pathLocale:"/",permalink:null,routeMeta:{},slug:"",filePath:null,filePathRelative:null,componentFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/photo/index.html.vue",componentFilePathRelative:"pages/photo/index.html.vue",componentFileChunkName:"v-e2acc714",dataFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/photo/index.html.js",dataFilePathRelative:"pages/photo/index.html.js",dataFileChunkName:"v-e2acc714",htmlFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/dist/photo/index.html",htmlFilePathRelative:"photo/index.html"},{data:{key:"v-3c506944",path:"/aurora-music/",title:"",lang:"zh-CN",frontmatter:{layout:"AuroraMusic",slug:"aurora-plugin-music"},excerpt:"",headers:[],git:{}},key:"v-3c506944",path:"/aurora-music/",title:"",lang:"zh-CN",frontmatter:{layout:"AuroraMusic",slug:"aurora-plugin-music"},excerpt:"",headers:[],content:"",contentRendered:"",date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:null,pathLocale:"/",permalink:null,routeMeta:{},slug:"",filePath:null,filePathRelative:null,componentFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/aurora-music/index.html.vue",componentFilePathRelative:"pages/aurora-music/index.html.vue",componentFileChunkName:"v-3c506944",dataFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/aurora-music/index.html.js",dataFilePathRelative:"pages/aurora-music/index.html.js",dataFileChunkName:"v-3c506944",htmlFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/dist/aurora-music/index.html",htmlFilePathRelative:"aurora-music/index.html"},{data:{key:"v-3279cf61",path:"/aurora-archive/",title:"",lang:"zh-CN",frontmatter:{layout:"AuroraArchive",slug:"aurora-plugin-archive"},excerpt:"",headers:[],git:{}},key:"v-3279cf61",path:"/aurora-archive/",title:"",lang:"zh-CN",frontmatter:{layout:"AuroraArchive",slug:"aurora-plugin-archive"},excerpt:"",headers:[],content:"",contentRendered:"",date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:null,pathLocale:"/",permalink:null,routeMeta:{},slug:"",filePath:null,filePathRelative:null,componentFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/aurora-archive/index.html.vue",componentFilePathRelative:"pages/aurora-archive/index.html.vue",componentFileChunkName:"v-3279cf61",dataFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/aurora-archive/index.html.js",dataFilePathRelative:"pages/aurora-archive/index.html.js",dataFileChunkName:"v-3279cf61",htmlFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/dist/aurora-archive/index.html",htmlFilePathRelative:"aurora-archive/index.html"}]},7039:(n,a,s)=>{s.d(a,{Z:()=>e});const e=[{data:{key:"v-245bbacd",path:"/how-to-write-article.html",title:"JavaScript数据类型的相关问题看这篇文章就够了",lang:"zh-CN",frontmatter:{date:"2022/1/20 10:08",coverUrl:"https://pic1.zhimg.com/80/v2-904505bcf0c424788f6028b8952aa2e7_1440w.jpg?source=1940ef5c",sticky:!0,keyword:"设置keyword,设置keyword,设置keyword,设置keyword",description:"JavaScript 数据类型种类、存储方式、判断方法",title:"JavaScript数据类型的相关问题看这篇文章就够了",tag:["笔记"],categories:["Javascript"]},excerpt:"",headers:[{level:2,title:"了解强、弱类型和动态、静态类型语言",slug:"了解强、弱类型和动态、静态类型语言",children:[{level:3,title:"强类型",slug:"强类型",children:[]},{level:3,title:"弱类型",slug:"弱类型",children:[]},{level:3,title:"静态类型",slug:"静态类型",children:[]},{level:3,title:"动态类型",slug:"动态类型",children:[]}]},{level:2,title:"基本数据类型",slug:"基本数据类型",children:[]},{level:2,title:"引用数据类型",slug:"引用数据类型",children:[{level:3,title:"引用类型的检索",slug:"引用类型的检索",children:[]}]},{level:2,title:"拓展：深浅拷贝",slug:"拓展-深浅拷贝",children:[{level:3,title:"手写方法实现深拷贝：",slug:"手写方法实现深拷贝",children:[]}]},{level:2,title:"typeof方法",slug:"typeof方法",children:[]},{level:2,title:"拓展：为什么null返回的是一个object呢？",slug:"拓展-为什么null返回的是一个object呢",children:[]},{level:2,title:"instanceof方法",slug:"instanceof方法",children:[]}],git:{updatedTime:1642668034e3,contributors:[{name:"iewgnafil",email:"1519467168@qq.com",commits:1}]}},key:"v-245bbacd",path:"/how-to-write-article.html",title:"JavaScript数据类型的相关问题看这篇文章就够了",lang:"zh-CN",frontmatter:{date:"2022/1/20 10:08",coverUrl:"https://pic1.zhimg.com/80/v2-904505bcf0c424788f6028b8952aa2e7_1440w.jpg?source=1940ef5c",sticky:!0,keyword:"设置keyword,设置keyword,设置keyword,设置keyword",description:"JavaScript 数据类型种类、存储方式、判断方法",title:"JavaScript数据类型的相关问题看这篇文章就够了",tag:["笔记"],categories:["Javascript"]},excerpt:"",headers:[{level:2,title:"了解强、弱类型和动态、静态类型语言",slug:"了解强、弱类型和动态、静态类型语言",children:[{level:3,title:"强类型",slug:"强类型",children:[]},{level:3,title:"弱类型",slug:"弱类型",children:[]},{level:3,title:"静态类型",slug:"静态类型",children:[]},{level:3,title:"动态类型",slug:"动态类型",children:[]}]},{level:2,title:"基本数据类型",slug:"基本数据类型",children:[]},{level:2,title:"引用数据类型",slug:"引用数据类型",children:[{level:3,title:"引用类型的检索",slug:"引用类型的检索",children:[]}]},{level:2,title:"拓展：深浅拷贝",slug:"拓展-深浅拷贝",children:[{level:3,title:"手写方法实现深拷贝：",slug:"手写方法实现深拷贝",children:[]}]},{level:2,title:"typeof方法",slug:"typeof方法",children:[]},{level:2,title:"拓展：为什么null返回的是一个object呢？",slug:"拓展-为什么null返回的是一个object呢",children:[]},{level:2,title:"instanceof方法",slug:"instanceof方法",children:[]}],content:"\r\n\r\n# JavaScript 数据类型\r\n值类型（基本类型）有7种，分别是 \r\n- undefined\r\n- null\r\n- Boolean\r\n- String\r\n- Number\r\n- Symbol(ES6新增)\r\n- BigInt(ES10新增)\r\n\r\n引用类型：\r\n- Object\r\n- Array\r\n- function\r\n- Set\r\n- Map\r\n- WeakMap\r\n- WeakSet\r\n- RegExp\r\n- Date\r\n- Math…\r\n# 拓展：JavaScript 是一种动态弱类型语言。\r\n这意味着相同的变量可用作不同的类型：\r\n\r\n```js\r\nvar x;               // x 为 undefined\r\nvar x = 5;           // 现在 x 为数字\r\nvar x = \"John\";      // 现在 x 为字符串\r\n```\r\n## 了解强、弱类型和动态、静态类型语言\r\n### 强类型\r\n\r\n-   语言层面限制函数的实参类型必须与形参类型相同\r\n-   强类型语言中不允许任意的隐式类型转换\r\n\r\n### 弱类型\r\n\r\n-   弱类型语言层面不会限制实参的类型\r\n-   弱类型语言允许任意的数据隐式类型转换\r\n\r\n### 静态类型\r\n\r\n一个变量声明时它的类型就是明确的，声明过后它的类型不再允许修改\r\n\r\n### 动态类型\r\n\r\n- 运行阶段才能够明确变量类型，变量的类型随时可以改变\r\n\r\n- 动态类型语言中的变量没有类型，变量中存放的值才有类型\r\n# 基本数据类型和引用数据类型的存储方式：\r\n## 基本数据类型\r\n基本数据类型存储在**栈内存**，存储的是**值**。\r\n> 原始类型存储的都是值，是没有函数可以调用的。\r\n## 引用数据类型\r\n引用数据类型的值存储在**堆内存**，**地址指针**（该指针指向堆中的该实体）存储在栈内存。\r\n> 之所以引用数据类型存储在堆内存中，是因为引用数据类型占据空间大、占用内存不固定。 如果存储在栈中，将会影响程序运行的性能。\r\n### 引用类型的检索\r\n当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体；所以当我们把对象赋值给另外一个变量的时候，复制的是地址，指向同一块内存空间，当其中一个对象改变时，另一个对象也会变化。上述的赋值行为发生**浅拷贝**：拷贝的是栈中的内存地址，所以如果其中一个对象改变了这个地址里的值，就会影响到另一个对象。\r\n## 拓展：深浅拷贝\r\n在JavaScript中，基本类型 值的复制是直接拷贝一份新的一模一样的数据，这两份数据相互独立，互不影响。而引用类型值的复制则为传递对象的引用，则需要考虑深浅拷贝的问题。\r\n\r\n-   深拷贝：创建一个新的对象，将一个对象从内存中**完整地拷贝**出来一份给该新对象，并从**堆内存中开辟一个全新的空间存放新对象**，且新对象的修改并不会改变原对象。\r\n\r\n```js\r\nlet arr = [1, 2, 3, 4, 5]\r\nlet arr2 =JSON.parse(JSON.stringify(arr))       \r\n// arr.slice()    // [...arr]     //[].concat(arr)    皆可实现数组的深拷贝\r\n// JSON.parse(JSON.stringify(arr))  先将arr变成字符串  然后再将arr变成对象\r\n\r\narr[0] = 0\r\nconsole.log(arr2);      // [1, 2, 3, 4, 5]\r\n```\r\n\r\n-   浅拷贝：创建一个新的对象，来接收你要拷贝的对象的值，复制的是**栈内存中存放的的地址**，所以两者指向的**仍然是堆里的同一个对象**，所以如果其中一个对象改变了栈内存中存放的地址所指向的对象，就会影响到另一个对象。\r\n\r\n```js\r\nlet c = {name:'小明', age: 18}\r\nlet d = c\r\nc.age = 19\r\nconsole.log(d);   // { name: '小明', age: 19 }\r\n```\r\n\r\n### 手写方法实现深拷贝：\r\n\r\n```js\r\nlet person = {\r\n    name: '小明',\r\n    age: 18,\r\n    like: {\r\n        sport: 'running',\r\n        food: 'beef'\r\n    }\r\n}\r\n\r\nfunction deepCopy(obj) {\r\n    let n = obj instanceof Array ? [] : {}     // 判断是否为Array  来判断创建n的数据类型\r\n    for (let item in obj) {\r\n        if (obj.hasOwnProperty(item)) {     // 判断是自己的  还是原型上继承下来的\r\n            n[item] = obj[item] instanceof Object ? deepCopy(obj[item]) : obj[item]    \r\n            // 判断item是否还是对象或数组\r\n        }\r\n    }\r\n    return n\r\n}\r\n\r\nlet newPerson = deepCopy(person)\r\nperson.like.sport = 'swimming'\r\nconsole.log(newPerson);     // { name: '小明', age: 18, like: { sport: 'running', food: 'beef' } }\r\nconsole.log(person);       // { name: '小明', age: 18, like: { sport: 'swimming', food: 'beef' } }\r\n\r\n```\r\n\r\n\r\n\r\n# 判断数据类型的方法\r\n## typeof方法\r\n可以通过typeof检测基本类型和引用类型，不过检测出来的引用类型都是对象：\r\n\r\n```js\r\nconsole.log(\r\n    typeof 123,     //number\r\n    typeof 'abc',   //string\r\n    typeof false,   //boolean\r\n    typeof undefined, //undefined\r\n    typeof null, //object\r\n    typeof function(){console.log('aaa');}, // function\r\n    typeof new Date(), //object\r\n    typeof [1,2,3], //object\r\n    typeof {a:1,b:2,c:3}   //object\r\n);\r\n```\r\n首先 **typeof** 能够正确的判断基本数据类型，但除了null, **typeof null所输出的为object**。\r\n但是对于对象来说，`typeof`也不能正确的判断其类型， 如`typeof`一个函数可以输出 `function`,而除此之外，输出的全是` object`,这种情况下，我们无法准确的知道对象的类型。\r\n## 拓展：为什么null返回的是一个object呢？\r\njs 在底层存储变量的时候，会在变量的机器码的低位1-3位存储其类型信息\r\n-   000：对象\r\n-   010：浮点数\r\n-   100：字符串\r\n-   110：布尔\r\n-   1：整数\r\n在JS的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 `null` 表示为全零，所以typeof错误的将它判断为 `object` 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。\r\n\r\n#### null 和 undefined 的区别：\r\n- `null` 是 javascript 的关键字，表示一个特殊值，常用来描述\"空值\"，typeof 运算返回\"object\"。\r\n- `undefined` 是预定义的全局变量，他的值就是\"未定义\"， typeof 运算返回 \"undefined\"\r\n- `undefined` 这个值表示变量不含有值。可以通过将变量的值设置为 null 来清空变量。\r\n- 相对来说，null更接近其他语言的空、而undefined则是js特有的机制\r\n## instanceof方法\r\n由上可知`typeof`来判断引用类型是不准确的，故想要检测引用类型可以通过 **instanceof**\r\n\r\n    语法：object instanceof constructor（object为实例对象，constructor为构造函数）\r\n    \r\n关于**instanceof** 的实现原理的理解，可参考下面的代码：\r\n\r\n```js\r\nfunction instance_of (left, right){\r\n    let leftVal = left.__proto__\r\n    let rightVal = right.prototype\r\n    while(true){\r\n        if(leftVal === null) return false\r\n        if(leftVal === rightVal)  return true\r\n        leftVal = leftVal.__proto__\r\n    }\r\n}\r\nlet a = [1, 2, 3]\r\nconsole.log(instance_of(a,Array));    // true\r\n```\r\n由此可知`instanceof`是顺着**原型链**去找，直到找到相同的原型对象，返回true，否则为false。\r\n\r\n**instanceof**可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型\r\n\r\n",contentRendered:'<h1 id="javascript-数据类型" tabindex="-1"><a class="header-anchor" href="#javascript-数据类型" aria-hidden="true">#</a> JavaScript 数据类型</h1>\n<p>值类型（基本类型）有7种，分别是</p>\n<ul>\n<li>undefined</li>\n<li>null</li>\n<li>Boolean</li>\n<li>String</li>\n<li>Number</li>\n<li>Symbol(ES6新增)</li>\n<li>BigInt(ES10新增)</li>\n</ul>\n<p>引用类型：</p>\n<ul>\n<li>Object</li>\n<li>Array</li>\n<li>function</li>\n<li>Set</li>\n<li>Map</li>\n<li>WeakMap</li>\n<li>WeakSet</li>\n<li>RegExp</li>\n<li>Date</li>\n<li>Math…</li>\n</ul>\n<h1 id="拓展-javascript-是一种动态弱类型语言。" tabindex="-1"><a class="header-anchor" href="#拓展-javascript-是一种动态弱类型语言。" aria-hidden="true">#</a> 拓展：JavaScript 是一种动态弱类型语言。</h1>\n<p>这意味着相同的变量可用作不同的类型：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">var</span> x<span class="token punctuation">;</span>               <span class="token comment">// x 为 undefined</span>\n<span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>           <span class="token comment">// 现在 x 为数字</span>\n<span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token string">"John"</span><span class="token punctuation">;</span>      <span class="token comment">// 现在 x 为字符串</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="了解强、弱类型和动态、静态类型语言" tabindex="-1"><a class="header-anchor" href="#了解强、弱类型和动态、静态类型语言" aria-hidden="true">#</a> 了解强、弱类型和动态、静态类型语言</h2>\n<h3 id="强类型" tabindex="-1"><a class="header-anchor" href="#强类型" aria-hidden="true">#</a> 强类型</h3>\n<ul>\n<li>语言层面限制函数的实参类型必须与形参类型相同</li>\n<li>强类型语言中不允许任意的隐式类型转换</li>\n</ul>\n<h3 id="弱类型" tabindex="-1"><a class="header-anchor" href="#弱类型" aria-hidden="true">#</a> 弱类型</h3>\n<ul>\n<li>弱类型语言层面不会限制实参的类型</li>\n<li>弱类型语言允许任意的数据隐式类型转换</li>\n</ul>\n<h3 id="静态类型" tabindex="-1"><a class="header-anchor" href="#静态类型" aria-hidden="true">#</a> 静态类型</h3>\n<p>一个变量声明时它的类型就是明确的，声明过后它的类型不再允许修改</p>\n<h3 id="动态类型" tabindex="-1"><a class="header-anchor" href="#动态类型" aria-hidden="true">#</a> 动态类型</h3>\n<ul>\n<li>\n<p>运行阶段才能够明确变量类型，变量的类型随时可以改变</p>\n</li>\n<li>\n<p>动态类型语言中的变量没有类型，变量中存放的值才有类型</p>\n</li>\n</ul>\n<h1 id="基本数据类型和引用数据类型的存储方式" tabindex="-1"><a class="header-anchor" href="#基本数据类型和引用数据类型的存储方式" aria-hidden="true">#</a> 基本数据类型和引用数据类型的存储方式：</h1>\n<h2 id="基本数据类型" tabindex="-1"><a class="header-anchor" href="#基本数据类型" aria-hidden="true">#</a> 基本数据类型</h2>\n<p>基本数据类型存储在<strong>栈内存</strong>，存储的是<strong>值</strong>。</p>\n<blockquote>\n<p>原始类型存储的都是值，是没有函数可以调用的。</p>\n</blockquote>\n<h2 id="引用数据类型" tabindex="-1"><a class="header-anchor" href="#引用数据类型" aria-hidden="true">#</a> 引用数据类型</h2>\n<p>引用数据类型的值存储在<strong>堆内存</strong>，<strong>地址指针</strong>（该指针指向堆中的该实体）存储在栈内存。</p>\n<blockquote>\n<p>之所以引用数据类型存储在堆内存中，是因为引用数据类型占据空间大、占用内存不固定。 如果存储在栈中，将会影响程序运行的性能。</p>\n</blockquote>\n<h3 id="引用类型的检索" tabindex="-1"><a class="header-anchor" href="#引用类型的检索" aria-hidden="true">#</a> 引用类型的检索</h3>\n<p>当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体；所以当我们把对象赋值给另外一个变量的时候，复制的是地址，指向同一块内存空间，当其中一个对象改变时，另一个对象也会变化。上述的赋值行为发生<strong>浅拷贝</strong>：拷贝的是栈中的内存地址，所以如果其中一个对象改变了这个地址里的值，就会影响到另一个对象。</p>\n<h2 id="拓展-深浅拷贝" tabindex="-1"><a class="header-anchor" href="#拓展-深浅拷贝" aria-hidden="true">#</a> 拓展：深浅拷贝</h2>\n<p>在JavaScript中，基本类型 值的复制是直接拷贝一份新的一模一样的数据，这两份数据相互独立，互不影响。而引用类型值的复制则为传递对象的引用，则需要考虑深浅拷贝的问题。</p>\n<ul>\n<li>深拷贝：创建一个新的对象，将一个对象从内存中<strong>完整地拷贝</strong>出来一份给该新对象，并从<strong>堆内存中开辟一个全新的空间存放新对象</strong>，且新对象的修改并不会改变原对象。</li>\n</ul>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>\n<span class="token keyword">let</span> arr2 <span class="token operator">=</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span>       \n<span class="token comment">// arr.slice()    // [...arr]     //[].concat(arr)    皆可实现数组的深拷贝</span>\n<span class="token comment">// JSON.parse(JSON.stringify(arr))  先将arr变成字符串  然后再将arr变成对象</span>\n\narr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr2<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// [1, 2, 3, 4, 5]</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ul>\n<li>浅拷贝：创建一个新的对象，来接收你要拷贝的对象的值，复制的是<strong>栈内存中存放的的地址</strong>，所以两者指向的<strong>仍然是堆里的同一个对象</strong>，所以如果其中一个对象改变了栈内存中存放的地址所指向的对象，就会影响到另一个对象。</li>\n</ul>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">\'小明\'</span><span class="token punctuation">,</span> <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">}</span>\n<span class="token keyword">let</span> d <span class="token operator">=</span> c\nc<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">19</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// { name: \'小明\', age: 19 }</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="手写方法实现深拷贝" tabindex="-1"><a class="header-anchor" href="#手写方法实现深拷贝" aria-hidden="true">#</a> 手写方法实现深拷贝：</h3>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>\n    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">\'小明\'</span><span class="token punctuation">,</span>\n    <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>\n    <span class="token literal-property property">like</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n        <span class="token literal-property property">sport</span><span class="token operator">:</span> <span class="token string">\'running\'</span><span class="token punctuation">,</span>\n        <span class="token literal-property property">food</span><span class="token operator">:</span> <span class="token string">\'beef\'</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">let</span> n <span class="token operator">=</span> obj <span class="token keyword">instanceof</span> <span class="token class-name">Array</span> <span class="token operator">?</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>     <span class="token comment">// 判断是否为Array  来判断创建n的数据类型</span>\n    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> item <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment">// 判断是自己的  还是原型上继承下来的</span>\n            n<span class="token punctuation">[</span>item<span class="token punctuation">]</span> <span class="token operator">=</span> obj<span class="token punctuation">[</span>item<span class="token punctuation">]</span> <span class="token keyword">instanceof</span> <span class="token class-name">Object</span> <span class="token operator">?</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>item<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">:</span> obj<span class="token punctuation">[</span>item<span class="token punctuation">]</span>    \n            <span class="token comment">// 判断item是否还是对象或数组</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">return</span> n\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> newPerson <span class="token operator">=</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span>\nperson<span class="token punctuation">.</span>like<span class="token punctuation">.</span>sport <span class="token operator">=</span> <span class="token string">\'swimming\'</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newPerson<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// { name: \'小明\', age: 18, like: { sport: \'running\', food: \'beef\' } }</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// { name: \'小明\', age: 18, like: { sport: \'swimming\', food: \'beef\' } }</span>\n\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><h1 id="判断数据类型的方法" tabindex="-1"><a class="header-anchor" href="#判断数据类型的方法" aria-hidden="true">#</a> 判断数据类型的方法</h1>\n<h2 id="typeof方法" tabindex="-1"><a class="header-anchor" href="#typeof方法" aria-hidden="true">#</a> typeof方法</h2>\n<p>可以通过typeof检测基本类型和引用类型，不过检测出来的引用类型都是对象：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>\n    <span class="token keyword">typeof</span> <span class="token number">123</span><span class="token punctuation">,</span>     <span class="token comment">//number</span>\n    <span class="token keyword">typeof</span> <span class="token string">\'abc\'</span><span class="token punctuation">,</span>   <span class="token comment">//string</span>\n    <span class="token keyword">typeof</span> <span class="token boolean">false</span><span class="token punctuation">,</span>   <span class="token comment">//boolean</span>\n    <span class="token keyword">typeof</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token comment">//undefined</span>\n    <span class="token keyword">typeof</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token comment">//object</span>\n    <span class="token keyword">typeof</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'aaa\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// function</span>\n    <span class="token keyword">typeof</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">//object</span>\n    <span class="token keyword">typeof</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">//object</span>\n    <span class="token keyword">typeof</span> <span class="token punctuation">{</span><span class="token literal-property property">a</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token literal-property property">b</span><span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token literal-property property">c</span><span class="token operator">:</span><span class="token number">3</span><span class="token punctuation">}</span>   <span class="token comment">//object</span>\n<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>首先 <strong>typeof</strong> 能够正确的判断基本数据类型，但除了null, <strong>typeof null所输出的为object</strong>。\n但是对于对象来说，<code>typeof</code>也不能正确的判断其类型， 如<code>typeof</code>一个函数可以输出 <code>function</code>,而除此之外，输出的全是<code> object</code>,这种情况下，我们无法准确的知道对象的类型。</p>\n<h2 id="拓展-为什么null返回的是一个object呢" tabindex="-1"><a class="header-anchor" href="#拓展-为什么null返回的是一个object呢" aria-hidden="true">#</a> 拓展：为什么null返回的是一个object呢？</h2>\n<p>js 在底层存储变量的时候，会在变量的机器码的低位1-3位存储其类型信息</p>\n<ul>\n<li>000：对象</li>\n<li>010：浮点数</li>\n<li>100：字符串</li>\n<li>110：布尔</li>\n<li>1：整数\n在JS的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 <code>null</code> 表示为全零，所以typeof错误的将它判断为 <code>object</code> 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。</li>\n</ul>\n<h4 id="null-和-undefined-的区别" tabindex="-1"><a class="header-anchor" href="#null-和-undefined-的区别" aria-hidden="true">#</a> null 和 undefined 的区别：</h4>\n<ul>\n<li><code>null</code> 是 javascript 的关键字，表示一个特殊值，常用来描述&quot;空值&quot;，typeof 运算返回&quot;object&quot;。</li>\n<li><code>undefined</code> 是预定义的全局变量，他的值就是&quot;未定义&quot;， typeof 运算返回 &quot;undefined&quot;</li>\n<li><code>undefined</code> 这个值表示变量不含有值。可以通过将变量的值设置为 null 来清空变量。</li>\n<li>相对来说，null更接近其他语言的空、而undefined则是js特有的机制</li>\n</ul>\n<h2 id="instanceof方法" tabindex="-1"><a class="header-anchor" href="#instanceof方法" aria-hidden="true">#</a> instanceof方法</h2>\n<p>由上可知<code>typeof</code>来判断引用类型是不准确的，故想要检测引用类型可以通过 <strong>instanceof</strong></p>\n<pre><code>语法：object instanceof constructor（object为实例对象，constructor为构造函数）\n</code></pre>\n<p>关于<strong>instanceof</strong> 的实现原理的理解，可参考下面的代码：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">instance_of</span> <span class="token punctuation">(</span><span class="token parameter">left<span class="token punctuation">,</span> right</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token keyword">let</span> leftVal <span class="token operator">=</span> left<span class="token punctuation">.</span>__proto__\n    <span class="token keyword">let</span> rightVal <span class="token operator">=</span> right<span class="token punctuation">.</span>prototype\n    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token keyword">if</span><span class="token punctuation">(</span>leftVal <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span>\n        <span class="token keyword">if</span><span class="token punctuation">(</span>leftVal <span class="token operator">===</span> rightVal<span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token boolean">true</span>\n        leftVal <span class="token operator">=</span> leftVal<span class="token punctuation">.</span>__proto__\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">instance_of</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>Array<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// true</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>由此可知<code>instanceof</code>是顺着<strong>原型链</strong>去找，直到找到相同的原型对象，返回true，否则为false。</p>\n<p><strong>instanceof</strong>可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型</p>\n',date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:"/how-to-write-article.html",pathLocale:"/",permalink:null,routeMeta:{},slug:"how-to-write-article",filePath:"C:/Users/mi/Desktop/我的博客/docs/how-to-write-article.md",filePathRelative:"how-to-write-article.md",componentFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/how-to-write-article.html.vue",componentFilePathRelative:"pages/how-to-write-article.html.vue",componentFileChunkName:"v-245bbacd",dataFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/how-to-write-article.html.js",dataFilePathRelative:"pages/how-to-write-article.html.js",dataFileChunkName:"v-245bbacd",htmlFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/dist/how-to-write-article.html",htmlFilePathRelative:"how-to-write-article.html"},{data:{key:"v-3f77dce2",path:"/JS/%E5%8E%9F%E7%94%9FJS.html",title:"原生JavaScript灵魂拷问",lang:"zh-CN",frontmatter:{date:"2022/1/29 19:08",coverUrl:"http://cdn-ali-img-shstaticbz.shanhutech.cn/bizhi/staticwp/202107/30d8b12ad792deb0fb9e802bbc45113e--848443906.jpg",sticky:!0,keyword:"面试,原生JS",description:"原生JavaScript灵魂拷问",title:"原生JavaScript灵魂拷问",tag:["面试","JS"],categories:["Javascript"]},excerpt:"",headers:[{level:2,title:"前言",slug:"前言",children:[]},{level:2,title:"JS类型之问——概念与检测篇",slug:"js类型之问——概念与检测篇",children:[{level:3,title:"1.JS中的数据类型有哪些？",slug:"_1-js中的数据类型有哪些",children:[]},{level:3,title:"2.你真的懂typeof吗？",slug:"_2-你真的懂typeof吗",children:[]},{level:3,title:"3.什么是instanceof？你能模拟实现一个instanceof吗？",slug:"_3-什么是instanceof-你能模拟实现一个instanceof吗",children:[]},{level:3,title:"4.如何区分数组与对象？使用instanceof判断数组可靠吗？",slug:"_4-如何区分数组与对象-使用instanceof判断数组可靠吗",children:[]},{level:3,title:"5.如何判断一个数是否为NaN？",slug:"_5-如何判断一个数是否为nan",children:[]},{level:3,title:"6.如何实现一个功能完善的类型判断函数？",slug:"_6-如何实现一个功能完善的类型判断函数",children:[]}]},{level:2,title:"JS类型之问——类型转换篇",slug:"js类型之问——类型转换篇",children:[{level:3,title:"7.toString 和 valueOf 方法有什么区别？",slug:"_7-tostring-和-valueof-方法有什么区别",children:[]},{level:3,title:"8.你知道对象转换成原始值是什么流程吗 (ToPrimitive)？",slug:"_8-你知道对象转换成原始值是什么流程吗-toprimitive",children:[]},{level:3,title:"9.你能做出下面这个题吗？",slug:"_9-你能做出下面这个题吗",children:[]},{level:3,title:"10.你能理清类型转换吗？",slug:"_10-你能理清类型转换吗",children:[]},{level:3,title:"11.== 的隐式转换规则",slug:"_11-的隐式转换规则",children:[]},{level:3,title:"12.1 + {} 与 {} + 1的输出结果分别是什么？",slug:"_12-1-与-1的输出结果分别是什么",children:[]},{level:3,title:"13.[]与{}的相加的结果是多少？",slug:"_13-与-的相加的结果是多少",children:[]},{level:3,title:"14.你能灵活运用 parseInt 与 parseFloat 吗",slug:"_14-你能灵活运用-parseint-与-parsefloat-吗",children:[]},{level:3,title:"15.如何让 if(a == 1 && a == 2) 条件成立？",slug:"_15-如何让-if-a-1-a-2-条件成立",children:[]}]}],git:{updatedTime:null,contributors:[]}},key:"v-3f77dce2",path:"/JS/%E5%8E%9F%E7%94%9FJS.html",title:"原生JavaScript灵魂拷问",lang:"zh-CN",frontmatter:{date:"2022/1/29 19:08",coverUrl:"http://cdn-ali-img-shstaticbz.shanhutech.cn/bizhi/staticwp/202107/30d8b12ad792deb0fb9e802bbc45113e--848443906.jpg",sticky:!0,keyword:"面试,原生JS",description:"原生JavaScript灵魂拷问",title:"原生JavaScript灵魂拷问",tag:["面试","JS"],categories:["Javascript"]},excerpt:"",headers:[{level:2,title:"前言",slug:"前言",children:[]},{level:2,title:"JS类型之问——概念与检测篇",slug:"js类型之问——概念与检测篇",children:[{level:3,title:"1.JS中的数据类型有哪些？",slug:"_1-js中的数据类型有哪些",children:[]},{level:3,title:"2.你真的懂typeof吗？",slug:"_2-你真的懂typeof吗",children:[]},{level:3,title:"3.什么是instanceof？你能模拟实现一个instanceof吗？",slug:"_3-什么是instanceof-你能模拟实现一个instanceof吗",children:[]},{level:3,title:"4.如何区分数组与对象？使用instanceof判断数组可靠吗？",slug:"_4-如何区分数组与对象-使用instanceof判断数组可靠吗",children:[]},{level:3,title:"5.如何判断一个数是否为NaN？",slug:"_5-如何判断一个数是否为nan",children:[]},{level:3,title:"6.如何实现一个功能完善的类型判断函数？",slug:"_6-如何实现一个功能完善的类型判断函数",children:[]}]},{level:2,title:"JS类型之问——类型转换篇",slug:"js类型之问——类型转换篇",children:[{level:3,title:"7.toString 和 valueOf 方法有什么区别？",slug:"_7-tostring-和-valueof-方法有什么区别",children:[]},{level:3,title:"8.你知道对象转换成原始值是什么流程吗 (ToPrimitive)？",slug:"_8-你知道对象转换成原始值是什么流程吗-toprimitive",children:[]},{level:3,title:"9.你能做出下面这个题吗？",slug:"_9-你能做出下面这个题吗",children:[]},{level:3,title:"10.你能理清类型转换吗？",slug:"_10-你能理清类型转换吗",children:[]},{level:3,title:"11.== 的隐式转换规则",slug:"_11-的隐式转换规则",children:[]},{level:3,title:"12.1 + {} 与 {} + 1的输出结果分别是什么？",slug:"_12-1-与-1的输出结果分别是什么",children:[]},{level:3,title:"13.[]与{}的相加的结果是多少？",slug:"_13-与-的相加的结果是多少",children:[]},{level:3,title:"14.你能灵活运用 parseInt 与 parseFloat 吗",slug:"_14-你能灵活运用-parseint-与-parsefloat-吗",children:[]},{level:3,title:"15.如何让 if(a == 1 && a == 2) 条件成立？",slug:"_15-如何让-if-a-1-a-2-条件成立",children:[]}]}],content:"\r\n\r\n\r\n## 前言\r\n\r\n当下的前端开发，三大框架三分天下，框架的简单、强大让我们欲罢不能，使用原生 `JavaScript` 越来越少。\r\n\r\n但我认为 `JavaScript` 作为每一个前端工程师的立身之本，不止要学会，还要学好、学精，学再多遍都不为过。\r\n\r\n另一方面，前端面试中，越来越重视原生 `JavaScript` 的考察，其所占比例也越来越高。\r\n\r\n我抓取了牛客上今年的线上面试题和面经，大约 `500` 左右道题，原生 `JavaScript` 的难点(闭包，`eventLoop，this`，手撕原生JS)考察的频率非常高。\r\n\r\n> 完整的分析我还正在赶工中，希望大家到时候可以来支持一下。\r\n\r\n因此我决定整理`JavaScript`中容易忽视或者混淆的知识点，写一系列篇文章，以灵魂拷问的方式，系统且完整的带大家遨游原生 `JavaScript` 的世界，希望能给大家带来一些收获。\r\n\r\n## JS类型之问——概念与检测篇\r\n\r\n### 1.JS中的数据类型有哪些？\r\n\r\n1. 基本数据类型：共有7种\r\n\r\n```js\r\nBoolean Number String undefined null Bigint Symbol\r\n复制代码\r\n```\r\n\r\n`Symbol` ： `ES6` 引入的一种新的原始值，表示独一无二的值，主要为了解决属性名冲突问题。\r\n\r\n`Bigint` ：`ES2020` 新增加，是比 `Number` 类型的整数范围更大。\r\n\r\n1. 引用数据类型：1种\r\n\r\n```js\r\nObject对象(包括普通Object、Function、Array、Date、RegExp、Math)\r\n复制代码\r\n```\r\n\r\n### 2.你真的懂typeof吗？\r\n\r\n1. `typeof`的作用？\r\n\r\n   区分数据类型，可以返回7种数据类型：`number、string、boolean、undefined、object、function` ，以及 `ES6` 新增的 `symbol`\r\n\r\n2. `typeof` 能正确区分数据类型吗？\r\n\r\n   不能。对于原始类型，除 `null` 都可以正确判断；对于引用类型，除 `function` 外，都会返回 `\"object\"`\r\n\r\n3. `typeof` 注意事项\r\n\r\n   - `typeof` 返回值为 `string` 格式，注意类似这种考题: `typeof(typeof(undefined)) -> \"string\"`\r\n   - `typeof` 未定义的变量不会报错，返回 `\"undefiend\"`\r\n   - `typeof(null) -> \"object\"`: 遗留已久的 `bug`\r\n   - `typeof`无法区别数组与普通对象: `typeof([]) -> \"object\"`\r\n   - `typeof(NaN) -> \"number\"`\r\n\r\n4. 习题\r\n\r\n```js\r\nconsole.log(typeof(b));\r\nconsole.log(typeof(undefined)); \r\nconsole.log(typeof(NaN)); \r\nconsole.log(typeof(null)); \r\nvar a = '123abc'; \r\nconsole.log(typeof(+a)); \r\nconsole.log(typeof(!!a)); \r\nconsole.log(typeof(a + \"\")); \r\nconsole.log(typeof(typeof(null)));\r\nconsole.log(typeof(typeof({})));\r\n复制代码\r\n```\r\n\r\n**答案**\r\n\r\n```js\r\nundefined // b未定义，返回undefined\r\nundefined\r\nnumber // NaN 为number类型\r\nobject\r\nnumber // +a 类型转换为NaN\r\nboolean\r\nstring\r\nstring // typeof(null) -> \"object\"; typeof(\"object\") -> \"string\"\r\nstring\r\n复制代码\r\n```\r\n\r\n### 3.什么是instanceof？你能模拟实现一个instanceof吗？\r\n\r\n1. `instanceof` 判断对象的原型链上是否存在构造函数的原型。只能判断引用类型。\r\n2. `instanceof` 常用来判断 `A` 是否为 `B` 的实例\r\n\r\n```js\r\n// A是B的实例，返回true，否则返回false\r\n// 判断A的原型链上是否有B的原型\r\nA instaceof B\r\n复制代码\r\n```\r\n\r\n1. 模拟实现 `instanceof`\r\n\r\n思想：沿原型链往上查找\r\n\r\n```js\r\nfunction instance_of(Case, Constructor) {\r\n    // 基本数据类型返回false\r\n    // 兼容一下函数对象\r\n    if ((typeof(Case) != 'object' && typeof(Case) != 'function') || Case == 'null') return false;\r\n    let CaseProto = Object.getPrototypeOf(Case);\r\n    while (true) {\r\n        // 查到原型链顶端，仍未查到，返回false\r\n        if (CaseProto == null) return false;\r\n        // 找到相同的原型\r\n        if (CaseProto === Constructor.prototype) return true;\r\n        CaseProto = Object.getPrototypeOf(CaseProto);\r\n    }\r\n}\r\n复制代码\r\n```\r\n\r\n测试：\r\n\r\n```js\r\nconsole.log(instance_of(Array, Object)) // true\r\nfunction User(name){\r\n    this.name = name;\r\n}\r\nconst user = new User('zc');\r\nconst vipUser = Object.create(user);\r\nconsole.log(instance_of(vipUser, User)) // true\r\n复制代码\r\n```\r\n\r\n### 4.如何区分数组与对象？使用instanceof判断数组可靠吗？\r\n\r\n1. `ES6` 提供的新方法 `Array.isArray()`\r\n2. 如果不存在`Array.isArray()`呢？可以借助`Object.prototype.toString.call()` 进行判断，此方式兼容性最好\r\n\r\n```js\r\nif (!Array.isArray) {\r\n    Array.isArray = function(o) {\r\n        return typeof(o) === 'object' \r\n               && Object.prototype.toString.call(o) === '[object Array]';\r\n    }\r\n}\r\n复制代码\r\n```\r\n\r\n1. `instanceof` 判断\r\n\r\n判断方式\r\n\r\n```js\r\n// 如果为true，则arr为数组\r\narr instanceof Array\r\n复制代码\r\n```\r\n\r\n`instanceof` 判断数组类型如此之简单，为何不推荐使用那？\r\n\r\n`instanceof` 操作符的问题在于，如果网页中存在多个 `iframe` ，那便会存在多个 `Array` 构造函数，此时判断是否是数组会存在问题。\r\n\r\n更详细的内容可以参考博文：[JavaScript为啥不用instanceof检测数组 ](https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fweixin_42467709%2Farticle%2Fdetails%2F105302852)\r\n\r\n### 5.如何判断一个数是否为NaN？\r\n\r\n`NaN` 有个非常特殊的特性， `NaN` 与任何值都不相等，包括它自身\r\n\r\n```js\r\nNaN === NaN // false\r\nNaN == NaN // false\r\n复制代码\r\n```\r\n\r\n鉴于这个独特的特性，可以手撕一个比较简单的判断函数\r\n\r\n```js\r\nfunction isNaN(x) {\r\n    return x != x;\r\n}\r\n复制代码\r\n```\r\n\r\n- 全局函数 `isNaN` 方法：不推荐使用。`MDN` 对它的介绍是：`isNaN` 函数内包含一些非常有趣的规则。\r\n\r\n但为了避免一些面试官出一些冷门题目，咱们来稍微了解一下 `isNaN` 的有趣机制：会先判断参数是不是 `Number` 类型，如果不是 `Number` 类型会尝试将这个参数转换为 `Number` 类型，之后再去判断是不是 `NaN` 。\r\n\r\n举个例子：\r\n\r\n```js\r\n// 为什么对象会带来三种不同的结果\r\n// 是不是很有趣\r\n// 具体原因可以参考类型转换篇\r\nconsole.log(isNaN([])) // false\r\nconsole.log(isNaN([1])) // false\r\nconsole.log(isNaN([1, 2])) // true \r\nconsole.log(isNaN(null)) // false\r\nconsole.log(isNaN(undefined)) // true\r\n复制代码\r\n```\r\n\r\n`isNaN` 的结果很大程度上取决于 `Number()` 类型转换的结果，关于 `Number` 的转换结果，后面会专门有一部分来介绍。\r\n\r\n- `Number.isNaN` (推荐使用)\r\n\r\n与 `isNaN()` 相比，`Number.isNaN()` 不会自行将参数转换成数字，只有在参数是值为 ` NaN` 的数字时，才会返回 `true`。\r\n\r\n### 6.如何实现一个功能完善的类型判断函数？\r\n\r\n`Object.prototype.toString.call([value])` ，可以精准判断数据类型，因此可以根据这个原理封装一个自己的 `type` 方法。\r\n\r\n```js\r\ntoString.call(()=>{})       // [object Function]\r\ntoString.call({})           // [object Object]\r\ntoString.call([])           // [object Array]\r\ntoString.call('')           // [object String]\r\ntoString.call(22)           // [object Number]\r\ntoString.call(undefined)    // [object undefined]\r\ntoString.call(null)         // [object null]\r\ntoString.call(new Date)     // [object Date]\r\ntoString.call(Math)         // [object Math]\r\ntoString.call(window)       // [object Window]\r\n复制代码\r\n```\r\n\r\n## JS类型之问——类型转换篇\r\n\r\n### 7.toString 和 valueOf 方法有什么区别？\r\n\r\n1. 基础：这两个方法属于 `Object` 对象，是为了解决 `JavaScript` 值运算与显示的问题。为了更适合自身功能，很多 `JavaScript` 内置对象都重写了这两个方法。\r\n2. `toString()`: 返回当前对象的字符串形式；`valueOf()` : 返回该对象的原始值\r\n3. 各个类型下两个方法返回值情况对比\r\n\r\n| 类型         | valueOf           | toString                |\r\n| ------------ | ----------------- | ----------------------- |\r\n| Array[1,2,3] | 数组本身[1, 2, 3] | 1,2,3                   |\r\n| Object       | 对象本身          | [object Object]         |\r\n| Boolean类型  | Boolean值         | \"true\"或\"false\"         |\r\n| Function     | 函数本身          | function fnName(){code} |\r\n| Number       | 数值              | 数值的字符换表示        |\r\n| Date         | 毫米格式时间戳    | GMT格式时间字符串       |\r\n\r\n1. 调用优先级\r\n\r\n   **隐式转换时会自动调用 `toString` 和 `valueOf` 方法**，两者优先级如下：\r\n\r\n   - 强制转化为字符串类型时，优先调用 `toString` 方法\r\n   - 强制转换为数值类型时，优先调用 `valueOf` 方法\r\n   - 使用运算符操作符情况下，`valueOf` 优先级高于 `toStirng`\r\n   - 对象的类型转换见下一问。\r\n\r\n### 8.你知道对象转换成原始值是什么流程吗 (ToPrimitive)？\r\n\r\n对象转换成原始类型，会调用内置的 `[ToPrimitive]`函数\r\n\r\n(参考博客: [从ECMA规范彻底理解 JavaScript 类型转换](https://juejin.cn/post/6988387082536222734#heading-8))\r\n\r\n- ```\r\n  ToPrimitive\r\n  ```\r\n\r\n   方法接受两个参数，一个是输入的值 \r\n\r\n  ```\r\n  input\r\n  ```\r\n\r\n  ，一个是期望转换的类型 \r\n\r\n  ```\r\n  PreferredType\r\n  ```\r\n\r\n  1. 如果未传入 `PreferredType` 参数，让 `hint` 等于 `'default'`，后面会将 `hint` 修改为 `'number'`\r\n  2. 如果 `PreferredType` 是 `hint String`，让 `hint` 等于 `'string'`\r\n  3. 如果 `PreferredType` 是 `hint Number`，让 `hint` 等于 `'number'`\r\n  4. 返回 `OrdinaryToPrimitive(input, hint)`\r\n\r\n- ```\r\n  OrdinaryToPrimitive(input, hint)\r\n  ```\r\n\r\n  1. 如果 `hint` 是 `'string'`，那么就将 `methodNames` 设置为 `toString、valueOf`\r\n  2. 如果 `hint` 是 `'number'`，那么就将 `methodNames` 设置为 `valueOf、toString`\r\n\r\n> `methodName` 存储的就是当前 `preferredType` 下的调用优先级，如果全部调用完毕仍然未转化为原始值，会发生报错。\r\n\r\n### 9.你能做出下面这个题吗？\r\n\r\n```js\r\nconst a = {x:1};\r\nconst b = {x:2};\r\nconst obj = {};\r\nobj[a] = 100;\r\nobj[b] = 200;\r\n\r\nconsole.log(obj[a]);\r\nconsole.log(obj[b]);\r\n复制代码\r\n```\r\n\r\n有了第七问和第八问的知识，这个题目就不难了。 `JavaScript` 对象的键必须是字符串，因此分别需要将对象 `a` 和 `b` 转换为 `string` 类型。具体转换流程：\r\n\r\n```js\r\n// 1.执行ToPrimitive\r\n// hint 为 string\r\nToPrimitive(a, 'hint String')\r\n// 2.执行OrdinaryToPrimitive\r\nOrdinaryToPrimitive(a, 'string')\r\n// 3.返回methodNames\r\nmethodNames = ['toString', 'valueOf']\r\n// 4.调用methodNames里方法\r\n// 调用toString\r\na.toString() // 返回[object Object]\r\n复制代码\r\n```\r\n\r\n对象 `a` 和 `b` 转换后的结果都是 `[object Object]`，`obj` 对象上只添加了一个属性 `[object Object]`。\r\n\r\n**答案**\r\n\r\n```js\r\n200\r\n200\r\n复制代码\r\n```\r\n\r\n### 10.你能理清类型转换吗？\r\n\r\n首先需要知道：在`JavaScript`中，只有**三种类型**的转换\r\n\r\n- 转换为`Number`类型: `Number() / parseFloat() / parseInt()`\r\n- 转化为`String`类型:` String() / toString()`\r\n- 转化为`Boolean`类型: `Boolean()`\r\n\r\n因此遇到类型转换问题，只需要弄清楚在**什么场景**之下转换成**那种类型**即可。\r\n\r\n#### 转换为boolean\r\n\r\n- 显式：`Boolean` 方法可以显式将值转换为布尔类型\r\n- 隐式：通常在逻辑判断或者有逻辑运算符时触发（`|| && !`）\r\n\r\n```js\r\nBoolean(1)   // 显式类型转换\r\nif (1) {}    // 逻辑判断类型触发隐式转换\r\n!!1          // 逻辑运算符触发隐式转换\r\n1 || 'hello' // 逻辑运算符触发隐式转换\r\n复制代码\r\n```\r\n\r\n`boolean` 类型只有 `true` 和 `false` 两种值。\r\n\r\n除值 **0,-0,null,NaN,undefined,或空字符串（\"\"）** 为 `false` 外，其余全为 `true`\r\n\r\n#### 转化为string\r\n\r\n- 显式：`String` 方法可以显式将值转换为字符串\r\n- 隐式：`+` 运算符有一侧操作数为 `string` 类型时\r\n\r\n转化为 `string` 类型的本质：**需要转换为string的部分调用自身的toString方法(null/undefined返回字符串格式的null和undefined)**\r\n\r\n> 当被转换值为对象时，相当于执行 `ToPrimitive(input, 'hint String')`\r\n\r\n```js\r\nString([1,2,3]) // 1,2,3\r\nString({x:1}) // [object Object]\r\n\r\n1 + '1' // 11\r\n1 + {} // 1[object Object]\r\n复制代码\r\n```\r\n\r\n#### 转化为number\r\n\r\n- 显式：`Number` 方法可以显式将值转化为数字类型\r\n\r\n`Number` 的具体规则，`ES5` 规范中给了一个[对应的结果表](https://link.juejin.cn?target=http%3A%2F%2Fes5.github.io%2F%23x9.3)\r\n\r\n| 类型      | 结果                                        |\r\n| --------- | ------------------------------------------- |\r\n| undefined | NaN                                         |\r\n| null      | +0                                          |\r\n| Boolean   | NaN                                         |\r\n| undefined | 参数为true返回1；false返回+0                |\r\n| Number    | 返回与之相等的值                            |\r\n| String    | 有些复杂，举例说明                          |\r\n| Object    | 先执行ToPrimitive方法，在执行Number类型转换 |\r\n\r\n1. `String`: 空字符串返回 `0`，出现任何一个非有效数字字符，返回 `NaN`\r\n\r\n```js\r\nconsole.log(Number(\"1 3\")) // NaN\r\nconsole.log(Number(\"abc\")) // NaN\r\nconsole.log(Number(\"1a\")) // NaN\r\nconsole.log(Number(\"0x11\")) // 17\r\nconsole.log(Number(\"123\")) // 123\r\nconsole.log(Number(\"-123\")) // -123\r\nconsole.log(Number(\"1.2\")) // 1.2\r\n复制代码\r\n```\r\n\r\n- 隐式：\r\n\r\n  ```\r\n  number\r\n  ```\r\n\r\n  的隐式类型转换比较复杂，对需要隐式转换的部分执行 \r\n\r\n  ```\r\n  Number\r\n  ```\r\n\r\n  ：\r\n\r\n  - 比较操作(`<, >, <=, >=`)\r\n  - 按位操作(`| & ^ ~`)\r\n  - 算数操作(`+ - * / %`) 注意：**+的操作数存在字符串时，为string转换**\r\n  - 一元 `+-` 操作\r\n\r\n### 11.== 的隐式转换规则\r\n\r\n1. `==`: 只需要值相等，无需类型相等；`null, undefined` 在 `==` 下互相等且自身等\r\n2. `==` 的转换规则:\r\n\r\n| 被比较数B |                     |                            |                                  |                               |        |\r\n| --------- | ------------------- | -------------------------- | -------------------------------- | ----------------------------- | ------ |\r\n|           |                     | Number                     | String                           | Boolean                       | Object |\r\n| 比较数A   |                     |                            |                                  |                               |        |\r\n| Number    | A == B              | A == ToNumber(B)           | A == ToNumber(B)                 | A == ToPrimitive(B)           |        |\r\n| String    | ToNumber(A) == B    | A == B                     | ToNumber(A) == ToNumber(B)       | ToPrimitive(B) == A           |        |\r\n| Boolean   | ToNumber(A) == B    | ToNumber(A) == ToNumber(B) | ToNumber(A) == ToNumber(B)       | ToNumber(A) == ToPrimitive(B) |        |\r\n| Object    | ToPrimitive(A) == B | ToPrimitive(A) == B        | ToPrimitive(A) == ToPrimitive(B) | A === B                       |        |\r\n\r\n在上面的表格中，`ToNumber(A)` 尝试在比较前将参数 `A` 转换为数字。`ToPrimitive(A)` 将参数 `A` 转换为原始值( `Primitive` )。\r\n\r\n### 12.`1 + {}` 与 `{} + 1`的输出结果分别是什么？\r\n\r\n通过上面的学习，当对象与其他元素相加时，对象会调用 `toPrimitive` 转化为原始值：\r\n\r\n1. 执行 `toPrimitive`，未传入 `PreferredType`，`methodNames` 为 `[valueOf, toString]`\r\n2. 执行 `({}).valueOf`，返回对象本身 `{}`，不是原始值\r\n3. 继续执行 `({}).toString()`，返回 `\"[object Object]\"`，返回结果为原始值，转换结束\r\n\r\n此时 `1 + {}`，右侧为 `string` 类型，将 `1` 进行 `ToString()` 转化为 `\"1\"` ，最后字符串连接，结果为 `\"1[object Object]\"`\r\n\r\n**注意**： `{} + 1` 输出的结果会和 `1 + {}` 一样吗？\r\n\r\n```\r\n{}` 在 `JavaScript` 中，不止可以作为对象定义，也可以作为代码块的定义。`js` 引擎会把 `{} + 1` 解析成**1个代码块和1个+1**，最终输出结果为 `1\r\n```\r\n\r\n**答案**\r\n\r\n```js\r\n1[object Object]\r\n1\r\n复制代码\r\n```\r\n\r\n### 13.[]与{}的相加的结果是多少？\r\n\r\n#### `[] + {}`\r\n\r\n数组是特殊的对象，需要调用 `toPrimitive`，转换为原始值\r\n\r\n- 执行 `toPrimitive`，未传入 `PreferredType`，`methodNames` 为 `[valueOf, toString]`\r\n- 执行 `[].valueOf`，返回数组本身\r\n- 执行 `[].toString`，返回空字符串 `''`\r\n\r\n空对象不做赘述。\r\n\r\n**答案**\r\n\r\n```js\r\n\"[object Object]\"\r\n复制代码\r\n```\r\n\r\n#### `[] + []`\r\n\r\n类似 `1` 两个空数组都执行 `toPrimitive`，返回两个空字符串。\r\n\r\n**答案**\r\n\r\n```js\r\n\"\"\r\n复制代码\r\n```\r\n\r\n#### `{} + []`\r\n\r\n类似于 `{} + 1`，`{} + []` 相当于 `{}; + []`，一元 `+` 强制将 `\"\"` 隐式转换为`0`，最终结果为`0`\r\n\r\n**答案**\r\n\r\n```js\r\n0\r\n复制代码\r\n```\r\n\r\n#### `{} + {}`\r\n\r\n对于这个题，我先公布一下答案，之后说一下我的疑问。\r\n\r\n**答案**\r\n\r\n```js\r\n[object Object][object Object]\r\n复制代码\r\n```\r\n\r\n**疑问**\r\n\r\n为什么 `JavaScript` 引擎没有将前面的 `{}` 解释成代码块？\r\n\r\n> 友情提示：由于 `{}` 可以解释为代码块的形式，有些需要注意的地方，举个栗子:\r\n>\r\n> - 空对象调用方法时：`{}.toString()` 会报错\r\n> - 箭头函数返回对象时：`let getTempItem = id => { id: id, name: \"Temp\" }` 会报错\r\n\r\n### 14.你能灵活运用 parseInt 与 parseFloat 吗\r\n\r\n1. `parseInt`：从数字类开始看，看到非数字类为止，返回原来的数。(小数点也属于非有效数字)\r\n\r\n```js\r\nparseInt('123x') -> 123\r\nparseInt('-023x') -> -23\r\nparseInt('1.1') -> 1\r\nparseInt('-abc') -> NaN\r\nparseInt('x123') -> NaN\r\n复制代码\r\n```\r\n\r\n1. `parseInt(string, radix)` 还有第二个参数 `radix` 表示要解析数字的基数，取值为 `2~36` (默认值为`10`)\r\n2. `parseFloat` 与 `parseInt` 类似，只不过它返回浮点数。从数字类开始看，看到除了第一个点以外的非数字类为截止，返回前面的数。\r\n\r\n#### 网红题：['1','2','3'].map(parseInt)\r\n\r\n这个网红题考察的就是 `parseInt` 有两个参数。 `map` 传入的函数可执行三个参数：\r\n\r\n```js\r\n// ele   遍历的元素\r\n// index 遍历的元素索引\r\n// arr   数组\r\narr.map(function(ele, index, arr){})\r\n复制代码\r\n```\r\n\r\n['1','2','3'].map(parseInt)相当于执行了以下三次过程：\r\n\r\n```js\r\nparseInt('1', 0, ['1','2','3'])\r\nparseInt('2', 1, ['1','2','3'])\r\nparseInt('3', 2, ['1','2','3'])\r\n复制代码\r\n```\r\n\r\n- `parseInt('1', 0, ['1','2','3'])`: radix为0时，默认取10，最后返回1\r\n- `parseInt('2', 1, ['1','2','3'])`: radix取值为2~36，返回NaN\r\n- `parseInt('3', 2, ['1','2','3'])`: radix取值为2，二进制只包括0，1，返回NaN\r\n\r\n### 15.如何让 if(a == 1 && a == 2) 条件成立？\r\n\r\n`valueOf` 的应用\r\n\r\n```js\r\nvar a = {\r\n    value: 0,\r\n    valueOf: function() {\r\n        this.value++;\r\n        return this.value;\r\n    }\r\n};\r\nconsole.log(a == 1 && a == 2); //true\r\n```\r\n\r\n关于本文\r\n\r\nhttps://juejin.cn/post/7021750693262262308",contentRendered:'<h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言" aria-hidden="true">#</a> 前言</h2>\n<p>当下的前端开发，三大框架三分天下，框架的简单、强大让我们欲罢不能，使用原生 <code>JavaScript</code> 越来越少。</p>\n<p>但我认为 <code>JavaScript</code> 作为每一个前端工程师的立身之本，不止要学会，还要学好、学精，学再多遍都不为过。</p>\n<p>另一方面，前端面试中，越来越重视原生 <code>JavaScript</code> 的考察，其所占比例也越来越高。</p>\n<p>我抓取了牛客上今年的线上面试题和面经，大约 <code>500</code> 左右道题，原生 <code>JavaScript</code> 的难点(闭包，<code>eventLoop，this</code>，手撕原生JS)考察的频率非常高。</p>\n<blockquote>\n<p>完整的分析我还正在赶工中，希望大家到时候可以来支持一下。</p>\n</blockquote>\n<p>因此我决定整理<code>JavaScript</code>中容易忽视或者混淆的知识点，写一系列篇文章，以灵魂拷问的方式，系统且完整的带大家遨游原生 <code>JavaScript</code> 的世界，希望能给大家带来一些收获。</p>\n<h2 id="js类型之问——概念与检测篇" tabindex="-1"><a class="header-anchor" href="#js类型之问——概念与检测篇" aria-hidden="true">#</a> JS类型之问——概念与检测篇</h2>\n<h3 id="_1-js中的数据类型有哪些" tabindex="-1"><a class="header-anchor" href="#_1-js中的数据类型有哪些" aria-hidden="true">#</a> 1.JS中的数据类型有哪些？</h3>\n<ol>\n<li>基本数据类型：共有7种</li>\n</ol>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code>Boolean Number String <span class="token keyword">undefined</span> <span class="token keyword">null</span> Bigint Symbol\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><code>Symbol</code> ： <code>ES6</code> 引入的一种新的原始值，表示独一无二的值，主要为了解决属性名冲突问题。</p>\n<p><code>Bigint</code> ：<code>ES2020</code> 新增加，是比 <code>Number</code> 类型的整数范围更大。</p>\n<ol>\n<li>引用数据类型：1种</li>\n</ol>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token function">Object对象</span><span class="token punctuation">(</span>包括普通Object、Function、Array、Date、RegExp、Math<span class="token punctuation">)</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="_2-你真的懂typeof吗" tabindex="-1"><a class="header-anchor" href="#_2-你真的懂typeof吗" aria-hidden="true">#</a> 2.你真的懂typeof吗？</h3>\n<ol>\n<li>\n<p><code>typeof</code>的作用？</p>\n<p>区分数据类型，可以返回7种数据类型：<code>number、string、boolean、undefined、object、function</code> ，以及 <code>ES6</code> 新增的 <code>symbol</code></p>\n</li>\n<li>\n<p><code>typeof</code> 能正确区分数据类型吗？</p>\n<p>不能。对于原始类型，除 <code>null</code> 都可以正确判断；对于引用类型，除 <code>function</code> 外，都会返回 <code>&quot;object&quot;</code></p>\n</li>\n<li>\n<p><code>typeof</code> 注意事项</p>\n<ul>\n<li><code>typeof</code> 返回值为 <code>string</code> 格式，注意类似这种考题: <code>typeof(typeof(undefined)) -&gt; &quot;string&quot;</code></li>\n<li><code>typeof</code> 未定义的变量不会报错，返回 <code>&quot;undefiend&quot;</code></li>\n<li><code>typeof(null) -&gt; &quot;object&quot;</code>: 遗留已久的 <code>bug</code></li>\n<li><code>typeof</code>无法区别数组与普通对象: <code>typeof([]) -&gt; &quot;object&quot;</code></li>\n<li><code>typeof(NaN) -&gt; &quot;number&quot;</code></li>\n</ul>\n</li>\n<li>\n<p>习题</p>\n</li>\n</ol>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> \nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> \nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> \n<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">\'123abc\'</span><span class="token punctuation">;</span> \nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token operator">+</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> \nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> \nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span>a <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> \nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p><strong>答案</strong></p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">undefined</span> <span class="token comment">// b未定义，返回undefined</span>\n<span class="token keyword">undefined</span>\nnumber <span class="token comment">// NaN 为number类型</span>\nobject\nnumber <span class="token comment">// +a 类型转换为NaN</span>\nboolean\nstring\nstring <span class="token comment">// typeof(null) -> "object"; typeof("object") -> "string"</span>\nstring\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h3 id="_3-什么是instanceof-你能模拟实现一个instanceof吗" tabindex="-1"><a class="header-anchor" href="#_3-什么是instanceof-你能模拟实现一个instanceof吗" aria-hidden="true">#</a> 3.什么是instanceof？你能模拟实现一个instanceof吗？</h3>\n<ol>\n<li><code>instanceof</code> 判断对象的原型链上是否存在构造函数的原型。只能判断引用类型。</li>\n<li><code>instanceof</code> 常用来判断 <code>A</code> 是否为 <code>B</code> 的实例</li>\n</ol>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token comment">// A是B的实例，返回true，否则返回false</span>\n<span class="token comment">// 判断A的原型链上是否有B的原型</span>\n<span class="token constant">A</span> instaceof <span class="token constant">B</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ol>\n<li>模拟实现 <code>instanceof</code></li>\n</ol>\n<p>思想：沿原型链往上查找</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">instance_of</span><span class="token punctuation">(</span><span class="token parameter">Case<span class="token punctuation">,</span> Constructor</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 基本数据类型返回false</span>\n    <span class="token comment">// 兼容一下函数对象</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span>Case<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token string">\'object\'</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span><span class="token punctuation">(</span>Case<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token string">\'function\'</span><span class="token punctuation">)</span> <span class="token operator">||</span> Case <span class="token operator">==</span> <span class="token string">\'null\'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n    <span class="token keyword">let</span> CaseProto <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>Case<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 查到原型链顶端，仍未查到，返回false</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>CaseProto <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n        <span class="token comment">// 找到相同的原型</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>CaseProto <span class="token operator">===</span> <span class="token class-name">Constructor</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n        CaseProto <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>CaseProto<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>测试：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">instance_of</span><span class="token punctuation">(</span>Array<span class="token punctuation">,</span> Object<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true</span>\n<span class="token keyword">function</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">\'zc\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> vipUser <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">instance_of</span><span class="token punctuation">(</span>vipUser<span class="token punctuation">,</span> User<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="_4-如何区分数组与对象-使用instanceof判断数组可靠吗" tabindex="-1"><a class="header-anchor" href="#_4-如何区分数组与对象-使用instanceof判断数组可靠吗" aria-hidden="true">#</a> 4.如何区分数组与对象？使用instanceof判断数组可靠吗？</h3>\n<ol>\n<li><code>ES6</code> 提供的新方法 <code>Array.isArray()</code></li>\n<li>如果不存在<code>Array.isArray()</code>呢？可以借助<code>Object.prototype.toString.call()</code> 进行判断，此方式兼容性最好</li>\n</ol>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Array<span class="token punctuation">.</span>isArray<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    Array<span class="token punctuation">.</span><span class="token function-variable function">isArray</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token keyword">typeof</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">\'object\'</span> \n               <span class="token operator">&amp;&amp;</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">\'[object Array]\'</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ol>\n<li><code>instanceof</code> 判断</li>\n</ol>\n<p>判断方式</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token comment">// 如果为true，则arr为数组</span>\narr <span class="token keyword">instanceof</span> <span class="token class-name">Array</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><code>instanceof</code> 判断数组类型如此之简单，为何不推荐使用那？</p>\n<p><code>instanceof</code> 操作符的问题在于，如果网页中存在多个 <code>iframe</code> ，那便会存在多个 <code>Array</code> 构造函数，此时判断是否是数组会存在问题。</p>\n<p>更详细的内容可以参考博文：<a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fweixin_42467709%2Farticle%2Fdetails%2F105302852" target="_blank" rel="noopener noreferrer">JavaScript为啥不用instanceof检测数组 <ExternalLinkIcon/></a></p>\n<h3 id="_5-如何判断一个数是否为nan" tabindex="-1"><a class="header-anchor" href="#_5-如何判断一个数是否为nan" aria-hidden="true">#</a> 5.如何判断一个数是否为NaN？</h3>\n<p><code>NaN</code> 有个非常特殊的特性， <code>NaN</code> 与任何值都不相等，包括它自身</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token number">NaN</span> <span class="token operator">===</span> <span class="token number">NaN</span> <span class="token comment">// false</span>\n<span class="token number">NaN</span> <span class="token operator">==</span> <span class="token number">NaN</span> <span class="token comment">// false</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>鉴于这个独特的特性，可以手撕一个比较简单的判断函数</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> x <span class="token operator">!=</span> x<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul>\n<li>全局函数 <code>isNaN</code> 方法：不推荐使用。<code>MDN</code> 对它的介绍是：<code>isNaN</code> 函数内包含一些非常有趣的规则。</li>\n</ul>\n<p>但为了避免一些面试官出一些冷门题目，咱们来稍微了解一下 <code>isNaN</code> 的有趣机制：会先判断参数是不是 <code>Number</code> 类型，如果不是 <code>Number</code> 类型会尝试将这个参数转换为 <code>Number</code> 类型，之后再去判断是不是 <code>NaN</code> 。</p>\n<p>举个例子：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token comment">// 为什么对象会带来三种不同的结果</span>\n<span class="token comment">// 是不是很有趣</span>\n<span class="token comment">// 具体原因可以参考类型转换篇</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// false</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// false</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true </span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// false</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><code>isNaN</code> 的结果很大程度上取决于 <code>Number()</code> 类型转换的结果，关于 <code>Number</code> 的转换结果，后面会专门有一部分来介绍。</p>\n<ul>\n<li><code>Number.isNaN</code> (推荐使用)</li>\n</ul>\n<p>与 <code>isNaN()</code> 相比，<code>Number.isNaN()</code> 不会自行将参数转换成数字，只有在参数是值为 <code> NaN</code> 的数字时，才会返回 <code>true</code>。</p>\n<h3 id="_6-如何实现一个功能完善的类型判断函数" tabindex="-1"><a class="header-anchor" href="#_6-如何实现一个功能完善的类型判断函数" aria-hidden="true">#</a> 6.如何实现一个功能完善的类型判断函数？</h3>\n<p><code>Object.prototype.toString.call([value])</code> ，可以精准判断数据类型，因此可以根据这个原理封装一个自己的 <code>type</code> 方法。</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>       <span class="token comment">// [object Function]</span>\n<span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>           <span class="token comment">// [object Object]</span>\n<span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>           <span class="token comment">// [object Array]</span>\n<span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">\'\'</span><span class="token punctuation">)</span>           <span class="token comment">// [object String]</span>\n<span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token number">22</span><span class="token punctuation">)</span>           <span class="token comment">// [object Number]</span>\n<span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">)</span>    <span class="token comment">// [object undefined]</span>\n<span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>         <span class="token comment">// [object null]</span>\n<span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">)</span>     <span class="token comment">// [object Date]</span>\n<span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>Math<span class="token punctuation">)</span>         <span class="token comment">// [object Math]</span>\n<span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span>       <span class="token comment">// [object Window]</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="js类型之问——类型转换篇" tabindex="-1"><a class="header-anchor" href="#js类型之问——类型转换篇" aria-hidden="true">#</a> JS类型之问——类型转换篇</h2>\n<h3 id="_7-tostring-和-valueof-方法有什么区别" tabindex="-1"><a class="header-anchor" href="#_7-tostring-和-valueof-方法有什么区别" aria-hidden="true">#</a> 7.toString 和 valueOf 方法有什么区别？</h3>\n<ol>\n<li>基础：这两个方法属于 <code>Object</code> 对象，是为了解决 <code>JavaScript</code> 值运算与显示的问题。为了更适合自身功能，很多 <code>JavaScript</code> 内置对象都重写了这两个方法。</li>\n<li><code>toString()</code>: 返回当前对象的字符串形式；<code>valueOf()</code> : 返回该对象的原始值</li>\n<li>各个类型下两个方法返回值情况对比</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>valueOf</th>\n<th>toString</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Array[1,2,3]</td>\n<td>数组本身[1, 2, 3]</td>\n<td>1,2,3</td>\n</tr>\n<tr>\n<td>Object</td>\n<td>对象本身</td>\n<td>[object Object]</td>\n</tr>\n<tr>\n<td>Boolean类型</td>\n<td>Boolean值</td>\n<td>&quot;true&quot;或&quot;false&quot;</td>\n</tr>\n<tr>\n<td>Function</td>\n<td>函数本身</td>\n<td>function fnName(){code}</td>\n</tr>\n<tr>\n<td>Number</td>\n<td>数值</td>\n<td>数值的字符换表示</td>\n</tr>\n<tr>\n<td>Date</td>\n<td>毫米格式时间戳</td>\n<td>GMT格式时间字符串</td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li>\n<p>调用优先级</p>\n<p><strong>隐式转换时会自动调用 <code>toString</code> 和 <code>valueOf</code> 方法</strong>，两者优先级如下：</p>\n<ul>\n<li>强制转化为字符串类型时，优先调用 <code>toString</code> 方法</li>\n<li>强制转换为数值类型时，优先调用 <code>valueOf</code> 方法</li>\n<li>使用运算符操作符情况下，<code>valueOf</code> 优先级高于 <code>toStirng</code></li>\n<li>对象的类型转换见下一问。</li>\n</ul>\n</li>\n</ol>\n<h3 id="_8-你知道对象转换成原始值是什么流程吗-toprimitive" tabindex="-1"><a class="header-anchor" href="#_8-你知道对象转换成原始值是什么流程吗-toprimitive" aria-hidden="true">#</a> 8.你知道对象转换成原始值是什么流程吗 (ToPrimitive)？</h3>\n<p>对象转换成原始类型，会调用内置的 <code>[ToPrimitive]</code>函数</p>\n<p>(参考博客: <a href="https://juejin.cn/post/6988387082536222734#heading-8" target="_blank" rel="noopener noreferrer">从ECMA规范彻底理解 JavaScript 类型转换<ExternalLinkIcon/></a>)</p>\n<ul>\n<li>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>ToPrimitive\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>方法接受两个参数，一个是输入的值</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>input\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>，一个是期望转换的类型</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>PreferredType\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><ol>\n<li>如果未传入 <code>PreferredType</code> 参数，让 <code>hint</code> 等于 <code>\'default\'</code>，后面会将 <code>hint</code> 修改为 <code>\'number\'</code></li>\n<li>如果 <code>PreferredType</code> 是 <code>hint String</code>，让 <code>hint</code> 等于 <code>\'string\'</code></li>\n<li>如果 <code>PreferredType</code> 是 <code>hint Number</code>，让 <code>hint</code> 等于 <code>\'number\'</code></li>\n<li>返回 <code>OrdinaryToPrimitive(input, hint)</code></li>\n</ol>\n</li>\n<li>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>OrdinaryToPrimitive(input, hint)\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><ol>\n<li>如果 <code>hint</code> 是 <code>\'string\'</code>，那么就将 <code>methodNames</code> 设置为 <code>toString、valueOf</code></li>\n<li>如果 <code>hint</code> 是 <code>\'number\'</code>，那么就将 <code>methodNames</code> 设置为 <code>valueOf、toString</code></li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p><code>methodName</code> 存储的就是当前 <code>preferredType</code> 下的调用优先级，如果全部调用完毕仍然未转化为原始值，会发生报错。</p>\n</blockquote>\n<h3 id="_9-你能做出下面这个题吗" tabindex="-1"><a class="header-anchor" href="#_9-你能做出下面这个题吗" aria-hidden="true">#</a> 9.你能做出下面这个题吗？</h3>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">x</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">x</span><span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\nobj<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>\nobj<span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>有了第七问和第八问的知识，这个题目就不难了。 <code>JavaScript</code> 对象的键必须是字符串，因此分别需要将对象 <code>a</code> 和 <code>b</code> 转换为 <code>string</code> 类型。具体转换流程：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token comment">// 1.执行ToPrimitive</span>\n<span class="token comment">// hint 为 string</span>\n<span class="token function">ToPrimitive</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token string">\'hint String\'</span><span class="token punctuation">)</span>\n<span class="token comment">// 2.执行OrdinaryToPrimitive</span>\n<span class="token function">OrdinaryToPrimitive</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token string">\'string\'</span><span class="token punctuation">)</span>\n<span class="token comment">// 3.返回methodNames</span>\nmethodNames <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">\'toString\'</span><span class="token punctuation">,</span> <span class="token string">\'valueOf\'</span><span class="token punctuation">]</span>\n<span class="token comment">// 4.调用methodNames里方法</span>\n<span class="token comment">// 调用toString</span>\na<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 返回[object Object]</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>对象 <code>a</code> 和 <code>b</code> 转换后的结果都是 <code>[object Object]</code>，<code>obj</code> 对象上只添加了一个属性 <code>[object Object]</code>。</p>\n<p><strong>答案</strong></p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token number">200</span>\n<span class="token number">200</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="_10-你能理清类型转换吗" tabindex="-1"><a class="header-anchor" href="#_10-你能理清类型转换吗" aria-hidden="true">#</a> 10.你能理清类型转换吗？</h3>\n<p>首先需要知道：在<code>JavaScript</code>中，只有<strong>三种类型</strong>的转换</p>\n<ul>\n<li>转换为<code>Number</code>类型: <code>Number() / parseFloat() / parseInt()</code></li>\n<li>转化为<code>String</code>类型:<code> String() / toString()</code></li>\n<li>转化为<code>Boolean</code>类型: <code>Boolean()</code></li>\n</ul>\n<p>因此遇到类型转换问题，只需要弄清楚在<strong>什么场景</strong>之下转换成<strong>那种类型</strong>即可。</p>\n<h4 id="转换为boolean" tabindex="-1"><a class="header-anchor" href="#转换为boolean" aria-hidden="true">#</a> 转换为boolean</h4>\n<ul>\n<li>显式：<code>Boolean</code> 方法可以显式将值转换为布尔类型</li>\n<li>隐式：通常在逻辑判断或者有逻辑运算符时触发（<code>|| &amp;&amp; !</code>）</li>\n</ul>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>   <span class="token comment">// 显式类型转换</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment">// 逻辑判断类型触发隐式转换</span>\n<span class="token operator">!</span><span class="token operator">!</span><span class="token number">1</span>          <span class="token comment">// 逻辑运算符触发隐式转换</span>\n<span class="token number">1</span> <span class="token operator">||</span> <span class="token string">\'hello\'</span> <span class="token comment">// 逻辑运算符触发隐式转换</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><code>boolean</code> 类型只有 <code>true</code> 和 <code>false</code> 两种值。</p>\n<p>除值 <strong>0,-0,null,NaN,undefined,或空字符串（&quot;&quot;）</strong> 为 <code>false</code> 外，其余全为 <code>true</code></p>\n<h4 id="转化为string" tabindex="-1"><a class="header-anchor" href="#转化为string" aria-hidden="true">#</a> 转化为string</h4>\n<ul>\n<li>显式：<code>String</code> 方法可以显式将值转换为字符串</li>\n<li>隐式：<code>+</code> 运算符有一侧操作数为 <code>string</code> 类型时</li>\n</ul>\n<p>转化为 <code>string</code> 类型的本质：<strong>需要转换为string的部分调用自身的toString方法(null/undefined返回字符串格式的null和undefined)</strong></p>\n<blockquote>\n<p>当被转换值为对象时，相当于执行 <code>ToPrimitive(input, \'hint String\')</code></p>\n</blockquote>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 1,2,3</span>\n<span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">x</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// [object Object]</span>\n\n<span class="token number">1</span> <span class="token operator">+</span> <span class="token string">\'1\'</span> <span class="token comment">// 11</span>\n<span class="token number">1</span> <span class="token operator">+</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 1[object Object]</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h4 id="转化为number" tabindex="-1"><a class="header-anchor" href="#转化为number" aria-hidden="true">#</a> 转化为number</h4>\n<ul>\n<li>显式：<code>Number</code> 方法可以显式将值转化为数字类型</li>\n</ul>\n<p><code>Number</code> 的具体规则，<code>ES5</code> 规范中给了一个<a href="https://link.juejin.cn?target=http%3A%2F%2Fes5.github.io%2F%23x9.3" target="_blank" rel="noopener noreferrer">对应的结果表<ExternalLinkIcon/></a></p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>结果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>undefined</td>\n<td>NaN</td>\n</tr>\n<tr>\n<td>null</td>\n<td>+0</td>\n</tr>\n<tr>\n<td>Boolean</td>\n<td>NaN</td>\n</tr>\n<tr>\n<td>undefined</td>\n<td>参数为true返回1；false返回+0</td>\n</tr>\n<tr>\n<td>Number</td>\n<td>返回与之相等的值</td>\n</tr>\n<tr>\n<td>String</td>\n<td>有些复杂，举例说明</td>\n</tr>\n<tr>\n<td>Object</td>\n<td>先执行ToPrimitive方法，在执行Number类型转换</td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li><code>String</code>: 空字符串返回 <code>0</code>，出现任何一个非有效数字字符，返回 <code>NaN</code></li>\n</ol>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">"1 3"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// NaN</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// NaN</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">"1a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// NaN</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">"0x11"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 17</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 123</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">"-123"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// -123</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">"1.2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 1.2</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ul>\n<li>\n<p>隐式：</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>number\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>的隐式类型转换比较复杂，对需要隐式转换的部分执行</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>Number\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>：</p>\n<ul>\n<li>比较操作(<code>&lt;, &gt;, &lt;=, &gt;=</code>)</li>\n<li>按位操作(<code>| &amp; ^ ~</code>)</li>\n<li>算数操作(<code>+ - * / %</code>) 注意：<strong>+的操作数存在字符串时，为string转换</strong></li>\n<li>一元 <code>+-</code> 操作</li>\n</ul>\n</li>\n</ul>\n<h3 id="_11-的隐式转换规则" tabindex="-1"><a class="header-anchor" href="#_11-的隐式转换规则" aria-hidden="true">#</a> 11.== 的隐式转换规则</h3>\n<ol>\n<li><code>==</code>: 只需要值相等，无需类型相等；<code>null, undefined</code> 在 <code>==</code> 下互相等且自身等</li>\n<li><code>==</code> 的转换规则:</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>被比较数B</th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td></td>\n<td></td>\n<td>Number</td>\n<td>String</td>\n<td>Boolean</td>\n<td>Object</td>\n</tr>\n<tr>\n<td>比较数A</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Number</td>\n<td>A == B</td>\n<td>A == ToNumber(B)</td>\n<td>A == ToNumber(B)</td>\n<td>A == ToPrimitive(B)</td>\n<td></td>\n</tr>\n<tr>\n<td>String</td>\n<td>ToNumber(A) == B</td>\n<td>A == B</td>\n<td>ToNumber(A) == ToNumber(B)</td>\n<td>ToPrimitive(B) == A</td>\n<td></td>\n</tr>\n<tr>\n<td>Boolean</td>\n<td>ToNumber(A) == B</td>\n<td>ToNumber(A) == ToNumber(B)</td>\n<td>ToNumber(A) == ToNumber(B)</td>\n<td>ToNumber(A) == ToPrimitive(B)</td>\n<td></td>\n</tr>\n<tr>\n<td>Object</td>\n<td>ToPrimitive(A) == B</td>\n<td>ToPrimitive(A) == B</td>\n<td>ToPrimitive(A) == ToPrimitive(B)</td>\n<td>A === B</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>在上面的表格中，<code>ToNumber(A)</code> 尝试在比较前将参数 <code>A</code> 转换为数字。<code>ToPrimitive(A)</code> 将参数 <code>A</code> 转换为原始值( <code>Primitive</code> )。</p>\n<h3 id="_12-1-与-1的输出结果分别是什么" tabindex="-1"><a class="header-anchor" href="#_12-1-与-1的输出结果分别是什么" aria-hidden="true">#</a> 12.<code>1 + {}</code> 与 <code>{} + 1</code>的输出结果分别是什么？</h3>\n<p>通过上面的学习，当对象与其他元素相加时，对象会调用 <code>toPrimitive</code> 转化为原始值：</p>\n<ol>\n<li>执行 <code>toPrimitive</code>，未传入 <code>PreferredType</code>，<code>methodNames</code> 为 <code>[valueOf, toString]</code></li>\n<li>执行 <code>({}).valueOf</code>，返回对象本身 <code>{}</code>，不是原始值</li>\n<li>继续执行 <code>({}).toString()</code>，返回 <code>&quot;[object Object]&quot;</code>，返回结果为原始值，转换结束</li>\n</ol>\n<p>此时 <code>1 + {}</code>，右侧为 <code>string</code> 类型，将 <code>1</code> 进行 <code>ToString()</code> 转化为 <code>&quot;1&quot;</code> ，最后字符串连接，结果为 <code>&quot;1[object Object]&quot;</code></p>\n<p><strong>注意</strong>： <code>{} + 1</code> 输出的结果会和 <code>1 + {}</code> 一样吗？</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>{}` 在 `JavaScript` 中，不止可以作为对象定义，也可以作为代码块的定义。`js` 引擎会把 `{} + 1` 解析成**1个代码块和1个+1**，最终输出结果为 `1\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p><strong>答案</strong></p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token number">1</span><span class="token punctuation">[</span>object Object<span class="token punctuation">]</span>\n<span class="token number">1</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="_13-与-的相加的结果是多少" tabindex="-1"><a class="header-anchor" href="#_13-与-的相加的结果是多少" aria-hidden="true">#</a> 13.[]与{}的相加的结果是多少？</h3>\n<h4 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a> <code>[] + {}</code></h4>\n<p>数组是特殊的对象，需要调用 <code>toPrimitive</code>，转换为原始值</p>\n<ul>\n<li>执行 <code>toPrimitive</code>，未传入 <code>PreferredType</code>，<code>methodNames</code> 为 <code>[valueOf, toString]</code></li>\n<li>执行 <code>[].valueOf</code>，返回数组本身</li>\n<li>执行 <code>[].toString</code>，返回空字符串 <code>\'\'</code></li>\n</ul>\n<p>空对象不做赘述。</p>\n<p><strong>答案</strong></p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token string">"[object Object]"</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="-1" tabindex="-1"><a class="header-anchor" href="#-1" aria-hidden="true">#</a> <code>[] + []</code></h4>\n<p>类似 <code>1</code> 两个空数组都执行 <code>toPrimitive</code>，返回两个空字符串。</p>\n<p><strong>答案</strong></p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token string">""</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="-2" tabindex="-1"><a class="header-anchor" href="#-2" aria-hidden="true">#</a> <code>{} + []</code></h4>\n<p>类似于 <code>{} + 1</code>，<code>{} + []</code> 相当于 <code>{}; + []</code>，一元 <code>+</code> 强制将 <code>&quot;&quot;</code> 隐式转换为<code>0</code>，最终结果为<code>0</code></p>\n<p><strong>答案</strong></p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token number">0</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="-3" tabindex="-1"><a class="header-anchor" href="#-3" aria-hidden="true">#</a> <code>{} + {}</code></h4>\n<p>对于这个题，我先公布一下答案，之后说一下我的疑问。</p>\n<p><strong>答案</strong></p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token punctuation">[</span>object Object<span class="token punctuation">]</span><span class="token punctuation">[</span>object Object<span class="token punctuation">]</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>疑问</strong></p>\n<p>为什么 <code>JavaScript</code> 引擎没有将前面的 <code>{}</code> 解释成代码块？</p>\n<blockquote>\n<p>友情提示：由于 <code>{}</code> 可以解释为代码块的形式，有些需要注意的地方，举个栗子:</p>\n<ul>\n<li>空对象调用方法时：<code>{}.toString()</code> 会报错</li>\n<li>箭头函数返回对象时：<code>let getTempItem = id =&gt; { id: id, name: &quot;Temp&quot; }</code> 会报错</li>\n</ul>\n</blockquote>\n<h3 id="_14-你能灵活运用-parseint-与-parsefloat-吗" tabindex="-1"><a class="header-anchor" href="#_14-你能灵活运用-parseint-与-parsefloat-吗" aria-hidden="true">#</a> 14.你能灵活运用 parseInt 与 parseFloat 吗</h3>\n<ol>\n<li><code>parseInt</code>：从数字类开始看，看到非数字类为止，返回原来的数。(小数点也属于非有效数字)</li>\n</ol>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">\'123x\'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token number">123</span>\n<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">\'-023x\'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token operator">-</span><span class="token number">23</span>\n<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">\'1.1\'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token number">1</span>\n<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">\'-abc\'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token number">NaN</span>\n<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">\'x123\'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token number">NaN</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ol>\n<li><code>parseInt(string, radix)</code> 还有第二个参数 <code>radix</code> 表示要解析数字的基数，取值为 <code>2~36</code> (默认值为<code>10</code>)</li>\n<li><code>parseFloat</code> 与 <code>parseInt</code> 类似，只不过它返回浮点数。从数字类开始看，看到除了第一个点以外的非数字类为截止，返回前面的数。</li>\n</ol>\n<h4 id="网红题-1-2-3-map-parseint" tabindex="-1"><a class="header-anchor" href="#网红题-1-2-3-map-parseint" aria-hidden="true">#</a> 网红题：[\'1\',\'2\',\'3\'].map(parseInt)</h4>\n<p>这个网红题考察的就是 <code>parseInt</code> 有两个参数。 <code>map</code> 传入的函数可执行三个参数：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token comment">// ele   遍历的元素</span>\n<span class="token comment">// index 遍历的元素索引</span>\n<span class="token comment">// arr   数组</span>\narr<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">ele<span class="token punctuation">,</span> index<span class="token punctuation">,</span> arr</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>[\'1\',\'2\',\'3\'].map(parseInt)相当于执行了以下三次过程：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">\'1\'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">\'1\'</span><span class="token punctuation">,</span><span class="token string">\'2\'</span><span class="token punctuation">,</span><span class="token string">\'3\'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">\'2\'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">\'1\'</span><span class="token punctuation">,</span><span class="token string">\'2\'</span><span class="token punctuation">,</span><span class="token string">\'3\'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">\'3\'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">\'1\'</span><span class="token punctuation">,</span><span class="token string">\'2\'</span><span class="token punctuation">,</span><span class="token string">\'3\'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul>\n<li><code>parseInt(\'1\', 0, [\'1\',\'2\',\'3\'])</code>: radix为0时，默认取10，最后返回1</li>\n<li><code>parseInt(\'2\', 1, [\'1\',\'2\',\'3\'])</code>: radix取值为2~36，返回NaN</li>\n<li><code>parseInt(\'3\', 2, [\'1\',\'2\',\'3\'])</code>: radix取值为2，二进制只包括0，1，返回NaN</li>\n</ul>\n<h3 id="_15-如何让-if-a-1-a-2-条件成立" tabindex="-1"><a class="header-anchor" href="#_15-如何让-if-a-1-a-2-条件成立" aria-hidden="true">#</a> 15.如何让 if(a == 1 &amp;&amp; a == 2) 条件成立？</h3>\n<p><code>valueOf</code> 的应用</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>\n    <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>\n    <span class="token function-variable function">valueOf</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token operator">++</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>关于本文</p>\n<p>https://juejin.cn/post/7021750693262262308</p>\n',date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:"/JS/原生JS.html",pathLocale:"/",permalink:null,routeMeta:{},slug:"原生JS",filePath:"C:/Users/mi/Desktop/我的博客/docs/JS/原生JS.md",filePathRelative:"JS/原生JS.md",componentFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/JS/原生JS.html.vue",componentFilePathRelative:"pages/JS/原生JS.html.vue",componentFileChunkName:"v-3f77dce2",dataFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/JS/原生JS.html.js",dataFilePathRelative:"pages/JS/原生JS.html.js",dataFileChunkName:"v-3f77dce2",htmlFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/dist/JS/原生JS.html",htmlFilePathRelative:"JS/原生JS.html"},{data:{key:"v-39cc4c5a",path:"/Navigation/interview.html",title:"interview-1",lang:"zh-CN",frontmatter:{date:"2022/2/4 11:08",coverUrl:"http://cdn-ali-img-shstaticbz.shanhutech.cn/bizhi/staticwp/202111/bf510fc53ed6ffc5c5a215992c7c8f60--761544518.jpg",sticky:!0,keyword:"面试表达",description:"interview expression",title:"interview-1",tag:["笔记"],categories:["面试表达"]},excerpt:"",headers:[{level:2,title:"一、事件循环",slug:"一、事件循环",children:[{level:3,title:"EventLoop",slug:"eventloop",children:[]}]},{level:2,title:"二、this是什么",slug:"二、this是什么",children:[{level:3,title:"关于this指针的指向问题",slug:"关于this指针的指向问题",children:[]}]},{level:2,title:"三、闭包相关问题",slug:"三、闭包相关问题",children:[]},{level:2,title:"四、vue的生命周期",slug:"四、vue的生命周期",children:[]},{level:2,title:"五、web前端开发技术的优化策略",slug:"五、web前端开发技术的优化策略",children:[{level:3,title:"减少页面加载时间的方式",slug:"减少页面加载时间的方式",children:[]}]},{level:2,title:"六、回流和重绘",slug:"六、回流和重绘",children:[{level:3,title:"何时发生回流重绘",slug:"何时发生回流重绘",children:[]},{level:3,title:"减少重排重绘的方法",slug:"减少重排重绘的方法",children:[]},{level:3,title:"浏览器的优化机制",slug:"浏览器的优化机制",children:[]}]},{level:2,title:"七、常见的HTTP状态码",slug:"七、常见的http状态码",children:[{level:3,title:"状态码分类：",slug:"状态码分类",children:[]},{level:3,title:"常见的HTTP状态码列表:",slug:"常见的http状态码列表",children:[]}]},{level:2,title:"八、Ajax如何使用",slug:"八、ajax如何使用",children:[]},{level:2,title:"九、下面代码中 a 在什么情况下会打印 1？",slug:"九、下面代码中-a-在什么情况下会打印-1",children:[]},{level:2,title:"十、介绍下 BFC 及其应用",slug:"十、介绍下-bfc-及其应用",children:[]},{level:2,title:"十一、对sort()的理解",slug:"十一、对sort-的理解",children:[]},{level:2,title:"十二、call、apply、bind的区别",slug:"十二、call、apply、bind的区别",children:[]},{level:2,title:"十三、分析比较 opacity: 0、visibility: hidden、display: none 优劣和适用场景。",slug:"十三、分析比较-opacity-0、visibility-hidden、display-none-优劣和适用场景。",children:[]},{level:2,title:"十四、ES6 代码转成 ES5 代码的实现思路是什么",slug:"十四、es6-代码转成-es5-代码的实现思路是什么",children:[]},{level:2,title:"十五、数组里面有10万个数据，取第一个元素和第10万个元素的时间相差多少",slug:"十五、数组里面有10万个数据-取第一个元素和第10万个元素的时间相差多少",children:[]},{level:2,title:"十六、Vue 的父组件和子组件生命周期钩子执行顺序是什么",slug:"十六、vue-的父组件和子组件生命周期钩子执行顺序是什么",children:[]},{level:2,title:"十七、import导入的模块",slug:"十七、import导入的模块",children:[]},{level:2,title:"十八、var、let 和 const",slug:"十八、var、let-和-const",children:[]},{level:2,title:"十九、 Object.steal()和Object.freezze()",slug:"十九、-object-steal-和object-freezze",children:[]}],git:{updatedTime:null,contributors:[]}},key:"v-39cc4c5a",path:"/Navigation/interview.html",title:"interview-1",lang:"zh-CN",frontmatter:{date:"2022/2/4 11:08",coverUrl:"http://cdn-ali-img-shstaticbz.shanhutech.cn/bizhi/staticwp/202111/bf510fc53ed6ffc5c5a215992c7c8f60--761544518.jpg",sticky:!0,keyword:"面试表达",description:"interview expression",title:"interview-1",tag:["笔记"],categories:["面试表达"]},excerpt:"",headers:[{level:2,title:"一、事件循环",slug:"一、事件循环",children:[{level:3,title:"EventLoop",slug:"eventloop",children:[]}]},{level:2,title:"二、this是什么",slug:"二、this是什么",children:[{level:3,title:"关于this指针的指向问题",slug:"关于this指针的指向问题",children:[]}]},{level:2,title:"三、闭包相关问题",slug:"三、闭包相关问题",children:[]},{level:2,title:"四、vue的生命周期",slug:"四、vue的生命周期",children:[]},{level:2,title:"五、web前端开发技术的优化策略",slug:"五、web前端开发技术的优化策略",children:[{level:3,title:"减少页面加载时间的方式",slug:"减少页面加载时间的方式",children:[]}]},{level:2,title:"六、回流和重绘",slug:"六、回流和重绘",children:[{level:3,title:"何时发生回流重绘",slug:"何时发生回流重绘",children:[]},{level:3,title:"减少重排重绘的方法",slug:"减少重排重绘的方法",children:[]},{level:3,title:"浏览器的优化机制",slug:"浏览器的优化机制",children:[]}]},{level:2,title:"七、常见的HTTP状态码",slug:"七、常见的http状态码",children:[{level:3,title:"状态码分类：",slug:"状态码分类",children:[]},{level:3,title:"常见的HTTP状态码列表:",slug:"常见的http状态码列表",children:[]}]},{level:2,title:"八、Ajax如何使用",slug:"八、ajax如何使用",children:[]},{level:2,title:"九、下面代码中 a 在什么情况下会打印 1？",slug:"九、下面代码中-a-在什么情况下会打印-1",children:[]},{level:2,title:"十、介绍下 BFC 及其应用",slug:"十、介绍下-bfc-及其应用",children:[]},{level:2,title:"十一、对sort()的理解",slug:"十一、对sort-的理解",children:[]},{level:2,title:"十二、call、apply、bind的区别",slug:"十二、call、apply、bind的区别",children:[]},{level:2,title:"十三、分析比较 opacity: 0、visibility: hidden、display: none 优劣和适用场景。",slug:"十三、分析比较-opacity-0、visibility-hidden、display-none-优劣和适用场景。",children:[]},{level:2,title:"十四、ES6 代码转成 ES5 代码的实现思路是什么",slug:"十四、es6-代码转成-es5-代码的实现思路是什么",children:[]},{level:2,title:"十五、数组里面有10万个数据，取第一个元素和第10万个元素的时间相差多少",slug:"十五、数组里面有10万个数据-取第一个元素和第10万个元素的时间相差多少",children:[]},{level:2,title:"十六、Vue 的父组件和子组件生命周期钩子执行顺序是什么",slug:"十六、vue-的父组件和子组件生命周期钩子执行顺序是什么",children:[]},{level:2,title:"十七、import导入的模块",slug:"十七、import导入的模块",children:[]},{level:2,title:"十八、var、let 和 const",slug:"十八、var、let-和-const",children:[]},{level:2,title:"十九、 Object.steal()和Object.freezze()",slug:"十九、-object-steal-和object-freezze",children:[]}],content:"## 一、事件循环\r\n> Javascript是一门单线程语言，只有前一个任务执行完毕才会运行下一个任务，为了规避掉资源分配的浪费，所以将Javascript的任务分为同步任务和异步任务 \r\n>\r\n> > 异步任务又分为宏任务和微任务\r\n### EventLoop\r\n> 先执行同步操作，异步操作排在事件队列里\r\n1. 先判断是同步还是异步，同步任务进入主线程，异步任务进入Event Table(任务队列)\r\n2. 异步任务在Event Table中注册事件，当满足促发条件的时候，会被推入到Event Queue(事件队列)\r\n3. 主线程空闲时，才会在Event Queue中看是否又需要执行的异步任务，如果有，就推入主线程中执行\r\n>异步任务执行顺序为先执行微任务，在执行宏任务\r\n\r\n---\r\n\r\n## 二、this是什么\r\n  当一个函数被调用时,会创建一个执行上下文,这个执行上下文包含函数在哪里调用(调用栈),函数的调用方法,传入的参数等,**this**就是用来记录当前这个执行上下文信息的一个属性\r\n### 关于this指针的指向问题\r\n1. **this**始终会指向一个对象,是根据函数的执行环境来决定的,函数作为一个对象的方法被调用的话,**this**就指向这个对象\r\n2. 如果是new的话,**this**就指向new出来的这个实例化对象\r\n3. 因为匿名函数和自执行函数的执行环境具有全局性,所以它的this一般指向window\r\n4. 箭头函数没有自己的this,它里面的**this**的指向跟外部作用域中**this**指向一致\r\n\r\n---\r\n\r\n## 三、闭包相关问题\r\n> 当内部函数被保存到外部时,将会产生闭包\r\n\r\n***定义***:在JavaScript中,根据词法作用域的规则,内部函数总是可以访问其外部函数中申明的变量,当通过调用一个外部函数返回一个内部函数后,即使该外部函数已经执行结束,但是内部函数引用外部函数的变量,依然保存在内存中,我们把这些变量的集合称为闭包\r\n\r\n***缺点***:闭包会导致原有的作用域链不释放,造成内存泄漏\\\r\n***优点***:\r\n1. 实现公有化变量 (企业的模块开发) \r\n2. 做缓存 \r\n3. 实现属性的私有化\r\n4. 模块化开发，防止污染全局变量\r\n> 变量长期驻扎在内存中,避免全局变量的污染,私有成员的存在\r\n\r\n---\r\n\r\n## 四、vue的生命周期\r\n\r\n>Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、销毁等一系列过程，我们称这是Vue的生命周期。通俗说就是Vue实例从创建到销毁的过程，就是生命周期。\r\n\r\n每一个组件或者实例都会经历一个完整的生命周期，总共分为三个阶段：初始化、运行中、销毁。\r\n1. 实例、组件通过new Vue() 创建出来之后会初始化事件和生命周期，然后就会执行**beforeCreate**钩子函数，这个时候，数据还没有挂载呢，只是一个空壳，无法访问到数据和真实的dom，一般不做操作\r\n2. 挂载数据，绑定事件等等，然后执行**created**函数，这个时候已经可以使用到数据，也可以更改数据,在这里更改数据不会触发updated函数，在这里可以在渲染前倒数第二次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取\r\n3. 接下来开始找实例或者组件对应的模板，编译模板为虚拟dom放入到render函数中准备渲染，然后执行**beforeMount**钩子函数，在这个函数中虚拟dom已经创建完成，马上就要渲染,在这里也可以更改数据，不会触发**updated**，在这里可以在渲染前最后一次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取\r\n4. 接下来开始render，渲染出真实dom，然后执行**mounted**钩子函数，此时，组件已经出现在页面中，数据、真实dom都已经处理好了,事件都已经挂载好了，可以在这里操作真实dom等事情...\r\n5. 当组件或实例的数据更改之后，会立即执行**beforeUpdate**，然后vue的虚拟dom机制会重新构建虚拟dom与上一次的虚拟dom树利用diff算法进行对比之后重新渲染，一般不做什么事儿\r\n6. 当更新完成后，执行**updated**，数据已经更改完成，dom也重新render完成，可以操作更新后的虚拟dom\r\n7. 当经过某种途径调用$destroy方法后，立即执行**beforeDestroy**，一般在这里做一些善后工作，例如清除计时器、清除非指令绑定的事件等等\r\n8. 组件的数据绑定、监听...去掉后只剩下dom空壳，这个时候，执行**destroyed**，在这里做善后工作也可以\r\n\r\n---\r\n\r\n## 五、web前端开发技术的优化策略\r\n[web前端开发技术的优化策略](https://blog.csdn.net/smell201611010513/article/details/103784242)\r\n1. 减少HTTP请求数\r\n2. 优化文件的规模\r\n3. 减少DNS查找\r\n4. 杜绝无用响应\r\n5. 有效避免重定向\r\n6. 优化网页内容\r\n\r\n### 减少页面加载时间的方式\r\n1. 优化图片 \r\n2. 图像格式的选择（GIF：提供的颜色较少，可用在一些对颜色要求不高的地方） \r\n3. 优化CSS（压缩合并css，如 margin-top, margin-left...) \r\n4. 网址后加斜杠（如www.campr.com/目录，会判断这个目录是什么文件类型，或者是目录。） \r\n5. cdn托管 \r\n6. 标明高度和宽度（如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小，如果图片很多，浏览器需要不断地调整页面。这不但影响速度，也影响浏览体验。\\\r\n当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加 载后面的内容。从而加载时间快了，浏览体验也更好了）\r\n7. 减少http请求（合并文件，合并图片）\r\n\r\n---\r\n## 六、回流和重绘\r\n**回流**：当render tree中的一部分或者全部因为元素的规模尺寸，布局，隐藏等改变而需要重新构建，这就叫回流\r\n>每个页面至少需要一次回流，就是在页面第一次加载的时候，这时候一定会发生回流，因为要构建render tree\r\n\r\n**重绘**:在回流的时候，浏览器会使渲染树中收到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏 览器会重新绘制受影响的部分到屏幕中，这就是重绘\r\n>当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，不会影响布局，就叫重绘\r\n\r\n### 何时发生回流重绘\r\n- 回流这一阶段主要是计算节点的位置和几何信息，那么当页面布局和几何信息发生变化的时候，就需要回流。比如以下情况：\r\n- 添加或删除可见的DOM元素\r\n- 元素的位置发生变化\r\n- 元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）\r\n- 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。\r\n- 页面一开始渲染的时候（这肯定避免不了）\r\n- 浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）\r\n\r\n**注意：回流一定会触发重绘，而重绘不一定会回流**\r\n\r\n### 减少重排重绘的方法\r\n[减少重排重绘的方法](https://github.com/chenjigeng/blog/issues/4)\r\n### 浏览器的优化机制\r\n目前大多数浏览器，都会通过队列化来批量的修改重排的过程，浏览器会将修改操作放到队列中，直到一段时间后，队列的存储达到阈值，才会一次性全部重排，清空队列；**但是！当你获取布局信息的操作的时候，会强制队列刷新**\r\n- offsetTop、offsetLeft、offsetWidth、offsetHeight\r\n- scrollTop、scrollLeft、scrollWidth、scrollHeight\r\n- clientTop、clientLeft、clientWidth、clientHeight\r\n- getComputedStyle()\r\n- getBoundingClientRect\r\n>以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。因此，我们在修改样式的时候，**最好避免使用上面列出的属性，他们都会刷新渲染队列**如果要使用它们，最好将值缓存起来。\r\n\r\n---\r\n\r\n## 七、常见的HTTP状态码\r\n\r\n### 状态码分类：\r\n\r\n| 分类      | \t分类描述                                       |\r\n| --------- | ------------------------------------------- |\r\n| 1**       | 信息，服务器收到请求，需要请求者继续执行操作    |\r\n| 2**       | 成功，操作被成功接收并处理                     |\r\n| 3**       | 重定向，需要进一步的操作以完成请求              |\r\n| 4**       | 客户端错误，请求包含语法错误或无法完成请求       |\r\n| 5**       | 服务器错误，服务器在处理请求的过程中发生了错误   |\r\n\r\n\r\n### 常见的HTTP状态码列表:\r\n| 状态码 |     描述                                      |\r\n| --------- | ------------------------------------------- |\r\n| ***100*** | 这个状态码告诉客户应该继续发送请求，这个临时响应是用来通知客户端的，部分的请求服务器已经接受，但是客户端应该继续发送请求的剩余部分，如果请求已经完成，就忽略这个响应，而且服务器会在请求完成后向客户发送一个最终的结果。|\r\n| ***200*** | 这个是最常见的http状态码，表示服务器已经成功接受请求，并将返回客户端所请求的最终结果。|\r\n| ***202*** | 表示服务器已经接受了请求，但是还没有处理，而且这个请求最终会不会处理还不确定。|\r\n| ***204*** | 服务器成功处理了请求，但没有返回任何实体内容，可能会返回新的头部元信息。|\r\n| ***301*** | 客户端请求的页面已经永久移动到新的位置，当链接发生变化时，返回301代码告诉客户端连接的变化，客户端保存新的链接，并向新的链接发出请求，已返回请求结果。|\r\n| ***404*** | 请求失败，客户端请求的资源没有找到或者是不存在。|\r\n| ***500*** | 服务器遇到未知的错误，导致无法完成客户端当前的请求。|\r\n| ***503*** | 服务器由于临时的服务器过载或者是维护，无法解决当前的请求。|\r\n\r\n[参考](https://www.runoob.com/http/http-status-codes.html)\r\n\r\n\r\n---\r\n\r\n## 八、Ajax如何使用\r\n一个完整的AJAX请求包括五个步骤：\r\n具体来说，AJAX 包括以下几个步骤。\r\n\r\n1. 创建 XMLHttpRequest 对象，也就是创建一个异步调用对象\r\n\r\n2. 创建一个新的 HTTP 请求，并指定该 HTTP 请求的方法、URL 及验证信息\r\n\r\n3. 设置响应 HTTP 请求状态变化的函数\r\n\r\n4. 发送 HTTP 请求\r\n\r\n5. 获取异步调用返回的数据\r\n\r\n6. 使用 JavaScript 和 DOM 实现局部刷新\r\n\r\n\r\n```js\r\n// 创建可以请求的实例对象\r\nvar myAjax = new XMLHttpRequest()\r\n// 设置请求的url参数，这是准备工作\r\nmyAjax.open('GET', 'https://autumnfish.cn/search?keywords=\"我们俩\"' )\r\n// 发送请求\r\nmyAjax.send()\r\n// 接收\r\nmyAjax.onreadystatechange = function() {\r\n  if (myAjax.readyState == 4 && myAjax.status == 200) {\r\n    console.log(JSON.parse(myAjax.responseText));  // JSON将字符串转换为对象\r\n  }\r\n}\r\n```\r\n[参考链接](https://juejin.cn/post/6992525007716876325#heading-54)\r\n\r\n\r\n---\r\n\r\n## 九、下面代码中 a 在什么情况下会打印 1？\r\n```js\r\nvar a = ?;\r\nif(a == 1 && a == 2 && a == 3){\r\n \tconso.log(1);\r\n}\r\n```\r\n>答案解析 因为==会进行隐式类型转换 所以我们重写toString方法就可以了\r\n```js\r\nvar a = {\r\n  i: 1,\r\n  toString() {\r\n    return a.i++;\r\n  }\r\n}\r\n\r\nif( a == 1 && a == 2 && a == 3 ) {\r\n  console.log(1);\r\n}\r\n```\r\n\r\n---\r\n\r\n## 十、介绍下 BFC 及其应用\r\n\r\nBFC 就是块级格式上下文，是页面盒模型布局中的一种 CSS 渲染模式，相当于一个独立的容器，里面的元素和外部的元素相互不影响。\\\r\n创建BFC 的方式有：\r\n\r\n下列方式会创建块格式化上下文：\r\n\r\n- html根元素（）\r\n\r\n- float浮动（元素的 float 不是 none）\r\n\r\n- 绝对定位元素（元素的 position 为 absolute 或 fixed）\r\n\r\n- 行内块元素（元素的 display 为 inline-block）\r\n\r\n- display 为表格布局、弹性元素（flex、inline-flex）、网格元素（grid、inline-grid）\r\n\r\n- overflow 计算值(Computed)不为 visible 的块元素\r\n- 等。。。\r\n\r\nBFC 主要的作用是：\r\n1. 清除浮动\r\n3. 防止同一 BFC 容器中的相邻元素间的外边距重叠问题\r\n\r\nBFC特性:\r\n- BFC元素的垂直方向上会发生边距重叠。\r\n\r\n- BFC元素和浮动元素不会发生重叠。\r\n\r\n- BFC在计算高度时会把浮动元素计算进去。\r\n\r\n- BFC在页面是个独立的容器，里外元素互不影响。\r\n\r\n--- \r\n\r\n## 十一、对sort()的理解\r\n>使用 sort() 对数组 [3, 15, 8, 29, 102, 22] 进行排序，输出结果\r\n\r\n答案:**[102, 15, 22, 29, 3, 8]**\r\n\r\n解析:\r\n>根据MDN上对Array.sort()的解释，***默认的排序方法会将数组元素转换为字符串，然后比较字符串中字符的UTF-16编码顺序来进行排序***。所以'102' 会排在 '15' 前面。\r\n\r\n如果要对数值进行升序排列：\r\n```js\r\n[3, 15, 8, 29, 102, 22].sort((a, b) => a - b) \r\n// [3, 8, 15, 22, 29, 102]\r\n```\r\n\r\n---\r\n\r\n## 十二、call、apply、bind的区别\r\n作用：\r\n> 改变函数执行时的上下文,其中call和apply是立即调用的\r\n1. cal、apply、bind必须通过函数来调用，第一个参数为对象，若第一个参数为null或者undefined，则指向window\r\n2. call和bind方法可以接收多个参数，apply方法只能接收2个参数，且第二个参数为数组或者伪数组\r\n3. call、apply、bind方法的调用：\r\n    1. call和apply方法没有返回值（即返回undefined）\r\n    2. bind方法返回一个原函数的拷贝，并具有指定的this值和初始参数\r\n4. call、apply、bind方法的调用：\r\n    1. call和apply是立即执行的 \r\n    2. bind返回值是一个函数，需要稍后再调用一下，才会执行。\r\n\r\n[参考](参考：https://segmentfault.com/a/1190000018017796)\r\n\r\n---\r\n\r\n## 十三、分析比较 opacity: 0、visibility: hidden、display: none 优劣和适用场景。\r\n\r\n总结一下：\\\r\n***结构***：\r\n- display:none: 会让元素完全从渲染树中消失，渲染的时候不占据任何空间, 不能点击，\r\n- visibility: hidden:不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，不能点击\r\n- opacity: 0: 不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，可以点击\r\n\r\n***继承***：\r\n- display: none和opacity: 0：是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示。\r\n- visibility: hidden：是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显式。\r\n\r\n***性能***：\r\n- displaynone : 修改元素会造成文档回流,读屏器不会读取display: none元素内容，性能消耗较大\r\n- visibility:hidden: 修改元素只会造成本元素的重绘,性能消耗较少读屏器读取visibility: hidden元素内容\r\n- opacity: 0 ： 修改元素会造成重绘，性能消耗较少\r\n\r\n***联系***：它们都能让元素不可见\r\n\r\n[参考](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/100)\r\n\r\n---\r\n\r\n## 十四、ES6 代码转成 ES5 代码的实现思路是什么\r\nBabel 是如何把 ES6 转成 ES5 呢\\\r\n其大致分为三步：\r\n1. 将代码字符串解析成抽象语法树，即所谓的 AST\r\n2. 对 AST 进行处理，在这个阶段可以对 ES6 代码进行相应转换，即转成 ES5 代码\r\n3. 根据处理后的 AST 再生成代码字符串\r\n\r\n>将ES6的代码转换为AST语法树，然后再将ES6 AST转为ES5 AST，再将AST转为代码\r\n\r\n--- \r\n\r\n## 十五、数组里面有10万个数据，取第一个元素和第10万个元素的时间相差多少\r\n\r\n1. 脚本里面的数组不是真正的数组，用的Hash算法，所以读取时间是一致的；\r\n2. 即便真正的数组，读取时间也是一致的，连续内存直接读就好了；\r\n3. 只有对单向链表才有差异；\r\n\r\n---\r\n\r\n## 十六、Vue 的父组件和子组件生命周期钩子执行顺序是什么\r\n\r\n1. 加载渲染过程\\\r\n**父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted**\r\n2. 子组件更新过程\\\r\n**父beforeUpdate->子beforeUpdate->子updated->父updated**\r\n3. 父组件更新过程\\\r\n**父beforeUpdate->父updated**\r\n4. 销毁过程\\\r\n**父beforeDestroy->子beforeDestroy->子destroyed->父destroyed**\r\n\r\n***总结***：从外到内，再从内到外\r\n\r\n---\r\n\r\n## 十七、import导入的模块\r\n> import导入的模块是只读的：您不能修改导入的模块。只有导出它们的模块才能更改其值\r\n\r\n[例题](https://github.com/lydiahallie/javascript-questions#57-whats-the-output)\r\n\r\n---\r\n\r\n## 十八、var、let 和 const \r\n\r\n- **var**的话会直接在栈内存里预分配内存空间，然后等到实际语句执行的时候，再存储对应的变量，如果传的是引用类型，那么会在堆内存里开辟一个内存空间存储实际内容，栈内存会存储一个指向堆内存的指针\r\n\r\n- **let**的话，是不会在栈内存里预分配内存空间，而且在栈内存分配变量时，做一个检查，如果已经有相同变量名存在就会报错\r\n\r\n- **const**的话，也不会预分配内存空间，在栈内存分配变量时也会做同样的检查。不过const存储的变量是不可修改的，对于基本类型来说你无法修改定义的值，对于引用类型来说你无法修改栈内存里分配的指针，但是你可以修改指针指向的对象里面的属性\r\n\r\n---\r\n\r\n## 十九、 Object.steal()和Object.freezze()\r\n1. O**bject.steal()**\r\n    1. 防止对象添加新属性或删除现有属性\r\n\r\n    2. 但仍可以修改现有属性的值\r\n\r\n[例题](https://github.com/lydiahallie/javascript-questions#136-which-of-the-following-will-modify-the-person-object)\r\n\r\n\r\n2. **Object.freeze()**\r\n    1. 冻结一个对象，不可添加、修改、删除任何属性\r\n\r\n    2. 但只是浅冻结对象，只是对对象的直接属性进行了冻结，若属性中又另一个对象，则可对这个对象进行修改\r\n\r\n[例题](https://github.com/lydiahallie/javascript-questions#137-which-of-the-following-will-modify-the-person-object)\r\n\r\n\r\n\r\n---\r\n\r\n<div style=\"font-weight:700; text-align:center; padding-top:20px;\">最后更新时间：2022.02.12</div>",contentRendered:'<h2 id="一、事件循环" tabindex="-1"><a class="header-anchor" href="#一、事件循环" aria-hidden="true">#</a> 一、事件循环</h2>\n<blockquote>\n<p>Javascript是一门单线程语言，只有前一个任务执行完毕才会运行下一个任务，为了规避掉资源分配的浪费，所以将Javascript的任务分为同步任务和异步任务</p>\n<blockquote>\n<p>异步任务又分为宏任务和微任务</p>\n</blockquote>\n</blockquote>\n<h3 id="eventloop" tabindex="-1"><a class="header-anchor" href="#eventloop" aria-hidden="true">#</a> EventLoop</h3>\n<blockquote>\n<p>先执行同步操作，异步操作排在事件队列里</p>\n</blockquote>\n<ol>\n<li>先判断是同步还是异步，同步任务进入主线程，异步任务进入Event Table(任务队列)</li>\n<li>异步任务在Event Table中注册事件，当满足促发条件的时候，会被推入到Event Queue(事件队列)</li>\n<li>主线程空闲时，才会在Event Queue中看是否又需要执行的异步任务，如果有，就推入主线程中执行</li>\n</ol>\n<blockquote>\n<p>异步任务执行顺序为先执行微任务，在执行宏任务</p>\n</blockquote>\n<hr>\n<h2 id="二、this是什么" tabindex="-1"><a class="header-anchor" href="#二、this是什么" aria-hidden="true">#</a> 二、this是什么</h2>\n<p>当一个函数被调用时,会创建一个执行上下文,这个执行上下文包含函数在哪里调用(调用栈),函数的调用方法,传入的参数等,<strong>this</strong>就是用来记录当前这个执行上下文信息的一个属性</p>\n<h3 id="关于this指针的指向问题" tabindex="-1"><a class="header-anchor" href="#关于this指针的指向问题" aria-hidden="true">#</a> 关于this指针的指向问题</h3>\n<ol>\n<li><strong>this</strong>始终会指向一个对象,是根据函数的执行环境来决定的,函数作为一个对象的方法被调用的话,<strong>this</strong>就指向这个对象</li>\n<li>如果是new的话,<strong>this</strong>就指向new出来的这个实例化对象</li>\n<li>因为匿名函数和自执行函数的执行环境具有全局性,所以它的this一般指向window</li>\n<li>箭头函数没有自己的this,它里面的<strong>this</strong>的指向跟外部作用域中<strong>this</strong>指向一致</li>\n</ol>\n<hr>\n<h2 id="三、闭包相关问题" tabindex="-1"><a class="header-anchor" href="#三、闭包相关问题" aria-hidden="true">#</a> 三、闭包相关问题</h2>\n<blockquote>\n<p>当内部函数被保存到外部时,将会产生闭包</p>\n</blockquote>\n<p><em><strong>定义</strong></em>:在JavaScript中,根据词法作用域的规则,内部函数总是可以访问其外部函数中申明的变量,当通过调用一个外部函数返回一个内部函数后,即使该外部函数已经执行结束,但是内部函数引用外部函数的变量,依然保存在内存中,我们把这些变量的集合称为闭包</p>\n<p><em><strong>缺点</strong></em>:闭包会导致原有的作用域链不释放,造成内存泄漏<br>\n<em><strong>优点</strong></em>:</p>\n<ol>\n<li>实现公有化变量 (企业的模块开发)</li>\n<li>做缓存</li>\n<li>实现属性的私有化</li>\n<li>模块化开发，防止污染全局变量</li>\n</ol>\n<blockquote>\n<p>变量长期驻扎在内存中,避免全局变量的污染,私有成员的存在</p>\n</blockquote>\n<hr>\n<h2 id="四、vue的生命周期" tabindex="-1"><a class="header-anchor" href="#四、vue的生命周期" aria-hidden="true">#</a> 四、vue的生命周期</h2>\n<blockquote>\n<p>Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、销毁等一系列过程，我们称这是Vue的生命周期。通俗说就是Vue实例从创建到销毁的过程，就是生命周期。</p>\n</blockquote>\n<p>每一个组件或者实例都会经历一个完整的生命周期，总共分为三个阶段：初始化、运行中、销毁。</p>\n<ol>\n<li>实例、组件通过new Vue() 创建出来之后会初始化事件和生命周期，然后就会执行<strong>beforeCreate</strong>钩子函数，这个时候，数据还没有挂载呢，只是一个空壳，无法访问到数据和真实的dom，一般不做操作</li>\n<li>挂载数据，绑定事件等等，然后执行<strong>created</strong>函数，这个时候已经可以使用到数据，也可以更改数据,在这里更改数据不会触发updated函数，在这里可以在渲染前倒数第二次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取</li>\n<li>接下来开始找实例或者组件对应的模板，编译模板为虚拟dom放入到render函数中准备渲染，然后执行<strong>beforeMount</strong>钩子函数，在这个函数中虚拟dom已经创建完成，马上就要渲染,在这里也可以更改数据，不会触发<strong>updated</strong>，在这里可以在渲染前最后一次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取</li>\n<li>接下来开始render，渲染出真实dom，然后执行<strong>mounted</strong>钩子函数，此时，组件已经出现在页面中，数据、真实dom都已经处理好了,事件都已经挂载好了，可以在这里操作真实dom等事情...</li>\n<li>当组件或实例的数据更改之后，会立即执行<strong>beforeUpdate</strong>，然后vue的虚拟dom机制会重新构建虚拟dom与上一次的虚拟dom树利用diff算法进行对比之后重新渲染，一般不做什么事儿</li>\n<li>当更新完成后，执行<strong>updated</strong>，数据已经更改完成，dom也重新render完成，可以操作更新后的虚拟dom</li>\n<li>当经过某种途径调用$destroy方法后，立即执行<strong>beforeDestroy</strong>，一般在这里做一些善后工作，例如清除计时器、清除非指令绑定的事件等等</li>\n<li>组件的数据绑定、监听...去掉后只剩下dom空壳，这个时候，执行<strong>destroyed</strong>，在这里做善后工作也可以</li>\n</ol>\n<hr>\n<h2 id="五、web前端开发技术的优化策略" tabindex="-1"><a class="header-anchor" href="#五、web前端开发技术的优化策略" aria-hidden="true">#</a> 五、web前端开发技术的优化策略</h2>\n<p><a href="https://blog.csdn.net/smell201611010513/article/details/103784242" target="_blank" rel="noopener noreferrer">web前端开发技术的优化策略<ExternalLinkIcon/></a></p>\n<ol>\n<li>减少HTTP请求数</li>\n<li>优化文件的规模</li>\n<li>减少DNS查找</li>\n<li>杜绝无用响应</li>\n<li>有效避免重定向</li>\n<li>优化网页内容</li>\n</ol>\n<h3 id="减少页面加载时间的方式" tabindex="-1"><a class="header-anchor" href="#减少页面加载时间的方式" aria-hidden="true">#</a> 减少页面加载时间的方式</h3>\n<ol>\n<li>优化图片</li>\n<li>图像格式的选择（GIF：提供的颜色较少，可用在一些对颜色要求不高的地方）</li>\n<li>优化CSS（压缩合并css，如 margin-top, margin-left...)</li>\n<li>网址后加斜杠（如www.campr.com/目录，会判断这个目录是什么文件类型，或者是目录。）</li>\n<li>cdn托管</li>\n<li>标明高度和宽度（如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小，如果图片很多，浏览器需要不断地调整页面。这不但影响速度，也影响浏览体验。<br>\n当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加 载后面的内容。从而加载时间快了，浏览体验也更好了）</li>\n<li>减少http请求（合并文件，合并图片）</li>\n</ol>\n<hr>\n<h2 id="六、回流和重绘" tabindex="-1"><a class="header-anchor" href="#六、回流和重绘" aria-hidden="true">#</a> 六、回流和重绘</h2>\n<p><strong>回流</strong>：当render tree中的一部分或者全部因为元素的规模尺寸，布局，隐藏等改变而需要重新构建，这就叫回流</p>\n<blockquote>\n<p>每个页面至少需要一次回流，就是在页面第一次加载的时候，这时候一定会发生回流，因为要构建render tree</p>\n</blockquote>\n<p><strong>重绘</strong>:在回流的时候，浏览器会使渲染树中收到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏 览器会重新绘制受影响的部分到屏幕中，这就是重绘</p>\n<blockquote>\n<p>当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，不会影响布局，就叫重绘</p>\n</blockquote>\n<h3 id="何时发生回流重绘" tabindex="-1"><a class="header-anchor" href="#何时发生回流重绘" aria-hidden="true">#</a> 何时发生回流重绘</h3>\n<ul>\n<li>回流这一阶段主要是计算节点的位置和几何信息，那么当页面布局和几何信息发生变化的时候，就需要回流。比如以下情况：</li>\n<li>添加或删除可见的DOM元素</li>\n<li>元素的位置发生变化</li>\n<li>元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）</li>\n<li>内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。</li>\n<li>页面一开始渲染的时候（这肯定避免不了）</li>\n<li>浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）</li>\n</ul>\n<p><strong>注意：回流一定会触发重绘，而重绘不一定会回流</strong></p>\n<h3 id="减少重排重绘的方法" tabindex="-1"><a class="header-anchor" href="#减少重排重绘的方法" aria-hidden="true">#</a> 减少重排重绘的方法</h3>\n<p><a href="https://github.com/chenjigeng/blog/issues/4" target="_blank" rel="noopener noreferrer">减少重排重绘的方法<ExternalLinkIcon/></a></p>\n<h3 id="浏览器的优化机制" tabindex="-1"><a class="header-anchor" href="#浏览器的优化机制" aria-hidden="true">#</a> 浏览器的优化机制</h3>\n<p>目前大多数浏览器，都会通过队列化来批量的修改重排的过程，浏览器会将修改操作放到队列中，直到一段时间后，队列的存储达到阈值，才会一次性全部重排，清空队列；<strong>但是！当你获取布局信息的操作的时候，会强制队列刷新</strong></p>\n<ul>\n<li>offsetTop、offsetLeft、offsetWidth、offsetHeight</li>\n<li>scrollTop、scrollLeft、scrollWidth、scrollHeight</li>\n<li>clientTop、clientLeft、clientWidth、clientHeight</li>\n<li>getComputedStyle()</li>\n<li>getBoundingClientRect</li>\n</ul>\n<blockquote>\n<p>以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。因此，我们在修改样式的时候，<strong>最好避免使用上面列出的属性，他们都会刷新渲染队列</strong>如果要使用它们，最好将值缓存起来。</p>\n</blockquote>\n<hr>\n<h2 id="七、常见的http状态码" tabindex="-1"><a class="header-anchor" href="#七、常见的http状态码" aria-hidden="true">#</a> 七、常见的HTTP状态码</h2>\n<h3 id="状态码分类" tabindex="-1"><a class="header-anchor" href="#状态码分类" aria-hidden="true">#</a> 状态码分类：</h3>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>分类描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1**</td>\n<td>信息，服务器收到请求，需要请求者继续执行操作</td>\n</tr>\n<tr>\n<td>2**</td>\n<td>成功，操作被成功接收并处理</td>\n</tr>\n<tr>\n<td>3**</td>\n<td>重定向，需要进一步的操作以完成请求</td>\n</tr>\n<tr>\n<td>4**</td>\n<td>客户端错误，请求包含语法错误或无法完成请求</td>\n</tr>\n<tr>\n<td>5**</td>\n<td>服务器错误，服务器在处理请求的过程中发生了错误</td>\n</tr>\n</tbody>\n</table>\n<h3 id="常见的http状态码列表" tabindex="-1"><a class="header-anchor" href="#常见的http状态码列表" aria-hidden="true">#</a> 常见的HTTP状态码列表:</h3>\n<table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><em><strong>100</strong></em></td>\n<td>这个状态码告诉客户应该继续发送请求，这个临时响应是用来通知客户端的，部分的请求服务器已经接受，但是客户端应该继续发送请求的剩余部分，如果请求已经完成，就忽略这个响应，而且服务器会在请求完成后向客户发送一个最终的结果。</td>\n</tr>\n<tr>\n<td><em><strong>200</strong></em></td>\n<td>这个是最常见的http状态码，表示服务器已经成功接受请求，并将返回客户端所请求的最终结果。</td>\n</tr>\n<tr>\n<td><em><strong>202</strong></em></td>\n<td>表示服务器已经接受了请求，但是还没有处理，而且这个请求最终会不会处理还不确定。</td>\n</tr>\n<tr>\n<td><em><strong>204</strong></em></td>\n<td>服务器成功处理了请求，但没有返回任何实体内容，可能会返回新的头部元信息。</td>\n</tr>\n<tr>\n<td><em><strong>301</strong></em></td>\n<td>客户端请求的页面已经永久移动到新的位置，当链接发生变化时，返回301代码告诉客户端连接的变化，客户端保存新的链接，并向新的链接发出请求，已返回请求结果。</td>\n</tr>\n<tr>\n<td><em><strong>404</strong></em></td>\n<td>请求失败，客户端请求的资源没有找到或者是不存在。</td>\n</tr>\n<tr>\n<td><em><strong>500</strong></em></td>\n<td>服务器遇到未知的错误，导致无法完成客户端当前的请求。</td>\n</tr>\n<tr>\n<td><em><strong>503</strong></em></td>\n<td>服务器由于临时的服务器过载或者是维护，无法解决当前的请求。</td>\n</tr>\n</tbody>\n</table>\n<p><a href="https://www.runoob.com/http/http-status-codes.html" target="_blank" rel="noopener noreferrer">参考<ExternalLinkIcon/></a></p>\n<hr>\n<h2 id="八、ajax如何使用" tabindex="-1"><a class="header-anchor" href="#八、ajax如何使用" aria-hidden="true">#</a> 八、Ajax如何使用</h2>\n<p>一个完整的AJAX请求包括五个步骤：\n具体来说，AJAX 包括以下几个步骤。</p>\n<ol>\n<li>\n<p>创建 XMLHttpRequest 对象，也就是创建一个异步调用对象</p>\n</li>\n<li>\n<p>创建一个新的 HTTP 请求，并指定该 HTTP 请求的方法、URL 及验证信息</p>\n</li>\n<li>\n<p>设置响应 HTTP 请求状态变化的函数</p>\n</li>\n<li>\n<p>发送 HTTP 请求</p>\n</li>\n<li>\n<p>获取异步调用返回的数据</p>\n</li>\n<li>\n<p>使用 JavaScript 和 DOM 实现局部刷新</p>\n</li>\n</ol>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token comment">// 创建可以请求的实例对象</span>\n<span class="token keyword">var</span> myAjax <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token comment">// 设置请求的url参数，这是准备工作</span>\nmyAjax<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">\'GET\'</span><span class="token punctuation">,</span> <span class="token string">\'https://autumnfish.cn/search?keywords="我们俩"\'</span> <span class="token punctuation">)</span>\n<span class="token comment">// 发送请求</span>\nmyAjax<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token comment">// 接收</span>\nmyAjax<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>myAjax<span class="token punctuation">.</span>readyState <span class="token operator">==</span> <span class="token number">4</span> <span class="token operator">&amp;&amp;</span> myAjax<span class="token punctuation">.</span>status <span class="token operator">==</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>myAjax<span class="token punctuation">.</span>responseText<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// JSON将字符串转换为对象</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p><a href="https://juejin.cn/post/6992525007716876325#heading-54" target="_blank" rel="noopener noreferrer">参考链接<ExternalLinkIcon/></a></p>\n<hr>\n<h2 id="九、下面代码中-a-在什么情况下会打印-1" tabindex="-1"><a class="header-anchor" href="#九、下面代码中-a-在什么情况下会打印-1" aria-hidden="true">#</a> 九、下面代码中 a 在什么情况下会打印 1？</h2>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token operator">?</span><span class="token punctuation">;</span>\n<span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n \tconso<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><blockquote>\n<p>答案解析 因为==会进行隐式类型转换 所以我们重写toString方法就可以了</p>\n</blockquote>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">i</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>\n  <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> a<span class="token punctuation">.</span>i<span class="token operator">++</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">if</span><span class="token punctuation">(</span> a <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">==</span> <span class="token number">3</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><hr>\n<h2 id="十、介绍下-bfc-及其应用" tabindex="-1"><a class="header-anchor" href="#十、介绍下-bfc-及其应用" aria-hidden="true">#</a> 十、介绍下 BFC 及其应用</h2>\n<p>BFC 就是块级格式上下文，是页面盒模型布局中的一种 CSS 渲染模式，相当于一个独立的容器，里面的元素和外部的元素相互不影响。<br>\n创建BFC 的方式有：</p>\n<p>下列方式会创建块格式化上下文：</p>\n<ul>\n<li>\n<p>html根元素（）</p>\n</li>\n<li>\n<p>float浮动（元素的 float 不是 none）</p>\n</li>\n<li>\n<p>绝对定位元素（元素的 position 为 absolute 或 fixed）</p>\n</li>\n<li>\n<p>行内块元素（元素的 display 为 inline-block）</p>\n</li>\n<li>\n<p>display 为表格布局、弹性元素（flex、inline-flex）、网格元素（grid、inline-grid）</p>\n</li>\n<li>\n<p>overflow 计算值(Computed)不为 visible 的块元素</p>\n</li>\n<li>\n<p>等。。。</p>\n</li>\n</ul>\n<p>BFC 主要的作用是：</p>\n<ol>\n<li>清除浮动</li>\n<li>防止同一 BFC 容器中的相邻元素间的外边距重叠问题</li>\n</ol>\n<p>BFC特性:</p>\n<ul>\n<li>\n<p>BFC元素的垂直方向上会发生边距重叠。</p>\n</li>\n<li>\n<p>BFC元素和浮动元素不会发生重叠。</p>\n</li>\n<li>\n<p>BFC在计算高度时会把浮动元素计算进去。</p>\n</li>\n<li>\n<p>BFC在页面是个独立的容器，里外元素互不影响。</p>\n</li>\n</ul>\n<hr>\n<h2 id="十一、对sort-的理解" tabindex="-1"><a class="header-anchor" href="#十一、对sort-的理解" aria-hidden="true">#</a> 十一、对sort()的理解</h2>\n<blockquote>\n<p>使用 sort() 对数组 [3, 15, 8, 29, 102, 22] 进行排序，输出结果</p>\n</blockquote>\n<p>答案:<strong>[102, 15, 22, 29, 3, 8]</strong></p>\n<p>解析:</p>\n<blockquote>\n<p>根据MDN上对Array.sort()的解释，<em><strong>默认的排序方法会将数组元素转换为字符串，然后比较字符串中字符的UTF-16编码顺序来进行排序</strong></em>。所以\'102\' 会排在 \'15\' 前面。</p>\n</blockquote>\n<p>如果要对数值进行升序排列：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">,</span> <span class="token number">102</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=></span> a <span class="token operator">-</span> b<span class="token punctuation">)</span> \n<span class="token comment">// [3, 8, 15, 22, 29, 102]</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><hr>\n<h2 id="十二、call、apply、bind的区别" tabindex="-1"><a class="header-anchor" href="#十二、call、apply、bind的区别" aria-hidden="true">#</a> 十二、call、apply、bind的区别</h2>\n<p>作用：</p>\n<blockquote>\n<p>改变函数执行时的上下文,其中call和apply是立即调用的</p>\n</blockquote>\n<ol>\n<li>cal、apply、bind必须通过函数来调用，第一个参数为对象，若第一个参数为null或者undefined，则指向window</li>\n<li>call和bind方法可以接收多个参数，apply方法只能接收2个参数，且第二个参数为数组或者伪数组</li>\n<li>call、apply、bind方法的调用：\n<ol>\n<li>call和apply方法没有返回值（即返回undefined）</li>\n<li>bind方法返回一个原函数的拷贝，并具有指定的this值和初始参数</li>\n</ol>\n</li>\n<li>call、apply、bind方法的调用：\n<ol>\n<li>call和apply是立即执行的</li>\n<li>bind返回值是一个函数，需要稍后再调用一下，才会执行。</li>\n</ol>\n</li>\n</ol>\n<p><a href="%E5%8F%82%E8%80%83%EF%BC%9Ahttps://segmentfault.com/a/1190000018017796">参考</a></p>\n<hr>\n<h2 id="十三、分析比较-opacity-0、visibility-hidden、display-none-优劣和适用场景。" tabindex="-1"><a class="header-anchor" href="#十三、分析比较-opacity-0、visibility-hidden、display-none-优劣和适用场景。" aria-hidden="true">#</a> 十三、分析比较 opacity: 0、visibility: hidden、display: none 优劣和适用场景。</h2>\n<p>总结一下：<br>\n<em><strong>结构</strong></em>：</p>\n<ul>\n<li>display:none: 会让元素完全从渲染树中消失，渲染的时候不占据任何空间, 不能点击，</li>\n<li>visibility: hidden:不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，不能点击</li>\n<li>opacity: 0: 不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，可以点击</li>\n</ul>\n<p><em><strong>继承</strong></em>：</p>\n<ul>\n<li>display: none和opacity: 0：是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示。</li>\n<li>visibility: hidden：是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显式。</li>\n</ul>\n<p><em><strong>性能</strong></em>：</p>\n<ul>\n<li>displaynone : 修改元素会造成文档回流,读屏器不会读取display: none元素内容，性能消耗较大</li>\n<li>visibility:hidden: 修改元素只会造成本元素的重绘,性能消耗较少读屏器读取visibility: hidden元素内容</li>\n<li>opacity: 0 ： 修改元素会造成重绘，性能消耗较少</li>\n</ul>\n<p><em><strong>联系</strong></em>：它们都能让元素不可见</p>\n<p><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/100" target="_blank" rel="noopener noreferrer">参考<ExternalLinkIcon/></a></p>\n<hr>\n<h2 id="十四、es6-代码转成-es5-代码的实现思路是什么" tabindex="-1"><a class="header-anchor" href="#十四、es6-代码转成-es5-代码的实现思路是什么" aria-hidden="true">#</a> 十四、ES6 代码转成 ES5 代码的实现思路是什么</h2>\n<p>Babel 是如何把 ES6 转成 ES5 呢<br>\n其大致分为三步：</p>\n<ol>\n<li>将代码字符串解析成抽象语法树，即所谓的 AST</li>\n<li>对 AST 进行处理，在这个阶段可以对 ES6 代码进行相应转换，即转成 ES5 代码</li>\n<li>根据处理后的 AST 再生成代码字符串</li>\n</ol>\n<blockquote>\n<p>将ES6的代码转换为AST语法树，然后再将ES6 AST转为ES5 AST，再将AST转为代码</p>\n</blockquote>\n<hr>\n<h2 id="十五、数组里面有10万个数据-取第一个元素和第10万个元素的时间相差多少" tabindex="-1"><a class="header-anchor" href="#十五、数组里面有10万个数据-取第一个元素和第10万个元素的时间相差多少" aria-hidden="true">#</a> 十五、数组里面有10万个数据，取第一个元素和第10万个元素的时间相差多少</h2>\n<ol>\n<li>脚本里面的数组不是真正的数组，用的Hash算法，所以读取时间是一致的；</li>\n<li>即便真正的数组，读取时间也是一致的，连续内存直接读就好了；</li>\n<li>只有对单向链表才有差异；</li>\n</ol>\n<hr>\n<h2 id="十六、vue-的父组件和子组件生命周期钩子执行顺序是什么" tabindex="-1"><a class="header-anchor" href="#十六、vue-的父组件和子组件生命周期钩子执行顺序是什么" aria-hidden="true">#</a> 十六、Vue 的父组件和子组件生命周期钩子执行顺序是什么</h2>\n<ol>\n<li>加载渲染过程<br>\n<strong>父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted</strong></li>\n<li>子组件更新过程<br>\n<strong>父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</strong></li>\n<li>父组件更新过程<br>\n<strong>父beforeUpdate-&gt;父updated</strong></li>\n<li>销毁过程<br>\n<strong>父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</strong></li>\n</ol>\n<p><em><strong>总结</strong></em>：从外到内，再从内到外</p>\n<hr>\n<h2 id="十七、import导入的模块" tabindex="-1"><a class="header-anchor" href="#十七、import导入的模块" aria-hidden="true">#</a> 十七、import导入的模块</h2>\n<blockquote>\n<p>import导入的模块是只读的：您不能修改导入的模块。只有导出它们的模块才能更改其值</p>\n</blockquote>\n<p><a href="https://github.com/lydiahallie/javascript-questions#57-whats-the-output" target="_blank" rel="noopener noreferrer">例题<ExternalLinkIcon/></a></p>\n<hr>\n<h2 id="十八、var、let-和-const" tabindex="-1"><a class="header-anchor" href="#十八、var、let-和-const" aria-hidden="true">#</a> 十八、var、let 和 const</h2>\n<ul>\n<li>\n<p><strong>var</strong>的话会直接在栈内存里预分配内存空间，然后等到实际语句执行的时候，再存储对应的变量，如果传的是引用类型，那么会在堆内存里开辟一个内存空间存储实际内容，栈内存会存储一个指向堆内存的指针</p>\n</li>\n<li>\n<p><strong>let</strong>的话，是不会在栈内存里预分配内存空间，而且在栈内存分配变量时，做一个检查，如果已经有相同变量名存在就会报错</p>\n</li>\n<li>\n<p><strong>const</strong>的话，也不会预分配内存空间，在栈内存分配变量时也会做同样的检查。不过const存储的变量是不可修改的，对于基本类型来说你无法修改定义的值，对于引用类型来说你无法修改栈内存里分配的指针，但是你可以修改指针指向的对象里面的属性</p>\n</li>\n</ul>\n<hr>\n<h2 id="十九、-object-steal-和object-freezze" tabindex="-1"><a class="header-anchor" href="#十九、-object-steal-和object-freezze" aria-hidden="true">#</a> 十九、 Object.steal()和Object.freezze()</h2>\n<ol>\n<li>O<strong>bject.steal()</strong>\n<ol>\n<li>\n<p>防止对象添加新属性或删除现有属性</p>\n</li>\n<li>\n<p>但仍可以修改现有属性的值</p>\n</li>\n</ol>\n</li>\n</ol>\n<p><a href="https://github.com/lydiahallie/javascript-questions#136-which-of-the-following-will-modify-the-person-object" target="_blank" rel="noopener noreferrer">例题<ExternalLinkIcon/></a></p>\n<ol start="2">\n<li><strong>Object.freeze()</strong>\n<ol>\n<li>\n<p>冻结一个对象，不可添加、修改、删除任何属性</p>\n</li>\n<li>\n<p>但只是浅冻结对象，只是对对象的直接属性进行了冻结，若属性中又另一个对象，则可对这个对象进行修改</p>\n</li>\n</ol>\n</li>\n</ol>\n<p><a href="https://github.com/lydiahallie/javascript-questions#137-which-of-the-following-will-modify-the-person-object" target="_blank" rel="noopener noreferrer">例题<ExternalLinkIcon/></a></p>\n<hr>\n<div style="font-weight:700; text-align:center; padding-top:20px;">最后更新时间：2022.02.12</div>',date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:"/Navigation/interview.html",pathLocale:"/",permalink:null,routeMeta:{},slug:"interview",filePath:"C:/Users/mi/Desktop/我的博客/docs/Navigation/interview.md",filePathRelative:"Navigation/interview.md",componentFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/Navigation/interview.html.vue",componentFilePathRelative:"pages/Navigation/interview.html.vue",componentFileChunkName:"v-39cc4c5a",dataFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/Navigation/interview.html.js",dataFilePathRelative:"pages/Navigation/interview.html.js",dataFileChunkName:"v-39cc4c5a",htmlFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/dist/Navigation/interview.html",htmlFilePathRelative:"Navigation/interview.html"},{data:{key:"v-0359f486",path:"/Navigation/interview2.html",title:"interview-2",lang:"zh-CN",frontmatter:{date:"2022/2/13 11:08",coverUrl:"http://cdn-ali-img-shstaticbz.shanhutech.cn/bizhi/staticwp/202107/0ee3a54e877205a6bd29ca2d23f44b43--2771443509.jpg",sticky:!0,keyword:"面试表达",description:"interview expression",title:"interview-2",tag:["笔记"],categories:["面试表达"]},excerpt:"",headers:[{level:2,title:"一、什么是 Data URL",slug:"一、什么是-data-url",children:[]},{level:2,title:"二、伪类与伪元素有什么区别",slug:"二、伪类与伪元素有什么区别",children:[]},{level:2,title:"三、如何实现表格单双行条纹样式",slug:"三、如何实现表格单双行条纹样式",children:[]},{level:2,title:"四、prefetch 与 preload 的区别是什么",slug:"四、prefetch-与-preload-的区别是什么",children:[]},{level:2,title:"五、如何实现页面文本不可复制",slug:"五、如何实现页面文本不可复制",children:[]},{level:2,title:"六、js 代码压缩",slug:"六、js-代码压缩",children:[]},{level:2,title:"七、package.json 指南",slug:"七、package-json-指南",children:[]},{level:2,title:"八、CSS 选择器优先级特异性权重",slug:"八、css-选择器优先级特异性权重",children:[]}],git:{updatedTime:null,contributors:[]}},key:"v-0359f486",path:"/Navigation/interview2.html",title:"interview-2",lang:"zh-CN",frontmatter:{date:"2022/2/13 11:08",coverUrl:"http://cdn-ali-img-shstaticbz.shanhutech.cn/bizhi/staticwp/202107/0ee3a54e877205a6bd29ca2d23f44b43--2771443509.jpg",sticky:!0,keyword:"面试表达",description:"interview expression",title:"interview-2",tag:["笔记"],categories:["面试表达"]},excerpt:"",headers:[{level:2,title:"一、什么是 Data URL",slug:"一、什么是-data-url",children:[]},{level:2,title:"二、伪类与伪元素有什么区别",slug:"二、伪类与伪元素有什么区别",children:[]},{level:2,title:"三、如何实现表格单双行条纹样式",slug:"三、如何实现表格单双行条纹样式",children:[]},{level:2,title:"四、prefetch 与 preload 的区别是什么",slug:"四、prefetch-与-preload-的区别是什么",children:[]},{level:2,title:"五、如何实现页面文本不可复制",slug:"五、如何实现页面文本不可复制",children:[]},{level:2,title:"六、js 代码压缩",slug:"六、js-代码压缩",children:[]},{level:2,title:"七、package.json 指南",slug:"七、package-json-指南",children:[]},{level:2,title:"八、CSS 选择器优先级特异性权重",slug:"八、css-选择器优先级特异性权重",children:[]}],content:'\r\n## 一、什么是 Data URL\r\n\r\n[参考链接](https://q.shanyue.tech/fe/html/478.html)\r\n\r\n---\r\n\r\n## 二、伪类与伪元素有什么区别\r\n1. 伪类使用单冒号，而伪元素使用双冒号。如 **:hover** 是伪类，**::before** 是伪元素\r\n2. 伪元素会在文档流生成一个新的元素，并且可以使用 content 属性设置内容\r\n\r\n[参考链接](https://www.cnblogs.com/ammyben/p/8012747.html)\r\n\r\n---\r\n\r\n## 三、如何实现表格单双行条纹样式\r\n\r\n[参考链接](https://q.shanyue.tech/fe/css/309.html)\r\n\r\n---\r\n\r\n## 四、prefetch 与 preload 的区别是什么\r\n\r\n[参考链接](https://q.shanyue.tech/fe/dom/286.html)\r\n\r\n---\r\n\r\n## 五、如何实现页面文本不可复制\r\n\r\n[参考链接](https://q.shanyue.tech/fe/dom/454.html)\r\n\r\n---\r\n\r\n## 六、js 代码压缩\r\n\r\n[参考链接](https://q.shanyue.tech/engineering/138.html)\r\n\r\n---\r\n\r\n## 七、package.json 指南\r\n\r\n[参考链接](http://nodejs.cn/learn/the-package-json-guide)\r\n\r\n---\r\n\r\n## 八、CSS 选择器优先级特异性权重\r\n\r\n[参考链接](https://zxuqian.cn/css-selector-specificity/)\r\n\r\n---\r\n\r\n<div style="font-weight:700; text-align:center; padding-top:20px;">最后更新时间：2022.02.13</div>',contentRendered:'<h2 id="一、什么是-data-url" tabindex="-1"><a class="header-anchor" href="#一、什么是-data-url" aria-hidden="true">#</a> 一、什么是 Data URL</h2>\n<p><a href="https://q.shanyue.tech/fe/html/478.html" target="_blank" rel="noopener noreferrer">参考链接<ExternalLinkIcon/></a></p>\n<hr>\n<h2 id="二、伪类与伪元素有什么区别" tabindex="-1"><a class="header-anchor" href="#二、伪类与伪元素有什么区别" aria-hidden="true">#</a> 二、伪类与伪元素有什么区别</h2>\n<ol>\n<li>伪类使用单冒号，而伪元素使用双冒号。如 <strong>:hover</strong> 是伪类，<strong>::before</strong> 是伪元素</li>\n<li>伪元素会在文档流生成一个新的元素，并且可以使用 content 属性设置内容</li>\n</ol>\n<p><a href="https://www.cnblogs.com/ammyben/p/8012747.html" target="_blank" rel="noopener noreferrer">参考链接<ExternalLinkIcon/></a></p>\n<hr>\n<h2 id="三、如何实现表格单双行条纹样式" tabindex="-1"><a class="header-anchor" href="#三、如何实现表格单双行条纹样式" aria-hidden="true">#</a> 三、如何实现表格单双行条纹样式</h2>\n<p><a href="https://q.shanyue.tech/fe/css/309.html" target="_blank" rel="noopener noreferrer">参考链接<ExternalLinkIcon/></a></p>\n<hr>\n<h2 id="四、prefetch-与-preload-的区别是什么" tabindex="-1"><a class="header-anchor" href="#四、prefetch-与-preload-的区别是什么" aria-hidden="true">#</a> 四、prefetch 与 preload 的区别是什么</h2>\n<p><a href="https://q.shanyue.tech/fe/dom/286.html" target="_blank" rel="noopener noreferrer">参考链接<ExternalLinkIcon/></a></p>\n<hr>\n<h2 id="五、如何实现页面文本不可复制" tabindex="-1"><a class="header-anchor" href="#五、如何实现页面文本不可复制" aria-hidden="true">#</a> 五、如何实现页面文本不可复制</h2>\n<p><a href="https://q.shanyue.tech/fe/dom/454.html" target="_blank" rel="noopener noreferrer">参考链接<ExternalLinkIcon/></a></p>\n<hr>\n<h2 id="六、js-代码压缩" tabindex="-1"><a class="header-anchor" href="#六、js-代码压缩" aria-hidden="true">#</a> 六、js 代码压缩</h2>\n<p><a href="https://q.shanyue.tech/engineering/138.html" target="_blank" rel="noopener noreferrer">参考链接<ExternalLinkIcon/></a></p>\n<hr>\n<h2 id="七、package-json-指南" tabindex="-1"><a class="header-anchor" href="#七、package-json-指南" aria-hidden="true">#</a> 七、package.json 指南</h2>\n<p><a href="http://nodejs.cn/learn/the-package-json-guide" target="_blank" rel="noopener noreferrer">参考链接<ExternalLinkIcon/></a></p>\n<hr>\n<h2 id="八、css-选择器优先级特异性权重" tabindex="-1"><a class="header-anchor" href="#八、css-选择器优先级特异性权重" aria-hidden="true">#</a> 八、CSS 选择器优先级特异性权重</h2>\n<p><a href="https://zxuqian.cn/css-selector-specificity/" target="_blank" rel="noopener noreferrer">参考链接<ExternalLinkIcon/></a></p>\n<hr>\n<div style="font-weight:700; text-align:center; padding-top:20px;">最后更新时间：2022.02.13</div>',date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:"/Navigation/interview2.html",pathLocale:"/",permalink:null,routeMeta:{},slug:"interview2",filePath:"C:/Users/mi/Desktop/我的博客/docs/Navigation/interview2.md",filePathRelative:"Navigation/interview2.md",componentFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/Navigation/interview2.html.vue",componentFilePathRelative:"pages/Navigation/interview2.html.vue",componentFileChunkName:"v-0359f486",dataFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/Navigation/interview2.html.js",dataFilePathRelative:"pages/Navigation/interview2.html.js",dataFileChunkName:"v-0359f486",htmlFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/dist/Navigation/interview2.html",htmlFilePathRelative:"Navigation/interview2.html"},{data:{key:"v-d40e49ba",path:"/Navigation/navigation.html",title:"面试知识导航",lang:"zh-CN",frontmatter:{date:"2022/1/29 20:08",coverUrl:"http://cdn-ali-img-shstaticbz.shanhutech.cn/bizhi/staticwp/202201/bb2418e08b46b481c0788d639b762b83--2124794725.jpg",sticky:!0,keyword:"导航,回流重绘",description:"面试知识导航",title:"面试知识导航",tag:["笔记"],categories:["面试知识导航"]},excerpt:"",headers:[{level:2,title:"一、你真的了解回流和重绘吗",slug:"一、你真的了解回流和重绘吗",children:[]},{level:2,title:"二、重新认识构造函数、原型和原型链",slug:"二、重新认识构造函数、原型和原型链",children:[]},{level:2,title:"三、改造下面的代码，使之输出0 - 9，写出你能想到的所有解法。",slug:"三、改造下面的代码-使之输出0-9-写出你能想到的所有解法。",children:[]},{level:2,title:"四、怎么让一个 div 水平垂直居中",slug:"四、怎么让一个-div-水平垂直居中",children:[]},{level:2,title:"五、箭头函数与普通函数（function）的区别是什么？构造函数（function）可以使用 new 生成实例，那么箭头函数可以吗？为什么？",slug:"五、箭头函数与普通函数-function-的区别是什么-构造函数-function-可以使用-new-生成实例-那么箭头函数可以吗-为什么",children:[]},{level:2,title:"六、介绍下 BFC、IFC、GFC 和 FFC",slug:"六、介绍下-bfc、ifc、gfc-和-ffc",children:[]},{level:2,title:"七、常见的DOM操作",slug:"七、常见的dom操作",children:[]},{level:2,title:"八、前端项目中常见的报错类型汇总",slug:"八、前端项目中常见的报错类型汇总",children:[]},{level:2,title:"九、分清splice、slice和split",slug:"九、分清splice、slice和split",children:[]},{level:2,title:"十、flex 的三个参数 flex:1 0 auto",slug:"十、flex-的三个参数-flex-1-0-auto",children:[]},{level:2,title:"十一、防抖和节流",slug:"十一、防抖和节流",children:[]},{level:2,title:"十二、数组扁平化",slug:"十二、数组扁平化",children:[]}],git:{updatedTime:null,contributors:[]}},key:"v-d40e49ba",path:"/Navigation/navigation.html",title:"面试知识导航",lang:"zh-CN",frontmatter:{date:"2022/1/29 20:08",coverUrl:"http://cdn-ali-img-shstaticbz.shanhutech.cn/bizhi/staticwp/202201/bb2418e08b46b481c0788d639b762b83--2124794725.jpg",sticky:!0,keyword:"导航,回流重绘",description:"面试知识导航",title:"面试知识导航",tag:["笔记"],categories:["面试知识导航"]},excerpt:"",headers:[{level:2,title:"一、你真的了解回流和重绘吗",slug:"一、你真的了解回流和重绘吗",children:[]},{level:2,title:"二、重新认识构造函数、原型和原型链",slug:"二、重新认识构造函数、原型和原型链",children:[]},{level:2,title:"三、改造下面的代码，使之输出0 - 9，写出你能想到的所有解法。",slug:"三、改造下面的代码-使之输出0-9-写出你能想到的所有解法。",children:[]},{level:2,title:"四、怎么让一个 div 水平垂直居中",slug:"四、怎么让一个-div-水平垂直居中",children:[]},{level:2,title:"五、箭头函数与普通函数（function）的区别是什么？构造函数（function）可以使用 new 生成实例，那么箭头函数可以吗？为什么？",slug:"五、箭头函数与普通函数-function-的区别是什么-构造函数-function-可以使用-new-生成实例-那么箭头函数可以吗-为什么",children:[]},{level:2,title:"六、介绍下 BFC、IFC、GFC 和 FFC",slug:"六、介绍下-bfc、ifc、gfc-和-ffc",children:[]},{level:2,title:"七、常见的DOM操作",slug:"七、常见的dom操作",children:[]},{level:2,title:"八、前端项目中常见的报错类型汇总",slug:"八、前端项目中常见的报错类型汇总",children:[]},{level:2,title:"九、分清splice、slice和split",slug:"九、分清splice、slice和split",children:[]},{level:2,title:"十、flex 的三个参数 flex:1 0 auto",slug:"十、flex-的三个参数-flex-1-0-auto",children:[]},{level:2,title:"十一、防抖和节流",slug:"十一、防抖和节流",children:[]},{level:2,title:"十二、数组扁平化",slug:"十二、数组扁平化",children:[]}],content:'# 面试知识导航\r\n\r\n## 一、你真的了解回流和重绘吗\r\n- [参考链接](https://github.com/chenjigeng/blog/issues/4)\r\n\r\n---\r\n\r\n## 二、重新认识构造函数、原型和原型链\r\n- [参考链接](https://github.com/yygmind/blog/issues/32)\r\n\r\n---\r\n\r\n## 三、改造下面的代码，使之输出0 - 9，写出你能想到的所有解法。\r\n\r\n```js\r\nfor (var i = 0; i< 10; i++){\r\n\tsetTimeout(() => {\r\n\t\tconsole.log(i);\r\n    }, 1000)\r\n}\r\n```\r\n- [解决办法汇总](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/43)\r\n\r\n---\r\n\r\n## 四、怎么让一个 div 水平垂直居中\r\n[参考链接](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/92)\r\n\r\n---\r\n\r\n## 五、箭头函数与普通函数（function）的区别是什么？构造函数（function）可以使用 new 生成实例，那么箭头函数可以吗？为什么？\r\n\r\n[参考链接](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/101)\r\n\r\n---\r\n\r\n## 六、介绍下 BFC、IFC、GFC 和 FFC\r\n[参考链接](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/122)\r\n\r\n---\r\n\r\n##  七、常见的DOM操作\r\n[参考链接](https://juejin.cn/post/6940945178899251230#heading-67)\r\n\r\n---\r\n\r\n## 八、前端项目中常见的报错类型汇总\r\n[参考链接](https://juejin.cn/post/6844903893432795149)\r\n\r\n---\r\n\r\n## 九、分清splice、slice和split\r\n[参考链接](https://juejin.cn/post/7025089834620452894)\r\n[代码](https://www.iewganfil.top/A/PDF/splice.pdf)\r\n\r\n--- \r\n\r\n## 十、flex 的三个参数 flex:1 0 auto\r\n[参考链接](https://www.jianshu.com/p/d064282ec5cd)\r\n\r\n---\r\n\r\n## 十一、防抖和节流\r\n[参考链接](https://juejin.cn/post/7050105366931046436)\r\n\r\n---\r\n\r\n## 十二、数组扁平化\r\n[参考链接](https://juejin.cn/post/7051944992700858382)\r\n\r\n---\r\n\r\n<div style="font-weight:700; text-align:center; padding-top:20px;">最后更新时间：2022.02.13</div>\r\n',contentRendered:'<h1 id="面试知识导航" tabindex="-1"><a class="header-anchor" href="#面试知识导航" aria-hidden="true">#</a> 面试知识导航</h1>\n<h2 id="一、你真的了解回流和重绘吗" tabindex="-1"><a class="header-anchor" href="#一、你真的了解回流和重绘吗" aria-hidden="true">#</a> 一、你真的了解回流和重绘吗</h2>\n<ul>\n<li><a href="https://github.com/chenjigeng/blog/issues/4" target="_blank" rel="noopener noreferrer">参考链接<ExternalLinkIcon/></a></li>\n</ul>\n<hr>\n<h2 id="二、重新认识构造函数、原型和原型链" tabindex="-1"><a class="header-anchor" href="#二、重新认识构造函数、原型和原型链" aria-hidden="true">#</a> 二、重新认识构造函数、原型和原型链</h2>\n<ul>\n<li><a href="https://github.com/yygmind/blog/issues/32" target="_blank" rel="noopener noreferrer">参考链接<ExternalLinkIcon/></a></li>\n</ul>\n<hr>\n<h2 id="三、改造下面的代码-使之输出0-9-写出你能想到的所有解法。" tabindex="-1"><a class="header-anchor" href="#三、改造下面的代码-使之输出0-9-写出你能想到的所有解法。" aria-hidden="true">#</a> 三、改造下面的代码，使之输出0 - 9，写出你能想到的所有解法。</h2>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n\t<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n\t\tconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul>\n<li><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/43" target="_blank" rel="noopener noreferrer">解决办法汇总<ExternalLinkIcon/></a></li>\n</ul>\n<hr>\n<h2 id="四、怎么让一个-div-水平垂直居中" tabindex="-1"><a class="header-anchor" href="#四、怎么让一个-div-水平垂直居中" aria-hidden="true">#</a> 四、怎么让一个 div 水平垂直居中</h2>\n<p><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/92" target="_blank" rel="noopener noreferrer">参考链接<ExternalLinkIcon/></a></p>\n<hr>\n<h2 id="五、箭头函数与普通函数-function-的区别是什么-构造函数-function-可以使用-new-生成实例-那么箭头函数可以吗-为什么" tabindex="-1"><a class="header-anchor" href="#五、箭头函数与普通函数-function-的区别是什么-构造函数-function-可以使用-new-生成实例-那么箭头函数可以吗-为什么" aria-hidden="true">#</a> 五、箭头函数与普通函数（function）的区别是什么？构造函数（function）可以使用 new 生成实例，那么箭头函数可以吗？为什么？</h2>\n<p><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/101" target="_blank" rel="noopener noreferrer">参考链接<ExternalLinkIcon/></a></p>\n<hr>\n<h2 id="六、介绍下-bfc、ifc、gfc-和-ffc" tabindex="-1"><a class="header-anchor" href="#六、介绍下-bfc、ifc、gfc-和-ffc" aria-hidden="true">#</a> 六、介绍下 BFC、IFC、GFC 和 FFC</h2>\n<p><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/122" target="_blank" rel="noopener noreferrer">参考链接<ExternalLinkIcon/></a></p>\n<hr>\n<h2 id="七、常见的dom操作" tabindex="-1"><a class="header-anchor" href="#七、常见的dom操作" aria-hidden="true">#</a> 七、常见的DOM操作</h2>\n<p><a href="https://juejin.cn/post/6940945178899251230#heading-67" target="_blank" rel="noopener noreferrer">参考链接<ExternalLinkIcon/></a></p>\n<hr>\n<h2 id="八、前端项目中常见的报错类型汇总" tabindex="-1"><a class="header-anchor" href="#八、前端项目中常见的报错类型汇总" aria-hidden="true">#</a> 八、前端项目中常见的报错类型汇总</h2>\n<p><a href="https://juejin.cn/post/6844903893432795149" target="_blank" rel="noopener noreferrer">参考链接<ExternalLinkIcon/></a></p>\n<hr>\n<h2 id="九、分清splice、slice和split" tabindex="-1"><a class="header-anchor" href="#九、分清splice、slice和split" aria-hidden="true">#</a> 九、分清splice、slice和split</h2>\n<p><a href="https://juejin.cn/post/7025089834620452894" target="_blank" rel="noopener noreferrer">参考链接<ExternalLinkIcon/></a>\n<a href="https://www.iewganfil.top/A/PDF/splice.pdf" target="_blank" rel="noopener noreferrer">代码<ExternalLinkIcon/></a></p>\n<hr>\n<h2 id="十、flex-的三个参数-flex-1-0-auto" tabindex="-1"><a class="header-anchor" href="#十、flex-的三个参数-flex-1-0-auto" aria-hidden="true">#</a> 十、flex 的三个参数 flex:1 0 auto</h2>\n<p><a href="https://www.jianshu.com/p/d064282ec5cd" target="_blank" rel="noopener noreferrer">参考链接<ExternalLinkIcon/></a></p>\n<hr>\n<h2 id="十一、防抖和节流" tabindex="-1"><a class="header-anchor" href="#十一、防抖和节流" aria-hidden="true">#</a> 十一、防抖和节流</h2>\n<p><a href="https://juejin.cn/post/7050105366931046436" target="_blank" rel="noopener noreferrer">参考链接<ExternalLinkIcon/></a></p>\n<hr>\n<h2 id="十二、数组扁平化" tabindex="-1"><a class="header-anchor" href="#十二、数组扁平化" aria-hidden="true">#</a> 十二、数组扁平化</h2>\n<p><a href="https://juejin.cn/post/7051944992700858382" target="_blank" rel="noopener noreferrer">参考链接<ExternalLinkIcon/></a></p>\n<hr>\n<div style="font-weight:700; text-align:center; padding-top:20px;">最后更新时间：2022.02.13</div>\n',date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:"/Navigation/navigation.html",pathLocale:"/",permalink:null,routeMeta:{},slug:"navigation",filePath:"C:/Users/mi/Desktop/我的博客/docs/Navigation/navigation.md",filePathRelative:"Navigation/navigation.md",componentFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/Navigation/navigation.html.vue",componentFilePathRelative:"pages/Navigation/navigation.html.vue",componentFileChunkName:"v-d40e49ba",dataFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/Navigation/navigation.html.js",dataFilePathRelative:"pages/Navigation/navigation.html.js",dataFileChunkName:"v-d40e49ba",htmlFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/dist/Navigation/navigation.html",htmlFilePathRelative:"Navigation/navigation.html"},{data:{key:"v-af0475ae",path:"/Navigation/PDF.html",title:"PDF导航",lang:"zh-CN",frontmatter:{date:"2022/1/28 16:08",coverUrl:"http://cdn-ali-img-shstaticbz.shanhutech.cn/bizhi/staticwp/202107/0ee3a54e877205a6bd29ca2d23f44b43--2771443509.jpg",sticky:!0,keyword:null,description:"PDF导航",title:"PDF导航",tag:["PDF"],categories:["PDF"]},excerpt:"",headers:[{level:2,title:"前端js篇",slug:"前端js篇",children:[]},{level:2,title:"前端网络篇",slug:"前端网络篇",children:[]},{level:2,title:"前端面试小书",slug:"前端面试小书",children:[]},{level:2,title:"面试题精选大全",slug:"面试题精选大全",children:[]},{level:2,title:"算法",slug:"算法",children:[]}],git:{updatedTime:null,contributors:[]}},key:"v-af0475ae",path:"/Navigation/PDF.html",title:"PDF导航",lang:"zh-CN",frontmatter:{date:"2022/1/28 16:08",coverUrl:"http://cdn-ali-img-shstaticbz.shanhutech.cn/bizhi/staticwp/202107/0ee3a54e877205a6bd29ca2d23f44b43--2771443509.jpg",sticky:!0,keyword:null,description:"PDF导航",title:"PDF导航",tag:["PDF"],categories:["PDF"]},excerpt:"",headers:[{level:2,title:"前端js篇",slug:"前端js篇",children:[]},{level:2,title:"前端网络篇",slug:"前端网络篇",children:[]},{level:2,title:"前端面试小书",slug:"前端面试小书",children:[]},{level:2,title:"面试题精选大全",slug:"面试题精选大全",children:[]},{level:2,title:"算法",slug:"算法",children:[]}],content:'\r\n## 前端js篇\r\n[PDF链接](https://www.iewganfil.top/A/Books/%E5%89%8D%E7%AB%AFJS%E7%AF%87.pdf)\r\n\r\n---\r\n\r\n## 前端网络篇\r\n[PDF链接](https://www.iewganfil.top/A/Books/%E5%89%8D%E7%AB%AF%E7%BD%91%E7%BB%9C%E7%AF%87.pdf)\r\n\r\n---\r\n\r\n## 前端面试小书\r\n[PDF链接](https://www.iewganfil.top/A/Books/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%B0%8F%E4%B9%A6.pdf)\r\n\r\n---\r\n\r\n## 面试题精选大全\r\n[PDF链接](https://www.iewganfil.top/A/Books/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89%E5%A4%A7%E5%85%A8.pdf)\r\n\r\n---\r\n\r\n## 算法\r\n[PDF链接](https://www.iewganfil.top/A/Books/%E7%AE%97%E6%B3%95.pdf)\r\n\r\n--- \r\n\r\n<div style="font-weight:700; text-align:center; padding-top:20px;">最后更新时间：2022.02.14</div>\r\n',contentRendered:'<h2 id="前端js篇" tabindex="-1"><a class="header-anchor" href="#前端js篇" aria-hidden="true">#</a> 前端js篇</h2>\n<p><a href="https://www.iewganfil.top/A/Books/%E5%89%8D%E7%AB%AFJS%E7%AF%87.pdf" target="_blank" rel="noopener noreferrer">PDF链接<ExternalLinkIcon/></a></p>\n<hr>\n<h2 id="前端网络篇" tabindex="-1"><a class="header-anchor" href="#前端网络篇" aria-hidden="true">#</a> 前端网络篇</h2>\n<p><a href="https://www.iewganfil.top/A/Books/%E5%89%8D%E7%AB%AF%E7%BD%91%E7%BB%9C%E7%AF%87.pdf" target="_blank" rel="noopener noreferrer">PDF链接<ExternalLinkIcon/></a></p>\n<hr>\n<h2 id="前端面试小书" tabindex="-1"><a class="header-anchor" href="#前端面试小书" aria-hidden="true">#</a> 前端面试小书</h2>\n<p><a href="https://www.iewganfil.top/A/Books/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%B0%8F%E4%B9%A6.pdf" target="_blank" rel="noopener noreferrer">PDF链接<ExternalLinkIcon/></a></p>\n<hr>\n<h2 id="面试题精选大全" tabindex="-1"><a class="header-anchor" href="#面试题精选大全" aria-hidden="true">#</a> 面试题精选大全</h2>\n<p><a href="https://www.iewganfil.top/A/Books/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89%E5%A4%A7%E5%85%A8.pdf" target="_blank" rel="noopener noreferrer">PDF链接<ExternalLinkIcon/></a></p>\n<hr>\n<h2 id="算法" tabindex="-1"><a class="header-anchor" href="#算法" aria-hidden="true">#</a> 算法</h2>\n<p><a href="https://www.iewganfil.top/A/Books/%E7%AE%97%E6%B3%95.pdf" target="_blank" rel="noopener noreferrer">PDF链接<ExternalLinkIcon/></a></p>\n<hr>\n<div style="font-weight:700; text-align:center; padding-top:20px;">最后更新时间：2022.02.14</div>\n',date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:"/Navigation/PDF.html",pathLocale:"/",permalink:null,routeMeta:{},slug:"PDF",filePath:"C:/Users/mi/Desktop/我的博客/docs/Navigation/PDF.md",filePathRelative:"Navigation/PDF.md",componentFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/Navigation/PDF.html.vue",componentFilePathRelative:"pages/Navigation/PDF.html.vue",componentFileChunkName:"v-af0475ae",dataFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/Navigation/PDF.html.js",dataFilePathRelative:"pages/Navigation/PDF.html.js",dataFileChunkName:"v-af0475ae",htmlFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/dist/Navigation/PDF.html",htmlFilePathRelative:"Navigation/PDF.html"},{data:{key:"v-7ffc659c",path:"/study/study1.html",title:"扁平化",lang:"zh-CN",frontmatter:{date:"2022/1/20 20:23",coverUrl:"http://cdn-ali-img-shstaticbz.shanhutech.cn/bizhi/staticwp/202112/4df6635c747bc083c7f159628e545666--2426815410.jpg",sticky:!0,keyword:"设置keyword,设置keyword,设置keyword,设置keyword",description:"数组扁平化且删除重复数据",title:"扁平化",tag:["面试题"],categories:["Javascript"]},excerpt:"",headers:[{level:2,title:"实现方法",slug:"实现方法",children:[{level:3,title:"扩展：手写flat",slug:"扩展-手写flat",children:[]}]}],git:{updatedTime:1642771259e3,contributors:[{name:"iewgnafil",email:"1519467168@qq.com",commits:2}]}},key:"v-7ffc659c",path:"/study/study1.html",title:"扁平化",lang:"zh-CN",frontmatter:{date:"2022/1/20 20:23",coverUrl:"http://cdn-ali-img-shstaticbz.shanhutech.cn/bizhi/staticwp/202112/4df6635c747bc083c7f159628e545666--2426815410.jpg",sticky:!0,keyword:"设置keyword,设置keyword,设置keyword,设置keyword",description:"数组扁平化且删除重复数据",title:"扁平化",tag:["面试题"],categories:["Javascript"]},excerpt:"",headers:[{level:2,title:"实现方法",slug:"实现方法",children:[{level:3,title:"扩展：手写flat",slug:"扩展-手写flat",children:[]}]}],content:"\r\n# 题目示例：\r\n已知如下数组：\r\n\r\n\r\n```js\r\nvar arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];\r\n```\r\n编写一个程序将数组扁平化并去除其中重复部分数据，最终得到一个升序且不重复的数组。\r\n## 实现方法\r\n\r\n```js\r\nArray.from(new Set(arr.flat(`Infinity`))).sort((a,b)=>{ return a-b})\r\n```\r\n- ` flat()  ` 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。`flat`的语法：\r\n> var newArray = arr.flat([depth])\\\r\n> `depth` 指定要提取嵌套数组的结构深度，默认值为 1。\r\n- 全局属性 `Infinity` 是一个数值，表示无穷大。\r\n- `Set`中的元素只会**出现一次**，即 Set 中的元素是唯一的。\r\n- ` Array.from()  ` 方法对一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。\r\n- ` sort()  ` 对数组的元素进行排序，并返回数组。\r\n### 扩展：手写flat\r\n此处仅列举几种简单易懂的方法：\\\r\n\\\r\n`instanceof`递归实现：\r\n```js\r\nfunction myflat1(arr){\r\n    let res = []\r\n    function bp(arr)  {\r\n        let len = arr.length\r\n        for(let i = 0;i < len; i++){\r\n            if( arr[i] instanceof Array){     // 判断该元素是否为数组\r\n                let a = [...arr[i]]           // 如果是数组  对其进行结构  再进行递归\r\n                bp(a)\r\n            }else{\r\n                res.push(arr[i])            // 元素不为数组时 push到res数组里\r\n            }\r\n        }\r\n    }\r\n    bp(arr)\r\n    return res\r\n}\r\n```\r\n转字符串切割：\r\n\r\n```js\r\nfunction myflat2(arr){\r\n    arr = arr.toString()         // 将数组进行字符串转换\r\n    arr = arr.split(',')         // split()方法将字符串进行分割成子字符串数组，以一个指定的分割字串来决定每个拆分的位置。 \r\n    for(let i = 0,len = arr.length;i < len; i++){ \r\n        arr[i] = Number(arr[i])  // 将字符串数组的元素转换成Number类型\r\n    }\r\n    return arr\r\n}\r\n```\r\n基于`Array.isArray`的`while`循环\r\n\r\n```js\r\nfunction myflat3(arr) {\r\n    while (arr.some(Array.isArray)) {     \r\n        // Array.isArray() 用于确定传递的值是否是一个Array  \r\n        //some() 方法测试数组中是不是至少有1个元素通过了被提供的函数测试\r\n        arr = [].concat(...arr)  \r\n    }\r\n    return arr\r\n}\r\n```",contentRendered:'<h1 id="题目示例" tabindex="-1"><a class="header-anchor" href="#题目示例" aria-hidden="true">#</a> 题目示例：</h1>\n<p>已知如下数组：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">]</span> <span class="token punctuation">]</span> <span class="token punctuation">]</span> <span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>编写一个程序将数组扁平化并去除其中重复部分数据，最终得到一个升序且不重复的数组。</p>\n<h2 id="实现方法" tabindex="-1"><a class="header-anchor" href="#实现方法" aria-hidden="true">#</a> 实现方法</h2>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code>Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">flat</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Infinity</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span>b</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">{</span> <span class="token keyword">return</span> a<span class="token operator">-</span>b<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><ul>\n<li><code>flat() </code> 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。<code>flat</code>的语法：</li>\n</ul>\n<blockquote>\n<p>var newArray = arr.flat([depth])<br>\n<code>depth</code> 指定要提取嵌套数组的结构深度，默认值为 1。</p>\n</blockquote>\n<ul>\n<li>全局属性 <code>Infinity</code> 是一个数值，表示无穷大。</li>\n<li><code>Set</code>中的元素只会<strong>出现一次</strong>，即 Set 中的元素是唯一的。</li>\n<li><code>Array.from() </code> 方法对一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。</li>\n<li><code>sort() </code> 对数组的元素进行排序，并返回数组。</li>\n</ul>\n<h3 id="扩展-手写flat" tabindex="-1"><a class="header-anchor" href="#扩展-手写flat" aria-hidden="true">#</a> 扩展：手写flat</h3>\n<p>此处仅列举几种简单易懂的方法：<br>\n<br>\n<code>instanceof</code>递归实现：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">myflat1</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>\n    <span class="token keyword">function</span> <span class="token function">bp</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>\n        <span class="token keyword">let</span> len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length\n        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n            <span class="token keyword">if</span><span class="token punctuation">(</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token comment">// 判断该元素是否为数组</span>\n                <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span>           <span class="token comment">// 如果是数组  对其进行结构  再进行递归</span>\n                <span class="token function">bp</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>\n            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>\n                res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token comment">// 元素不为数组时 push到res数组里</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n    <span class="token function">bp</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>\n    <span class="token keyword">return</span> res\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>转字符串切割：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">myflat2</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    arr <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token comment">// 将数组进行字符串转换</span>\n    arr <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">\',\'</span><span class="token punctuation">)</span>         <span class="token comment">// split()方法将字符串进行分割成子字符串数组，以一个指定的分割字串来决定每个拆分的位置。 </span>\n    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span> \n        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">Number</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment">// 将字符串数组的元素转换成Number类型</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">return</span> arr\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>基于<code>Array.isArray</code>的<code>while</code>循环</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">myflat3</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">while</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">some</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span>isArray<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     \n        <span class="token comment">// Array.isArray() 用于确定传递的值是否是一个Array  </span>\n        <span class="token comment">//some() 方法测试数组中是不是至少有1个元素通过了被提供的函数测试</span>\n        arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token operator">...</span>arr<span class="token punctuation">)</span>  \n    <span class="token punctuation">}</span>\n    <span class="token keyword">return</span> arr\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div>',date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:"/study/study1.html",pathLocale:"/",permalink:null,routeMeta:{},slug:"study1",filePath:"C:/Users/mi/Desktop/我的博客/docs/study/study1.md",filePathRelative:"study/study1.md",componentFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/study/study1.html.vue",componentFilePathRelative:"pages/study/study1.html.vue",componentFileChunkName:"v-7ffc659c",dataFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/study/study1.html.js",dataFilePathRelative:"pages/study/study1.html.js",dataFileChunkName:"v-7ffc659c",htmlFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/dist/study/study1.html",htmlFilePathRelative:"study/study1.html"},{data:{key:"v-7c92b45e",path:"/study/study2.html",title:"防抖和节流",lang:"zh-CN",frontmatter:{date:"2022/1/20 20:23",coverUrl:"https://www.toopic.cn/public/uploads/small/1634265816194163426581671.jpg",sticky:!0,keyword:"设置keyword,设置keyword,设置keyword,设置keyword",description:"什么是防抖和节流？有什么区别？如何实现？",title:"防抖和节流",tag:["面试题"],categories:["Javascript"]},excerpt:"",headers:[],git:{updatedTime:16427402e5,contributors:[{name:"iewgnafil",email:"1519467168@qq.com",commits:1}]}},key:"v-7c92b45e",path:"/study/study2.html",title:"防抖和节流",lang:"zh-CN",frontmatter:{date:"2022/1/20 20:23",coverUrl:"https://www.toopic.cn/public/uploads/small/1634265816194163426581671.jpg",sticky:!0,keyword:"设置keyword,设置keyword,设置keyword,设置keyword",description:"什么是防抖和节流？有什么区别？如何实现？",title:"防抖和节流",tag:["面试题"],categories:["Javascript"]},excerpt:"",headers:[],content:"\r\n1.  **防抖**\r\n\r\n> 触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间\r\n\r\n-   思路：\r\n\r\n> 每次触发事件时都取消之前的延时调用方法\r\n\r\n```js\r\nfunction debounce(fn,delay) {\r\n      let timeout = null; // 创建一个标记用来存放定时器的返回值\r\n      return function () {\r\n        clearTimeout(timeout); // 每当用户输入的时候把前一个 setTimeout clear 掉\r\n        timeout = setTimeout(() => { // 然后又创建一个新的 setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数\r\n          fn.apply(this, arguments);  //加了apply，此时this为debounce的\r\n        }, delay);     // delay为事件触发时间间隔\r\n      };\r\n    }\r\n```\r\n2.  **节流**\r\n\r\n> 高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率\r\n\r\n-   思路：\r\n\r\n> 每次触发事件时都判断与前一次执行是否间隔事件大于n秒\r\n\r\n```js\r\nfunction throttle(fn, delay){\r\n    let time = 0\r\n    return function(){\r\n        let now = Date.now();     // 每次点击都记录此时的时间戳\r\n        //console.log(now);\r\n        if(now - time >= delay){ //点击时的时间相比较前一次点击  至少要相差delay时间  否则不执行\r\n            fn.apply(this,arguments) //加了apply，此时this为throttle的 \r\n        }\r\n        time = Date.now()     // 触发事件之后，更新此时的时间，用于下一次的判断\r\n    }\r\n}\r\n```",contentRendered:'<ol>\n<li><strong>防抖</strong></li>\n</ol>\n<blockquote>\n<p>触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间</p>\n</blockquote>\n<ul>\n<li>思路：</li>\n</ul>\n<blockquote>\n<p>每次触发事件时都取消之前的延时调用方法</p>\n</blockquote>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span>delay</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">let</span> timeout <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 创建一个标记用来存放定时器的返回值</span>\n      <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 每当用户输入的时候把前一个 setTimeout clear 掉</span>\n        timeout <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span> <span class="token comment">// 然后又创建一个新的 setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数</span>\n          <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//加了apply，此时this为debounce的</span>\n        <span class="token punctuation">}</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// delay为事件触发时间间隔</span>\n      <span class="token punctuation">}</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><ol start="2">\n<li><strong>节流</strong></li>\n</ol>\n<blockquote>\n<p>高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率</p>\n</blockquote>\n<ul>\n<li>思路：</li>\n</ul>\n<blockquote>\n<p>每次触发事件时都判断与前一次执行是否间隔事件大于n秒</p>\n</blockquote>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> delay</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token keyword">let</span> time <span class="token operator">=</span> <span class="token number">0</span>\n    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token keyword">let</span> now <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 每次点击都记录此时的时间戳</span>\n        <span class="token comment">//console.log(now);</span>\n        <span class="token keyword">if</span><span class="token punctuation">(</span>now <span class="token operator">-</span> time <span class="token operator">>=</span> delay<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">//点击时的时间相比较前一次点击  至少要相差delay时间  否则不执行</span>\n            <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>arguments<span class="token punctuation">)</span> <span class="token comment">//加了apply，此时this为throttle的 </span>\n        <span class="token punctuation">}</span>\n        time <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token comment">// 触发事件之后，更新此时的时间，用于下一次的判断</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div>',date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:"/study/study2.html",pathLocale:"/",permalink:null,routeMeta:{},slug:"study2",filePath:"C:/Users/mi/Desktop/我的博客/docs/study/study2.md",filePathRelative:"study/study2.md",componentFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/study/study2.html.vue",componentFilePathRelative:"pages/study/study2.html.vue",componentFileChunkName:"v-7c92b45e",dataFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/study/study2.html.js",dataFilePathRelative:"pages/study/study2.html.js",dataFileChunkName:"v-7c92b45e",htmlFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/dist/study/study2.html",htmlFilePathRelative:"study/study2.html"},{data:{key:"v-79290320",path:"/study/study3.html",title:"输出什么",lang:"zh-CN",frontmatter:{date:"2022/1/20 20:23",coverUrl:"http://cdn-ali-img-shstaticbz.shanhutech.cn/bizhi/staticwp/202109/ac3990b3d19dd512dd6f6a364e70848a--1897315302.jpg",sticky:!0,keyword:"设置keyword,设置keyword,设置keyword,设置keyword",description:"输出什么",title:"输出什么",tag:["面试题"],categories:["Javascript"]},excerpt:"",headers:[{level:3,title:"map",slug:"map",children:[]},{level:3,title:"parseInt",slug:"parseint",children:[]},{level:3,title:"回到真实的事例上",slug:"回到真实的事例上",children:[]}],git:{updatedTime:16427402e5,contributors:[{name:"iewgnafil",email:"1519467168@qq.com",commits:1}]}},key:"v-79290320",path:"/study/study3.html",title:"输出什么",lang:"zh-CN",frontmatter:{date:"2022/1/20 20:23",coverUrl:"http://cdn-ali-img-shstaticbz.shanhutech.cn/bizhi/staticwp/202109/ac3990b3d19dd512dd6f6a364e70848a--1897315302.jpg",sticky:!0,keyword:"设置keyword,设置keyword,设置keyword,设置keyword",description:"输出什么",title:"输出什么",tag:["面试题"],categories:["Javascript"]},excerpt:"",headers:[{level:3,title:"map",slug:"map",children:[]},{level:3,title:"parseInt",slug:"parseint",children:[]},{level:3,title:"回到真实的事例上",slug:"回到真实的事例上",children:[]}],content:"\r\n### map\r\n`map()` 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。\r\n\r\n\r\n```js\r\nvar new_array = arr.map(function callback(currentValue[,index[, array]]) {\r\n // Return element for new_array\r\n }[, thisArg])\r\n```\r\n可以看到`callback`回调函数需要三个参数, 我们通常只使用第一个参数 (其他两个参数是可选的)。\\\r\n`currentValue` 是callback 数组中正在处理的当前元素。\\\r\n`index`可选, 是callback 数组中正在处理的当前元素的索引。\\\r\n`array`可选, 是callback map 方法被调用的数组。\\\r\n另外还有`thisArg`可选, 执行 callback 函数时使用的this 值。\r\n\r\n```js\r\nconst arr = [1, 2, 3];\r\narr.map((num) => num + 1); // [2, 3, 4]\r\n```\r\n### parseInt\r\n`parseInt()` 函数解析一个字符串参数，并返回一个指定基数的整数 (数学系统的基础)。\r\n\r\n```js\r\nconst intValue = parseInt(string[, radix]);\r\n```\r\n`string` 要被解析的值。如果参数不是一个字符串，则将其转换为字符串(使用 ToString 抽象操作)。字符串开头的空白符将会被忽略。\r\n\r\n`radix` 一个介于2和36之间的整数(数学系统的基础)，表示上述字符串的基数。默认为10。\\\r\n`返回值` 返回一个整数或NaN\r\n\r\n```js\r\nparseInt(100); // 100\r\nparseInt(100, 10); // 100\r\nparseInt(100, 2); // 4 -> 将100视为2进制下的显示  则为4\r\n```\r\n\r\n### 回到真实的事例上\r\n\r\n回到我们真实的事例上\r\n\r\n```js\r\n['1', '2', '3'].map(parseInt)\r\n```\r\n对于每个迭代`map`, `parseInt()`传递两个参数: **字符串和基数**。\\\r\n所以实际执行的的代码是：\r\n\r\n```js\r\n['1', '2', '3'].map((item, index) => {\r\n\treturn parseInt(item, index)\r\n})\r\n```\r\n即返回的值分别为：\r\n\r\n```js\r\nparseInt('1', 0) // 1\r\nparseInt('2', 1) // NaN\r\nparseInt('3', 2) // NaN, 3 不是二进制\r\n```\r\n所以：\r\n\r\n```js\r\n['1', '2', '3'].map(parseInt)\r\n// 1, NaN, NaN\r\n```",contentRendered:'<h3 id="map" tabindex="-1"><a class="header-anchor" href="#map" aria-hidden="true">#</a> map</h3>\n<p><code>map()</code> 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">var</span> new_array <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token parameter">currentValue<span class="token punctuation">[</span><span class="token punctuation">,</span>index<span class="token punctuation">[</span><span class="token punctuation">,</span> array<span class="token punctuation">]</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n <span class="token comment">// Return element for new_array</span>\n <span class="token punctuation">}</span><span class="token punctuation">[</span><span class="token punctuation">,</span> thisArg<span class="token punctuation">]</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>可以看到<code>callback</code>回调函数需要三个参数, 我们通常只使用第一个参数 (其他两个参数是可选的)。<br>\n<code>currentValue</code> 是callback 数组中正在处理的当前元素。<br>\n<code>index</code>可选, 是callback 数组中正在处理的当前元素的索引。<br>\n<code>array</code>可选, 是callback map 方法被调用的数组。<br>\n另外还有<code>thisArg</code>可选, 执行 callback 函数时使用的this 值。</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\narr<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">num</span><span class="token punctuation">)</span> <span class="token operator">=></span> num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [2, 3, 4]</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="parseint" tabindex="-1"><a class="header-anchor" href="#parseint" aria-hidden="true">#</a> parseInt</h3>\n<p><code>parseInt()</code> 函数解析一个字符串参数，并返回一个指定基数的整数 (数学系统的基础)。</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">const</span> intValue <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>string<span class="token punctuation">[</span><span class="token punctuation">,</span> radix<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p><code>string</code> 要被解析的值。如果参数不是一个字符串，则将其转换为字符串(使用 ToString 抽象操作)。字符串开头的空白符将会被忽略。</p>\n<p><code>radix</code> 一个介于2和36之间的整数(数学系统的基础)，表示上述字符串的基数。默认为10。<br>\n<code>返回值</code> 返回一个整数或NaN</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 100</span>\n<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 100</span>\n<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 4 -> 将100视为2进制下的显示  则为4</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="回到真实的事例上" tabindex="-1"><a class="header-anchor" href="#回到真实的事例上" aria-hidden="true">#</a> 回到真实的事例上</h3>\n<p>回到我们真实的事例上</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token punctuation">[</span><span class="token string">\'1\'</span><span class="token punctuation">,</span> <span class="token string">\'2\'</span><span class="token punctuation">,</span> <span class="token string">\'3\'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>parseInt<span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>对于每个迭代<code>map</code>, <code>parseInt()</code>传递两个参数: <strong>字符串和基数</strong>。<br>\n所以实际执行的的代码是：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token punctuation">[</span><span class="token string">\'1\'</span><span class="token punctuation">,</span> <span class="token string">\'2\'</span><span class="token punctuation">,</span> <span class="token string">\'3\'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n\t<span class="token keyword">return</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> index<span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>即返回的值分别为：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">\'1\'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// 1</span>\n<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">\'2\'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// NaN</span>\n<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">\'3\'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// NaN, 3 不是二进制</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>所以：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token punctuation">[</span><span class="token string">\'1\'</span><span class="token punctuation">,</span> <span class="token string">\'2\'</span><span class="token punctuation">,</span> <span class="token string">\'3\'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>parseInt<span class="token punctuation">)</span>\n<span class="token comment">// 1, NaN, NaN</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div>',date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:"/study/study3.html",pathLocale:"/",permalink:null,routeMeta:{},slug:"study3",filePath:"C:/Users/mi/Desktop/我的博客/docs/study/study3.md",filePathRelative:"study/study3.md",componentFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/study/study3.html.vue",componentFilePathRelative:"pages/study/study3.html.vue",componentFileChunkName:"v-79290320",dataFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/study/study3.html.js",dataFilePathRelative:"pages/study/study3.html.js",dataFileChunkName:"v-79290320",htmlFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/dist/study/study3.html",htmlFilePathRelative:"study/study3.html"},{data:{key:"v-75bf51e2",path:"/study/study4.html",title:"跨域",lang:"zh-CN",frontmatter:{date:"2022/1/21 20:23",coverUrl:"http://cdn-ali-img-shstaticbz.shanhutech.cn/bizhi/staticwp/202201/ec75de816ec1a1e965b9604a936e5c3e--333631415.jpg",sticky:!0,keyword:"跨域,jsonp,cros,postMessage",description:"跨域",title:"跨域",tag:["跨域","面试题"],categories:["跨域"]},excerpt:"",headers:[{level:2,title:"常见的跨域场景",slug:"常见的跨域场景",children:[]},{level:2,title:"特别说明",slug:"特别说明",children:[]},{level:2,title:"跨域的解决方案",slug:"跨域的解决方案",children:[{level:3,title:"1. jsonp",slug:"_1-jsonp",children:[]},{level:3,title:"2. cors",slug:"_2-cors",children:[]},{level:3,title:"3. postMessage",slug:"_3-postmessage",children:[]}]}],git:{updatedTime:1642771259e3,contributors:[{name:"iewgnafil",email:"1519467168@qq.com",commits:2}]}},key:"v-75bf51e2",path:"/study/study4.html",title:"跨域",lang:"zh-CN",frontmatter:{date:"2022/1/21 20:23",coverUrl:"http://cdn-ali-img-shstaticbz.shanhutech.cn/bizhi/staticwp/202201/ec75de816ec1a1e965b9604a936e5c3e--333631415.jpg",sticky:!0,keyword:"跨域,jsonp,cros,postMessage",description:"跨域",title:"跨域",tag:["跨域","面试题"],categories:["跨域"]},excerpt:"",headers:[{level:2,title:"常见的跨域场景",slug:"常见的跨域场景",children:[]},{level:2,title:"特别说明",slug:"特别说明",children:[]},{level:2,title:"跨域的解决方案",slug:"跨域的解决方案",children:[{level:3,title:"1. jsonp",slug:"_1-jsonp",children:[]},{level:3,title:"2. cors",slug:"_2-cors",children:[]},{level:3,title:"3. postMessage",slug:"_3-postmessage",children:[]}]}],content:'\r\n# 什么是跨域\r\n浏览器都具有同源策略  --- 协议 + 域名 + 端口  都相同\r\n\r\nhttp://   www   .    abc.com  :    8080   /    detail   \\\r\n 协议    子域名       主域名        端口        请求资源地址\r\n\r\n\r\n - 同源策略限制了ajax请求\r\n\r\n - 没有被同源策略所影响的三个标签\r\n ```js\r\n   <img src="xxx> \r\n   <link href="xxx>\r\n   <script src="xxx">\r\n```\r\n   \r\n\r\n## 常见的跨域场景\r\nhttp://www.a.com/a.js   \\\r\nhttp://www.a.com/b.js      同一个域名，允许通信\r\n\r\n\r\nhttp://www.a.com/a.js     \\\r\nhttps://www.a.com/a.js     协议不同，跨域\r\n\r\n\r\nhttp://www.a.com/a.js      \\\r\nhttp://script.a.com/a.js\t 主域相同，子域不相同，跨域\r\n\r\n\r\n## 特别说明\r\n1. 如果是端口和协议照成的跨域，前端是没有办法解决的\r\n2. 跨域仅仅只是根据url的首部 来识别，不会根据这个首部对应得ip地址来判断\r\n3. 跨域并不是请求没有发出去，请求时能发出去得，服务器也是能响应的，只是响应结果被浏览器拦截了\r\n\r\n\r\n## 跨域的解决方案\r\n### 1. jsonp\r\n  原理：**利用script标签上的src属性不会被同源的策略所拦截的这一机制**，将我们要请求的url地址，添加到script的src属性中，且携带上前端全局下的函数名作为参数给到后端，后端获取到前端传递的函数名，然后返回该函数的调用语法，将要返回的数据放在该函数的调用中作为参数，当浏览器接收到全局下的函数被调用的后端响应，会自动执行该函数，从而从参数中获取到后端返回的数据\r\n\r\n  缺点：\r\n  1. 需要对方的服务器做支持才可以\r\n  2. 只支持**get** 请求，有局限性，可能会遭到 **XSS攻击**\r\n\r\n\r\n### 2. cors\r\n  cors是W3C的标准，它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求。也就是说浏览器发请求是不会被跨域的，跨域的核心是后端响应不了。\r\n\r\n  >要让后端响应内容能够补被浏览器拦截，关键在于后端。如果后端也能遵从CorS标准的话，后端的响应也可以跨源.\r\n\r\n分为简单请求和复杂请求两种：\r\n  - 简单请求\\\r\n    . 使用GET、POST、HEAD \\\r\n    . Content-Type的值仅限于:**text/plain || multipart/from-data || application/x-www-from-urlencoded**\r\n\r\n  - 复杂请求\\\r\n    .  不满足简单请求的条件的就是复杂请求\\\r\n    .  复杂请求的cors请求，会在正式通信之前，增加一次http查询请求，称为"预检"，预检是用来知道服务端是都允许跨域请求，预检请求发的是options方法\r\n\r\n### 3. postMessage\r\n  html5中的 xhr 提供的API，postMessage()方法允许来自不同源的脚本采用异步的方法进行有限通信，可以实现跨文本，多窗口，跨域消息传递 \\\r\n  可以解决这么几个问题：\r\n  - 页面和其他新的窗口的数据传递\r\n  - 多窗口之间的消息传递\r\n  - 页面与嵌套的iframe消息传递\r\n  - 上面三个场景的跨域数据传递\r\n\r\n\r\n  otherWindow.postMessage(message, targrtOrigin, [transfer])\r\n  - message: 要发送给其他window的数据\r\n  - targetOrigin: 目标窗口\r\n  - transfer(可选)和message一起传递的一个对象，这个对象的所有权限将移交给消息接收方\r\n\r\n  缺点: **场景比较简单**\r\n\r\n\r\n  [参考链接](https://juejin.cn/post/6992525007716876325#heading-59)',contentRendered:'<h1 id="什么是跨域" tabindex="-1"><a class="header-anchor" href="#什么是跨域" aria-hidden="true">#</a> 什么是跨域</h1>\n<p>浏览器都具有同源策略  --- 协议 + 域名 + 端口  都相同</p>\n<p>http://   www   .    abc.com  :    8080   /    detail   <br>\n协议    子域名       主域名        端口        请求资源地址</p>\n<ul>\n<li>\n<p>同源策略限制了ajax请求</p>\n</li>\n<li>\n<p>没有被同源策略所影响的三个标签</p>\n</li>\n</ul>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code>  <span class="token operator">&lt;</span>img src<span class="token operator">=</span>"xxx<span class="token operator">></span> \n  <span class="token operator">&lt;</span>link href<span class="token operator">=</span>"xxx<span class="token operator">></span>\n  <span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"xxx"</span><span class="token operator">></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="常见的跨域场景" tabindex="-1"><a class="header-anchor" href="#常见的跨域场景" aria-hidden="true">#</a> 常见的跨域场景</h2>\n<p>http://www.a.com/a.js   <br>\nhttp://www.a.com/b.js      同一个域名，允许通信</p>\n<p>http://www.a.com/a.js     <br>\nhttps://www.a.com/a.js     协议不同，跨域</p>\n<p>http://www.a.com/a.js      <br>\nhttp://script.a.com/a.js\t 主域相同，子域不相同，跨域</p>\n<h2 id="特别说明" tabindex="-1"><a class="header-anchor" href="#特别说明" aria-hidden="true">#</a> 特别说明</h2>\n<ol>\n<li>如果是端口和协议照成的跨域，前端是没有办法解决的</li>\n<li>跨域仅仅只是根据url的首部 来识别，不会根据这个首部对应得ip地址来判断</li>\n<li>跨域并不是请求没有发出去，请求时能发出去得，服务器也是能响应的，只是响应结果被浏览器拦截了</li>\n</ol>\n<h2 id="跨域的解决方案" tabindex="-1"><a class="header-anchor" href="#跨域的解决方案" aria-hidden="true">#</a> 跨域的解决方案</h2>\n<h3 id="_1-jsonp" tabindex="-1"><a class="header-anchor" href="#_1-jsonp" aria-hidden="true">#</a> 1. jsonp</h3>\n<p>原理：<strong>利用script标签上的src属性不会被同源的策略所拦截的这一机制</strong>，将我们要请求的url地址，添加到script的src属性中，且携带上前端全局下的函数名作为参数给到后端，后端获取到前端传递的函数名，然后返回该函数的调用语法，将要返回的数据放在该函数的调用中作为参数，当浏览器接收到全局下的函数被调用的后端响应，会自动执行该函数，从而从参数中获取到后端返回的数据</p>\n<p>缺点：</p>\n<ol>\n<li>需要对方的服务器做支持才可以</li>\n<li>只支持<strong>get</strong> 请求，有局限性，可能会遭到 <strong>XSS攻击</strong></li>\n</ol>\n<h3 id="_2-cors" tabindex="-1"><a class="header-anchor" href="#_2-cors" aria-hidden="true">#</a> 2. cors</h3>\n<p>cors是W3C的标准，它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求。也就是说浏览器发请求是不会被跨域的，跨域的核心是后端响应不了。</p>\n<blockquote>\n<p>要让后端响应内容能够补被浏览器拦截，关键在于后端。如果后端也能遵从CorS标准的话，后端的响应也可以跨源.</p>\n</blockquote>\n<p>分为简单请求和复杂请求两种：</p>\n<ul>\n<li>\n<p>简单请求<br>\n. 使用GET、POST、HEAD <br>\n. Content-Type的值仅限于:<strong>text/plain || multipart/from-data || application/x-www-from-urlencoded</strong></p>\n</li>\n<li>\n<p>复杂请求<br>\n.  不满足简单请求的条件的就是复杂请求<br>\n.  复杂请求的cors请求，会在正式通信之前，增加一次http查询请求，称为&quot;预检&quot;，预检是用来知道服务端是都允许跨域请求，预检请求发的是options方法</p>\n</li>\n</ul>\n<h3 id="_3-postmessage" tabindex="-1"><a class="header-anchor" href="#_3-postmessage" aria-hidden="true">#</a> 3. postMessage</h3>\n<p>html5中的 xhr 提供的API，postMessage()方法允许来自不同源的脚本采用异步的方法进行有限通信，可以实现跨文本，多窗口，跨域消息传递 <br>\n可以解决这么几个问题：</p>\n<ul>\n<li>页面和其他新的窗口的数据传递</li>\n<li>多窗口之间的消息传递</li>\n<li>页面与嵌套的iframe消息传递</li>\n<li>上面三个场景的跨域数据传递</li>\n</ul>\n<p>otherWindow.postMessage(message, targrtOrigin, [transfer])</p>\n<ul>\n<li>message: 要发送给其他window的数据</li>\n<li>targetOrigin: 目标窗口</li>\n<li>transfer(可选)和message一起传递的一个对象，这个对象的所有权限将移交给消息接收方</li>\n</ul>\n<p>缺点: <strong>场景比较简单</strong></p>\n<p><a href="https://juejin.cn/post/6992525007716876325#heading-59" target="_blank" rel="noopener noreferrer">参考链接<ExternalLinkIcon/></a></p>\n',date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:"/study/study4.html",pathLocale:"/",permalink:null,routeMeta:{},slug:"study4",filePath:"C:/Users/mi/Desktop/我的博客/docs/study/study4.md",filePathRelative:"study/study4.md",componentFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/study/study4.html.vue",componentFilePathRelative:"pages/study/study4.html.vue",componentFileChunkName:"v-75bf51e2",dataFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/study/study4.html.js",dataFilePathRelative:"pages/study/study4.html.js",dataFileChunkName:"v-75bf51e2",htmlFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/dist/study/study4.html",htmlFilePathRelative:"study/study4.html"},{data:{key:"v-3706649a",path:"/404.html",title:"",lang:"zh-CN",frontmatter:{layout:"404"},excerpt:"",headers:[],git:{}},key:"v-3706649a",path:"/404.html",title:"",lang:"zh-CN",frontmatter:{layout:"404"},excerpt:"",headers:[],content:"",contentRendered:"",date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:null,pathLocale:"/",permalink:null,routeMeta:{},slug:"",filePath:null,filePathRelative:null,componentFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/404.html.vue",componentFilePathRelative:"pages/404.html.vue",componentFileChunkName:"v-3706649a",dataFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/404.html.js",dataFilePathRelative:"pages/404.html.js",dataFileChunkName:"v-3706649a",htmlFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/dist/404.html",htmlFilePathRelative:"404.html"},{data:{key:"v-8daa1a0e",path:"/",title:"",lang:"zh-CN",frontmatter:{layout:"Layout",home:!0},excerpt:"",headers:[],git:{}},key:"v-8daa1a0e",path:"/",title:"",lang:"zh-CN",frontmatter:{layout:"Layout",home:!0},excerpt:"",headers:[],content:"",contentRendered:"",date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:null,pathLocale:"/",permalink:null,routeMeta:{},slug:"",filePath:null,filePathRelative:null,componentFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/index.html.vue",componentFilePathRelative:"pages/index.html.vue",componentFileChunkName:"v-8daa1a0e",dataFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/index.html.js",dataFilePathRelative:"pages/index.html.js",dataFileChunkName:"v-8daa1a0e",htmlFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/dist/index.html",htmlFilePathRelative:"index.html"},{data:{key:"v-74bc627b",path:"/about/",title:"",lang:"zh-CN",frontmatter:{layout:"About",slug:"aurora-about"},excerpt:"",headers:[],git:{}},key:"v-74bc627b",path:"/about/",title:"",lang:"zh-CN",frontmatter:{layout:"About",slug:"aurora-about"},excerpt:"",headers:[],content:"",contentRendered:"",date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:null,pathLocale:"/",permalink:null,routeMeta:{},slug:"",filePath:null,filePathRelative:null,componentFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/about/index.html.vue",componentFilePathRelative:"pages/about/index.html.vue",componentFileChunkName:"v-74bc627b",dataFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/about/index.html.js",dataFilePathRelative:"pages/about/index.html.js",dataFileChunkName:"v-74bc627b",htmlFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/dist/about/index.html",htmlFilePathRelative:"about/index.html"},{data:{key:"v-14f724bf",path:"/mood/",title:"",lang:"zh-CN",frontmatter:{layout:"Mood",slug:"aurora-mood"},excerpt:"",headers:[],git:{}},key:"v-14f724bf",path:"/mood/",title:"",lang:"zh-CN",frontmatter:{layout:"Mood",slug:"aurora-mood"},excerpt:"",headers:[],content:"",contentRendered:"",date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:null,pathLocale:"/",permalink:null,routeMeta:{},slug:"",filePath:null,filePathRelative:null,componentFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/mood/index.html.vue",componentFilePathRelative:"pages/mood/index.html.vue",componentFileChunkName:"v-14f724bf",dataFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/mood/index.html.js",dataFilePathRelative:"pages/mood/index.html.js",dataFileChunkName:"v-14f724bf",htmlFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/dist/mood/index.html",htmlFilePathRelative:"mood/index.html"},{data:{key:"v-14e6501c",path:"/link/",title:"",lang:"zh-CN",frontmatter:{layout:"Link",slug:"aurora-link"},excerpt:"",headers:[],git:{}},key:"v-14e6501c",path:"/link/",title:"",lang:"zh-CN",frontmatter:{layout:"Link",slug:"aurora-link"},excerpt:"",headers:[],content:"",contentRendered:"",date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:null,pathLocale:"/",permalink:null,routeMeta:{},slug:"",filePath:null,filePathRelative:null,componentFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/link/index.html.vue",componentFilePathRelative:"pages/link/index.html.vue",componentFileChunkName:"v-14e6501c",dataFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/link/index.html.js",dataFilePathRelative:"pages/link/index.html.js",dataFileChunkName:"v-14e6501c",htmlFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/dist/link/index.html",htmlFilePathRelative:"link/index.html"},{data:{key:"v-744d024e",path:"/tag/",title:"",lang:"zh-CN",frontmatter:{layout:"Tag",slug:"aurora-tag"},excerpt:"",headers:[],git:{}},key:"v-744d024e",path:"/tag/",title:"",lang:"zh-CN",frontmatter:{layout:"Tag",slug:"aurora-tag"},excerpt:"",headers:[],content:"",contentRendered:"",date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:null,pathLocale:"/",permalink:null,routeMeta:{},slug:"",filePath:null,filePathRelative:null,componentFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/tag/index.html.vue",componentFilePathRelative:"pages/tag/index.html.vue",componentFileChunkName:"v-744d024e",dataFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/tag/index.html.js",dataFilePathRelative:"pages/tag/index.html.js",dataFileChunkName:"v-744d024e",htmlFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/dist/tag/index.html",htmlFilePathRelative:"tag/index.html"},{data:{key:"v-705c21a6",path:"/archive/",title:"",lang:"zh-CN",frontmatter:{layout:"Archive",slug:"aurora-archive"},excerpt:"",headers:[],git:{}},key:"v-705c21a6",path:"/archive/",title:"",lang:"zh-CN",frontmatter:{layout:"Archive",slug:"aurora-archive"},excerpt:"",headers:[],content:"",contentRendered:"",date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:null,pathLocale:"/",permalink:null,routeMeta:{},slug:"",filePath:null,filePathRelative:null,componentFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/archive/index.html.vue",componentFilePathRelative:"pages/archive/index.html.vue",componentFileChunkName:"v-705c21a6",dataFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/archive/index.html.js",dataFilePathRelative:"pages/archive/index.html.js",dataFileChunkName:"v-705c21a6",htmlFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/dist/archive/index.html",htmlFilePathRelative:"archive/index.html"},{data:{key:"v-6629f178",path:"/aurora-coze/",title:"",lang:"zh-CN",frontmatter:{layout:"CozeMood",slug:"aurora-coze-mood"},excerpt:"",headers:[],git:{}},key:"v-6629f178",path:"/aurora-coze/",title:"",lang:"zh-CN",frontmatter:{layout:"CozeMood",slug:"aurora-coze-mood"},excerpt:"",headers:[],content:"",contentRendered:"",date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:null,pathLocale:"/",permalink:null,routeMeta:{},slug:"",filePath:null,filePathRelative:null,componentFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/aurora-coze/index.html.vue",componentFilePathRelative:"pages/aurora-coze/index.html.vue",componentFileChunkName:"v-6629f178",dataFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/aurora-coze/index.html.js",dataFilePathRelative:"pages/aurora-coze/index.html.js",dataFileChunkName:"v-6629f178",htmlFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/dist/aurora-coze/index.html",htmlFilePathRelative:"aurora-coze/index.html"},{data:{key:"v-f693f690",path:"/aurora-register/",title:"",lang:"zh-CN",frontmatter:{layout:"RegisterUser",slug:"aurora-coze-register"},excerpt:"",headers:[],git:{}},key:"v-f693f690",path:"/aurora-register/",title:"",lang:"zh-CN",frontmatter:{layout:"RegisterUser",slug:"aurora-coze-register"},excerpt:"",headers:[],content:"",contentRendered:"",date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:null,pathLocale:"/",permalink:null,routeMeta:{},slug:"",filePath:null,filePathRelative:null,componentFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/aurora-register/index.html.vue",componentFilePathRelative:"pages/aurora-register/index.html.vue",componentFileChunkName:"v-f693f690",dataFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/aurora-register/index.html.js",dataFilePathRelative:"pages/aurora-register/index.html.js",dataFileChunkName:"v-f693f690",htmlFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/dist/aurora-register/index.html",htmlFilePathRelative:"aurora-register/index.html"},{data:{key:"v-e2acc714",path:"/photo/",title:"",lang:"zh-CN",frontmatter:{layout:"CozePhoto",slug:"aurora-photo"},excerpt:"",headers:[],git:{}},key:"v-e2acc714",path:"/photo/",title:"",lang:"zh-CN",frontmatter:{layout:"CozePhoto",slug:"aurora-photo"},excerpt:"",headers:[],content:"",contentRendered:"",date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:null,pathLocale:"/",permalink:null,routeMeta:{},slug:"",filePath:null,filePathRelative:null,componentFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/photo/index.html.vue",componentFilePathRelative:"pages/photo/index.html.vue",componentFileChunkName:"v-e2acc714",dataFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/photo/index.html.js",dataFilePathRelative:"pages/photo/index.html.js",dataFileChunkName:"v-e2acc714",htmlFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/dist/photo/index.html",htmlFilePathRelative:"photo/index.html"},{data:{key:"v-3c506944",path:"/aurora-music/",title:"",lang:"zh-CN",frontmatter:{layout:"AuroraMusic",slug:"aurora-plugin-music"},excerpt:"",headers:[],git:{}},key:"v-3c506944",path:"/aurora-music/",title:"",lang:"zh-CN",frontmatter:{layout:"AuroraMusic",slug:"aurora-plugin-music"},excerpt:"",headers:[],content:"",contentRendered:"",date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:null,pathLocale:"/",permalink:null,routeMeta:{},slug:"",filePath:null,filePathRelative:null,componentFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/aurora-music/index.html.vue",componentFilePathRelative:"pages/aurora-music/index.html.vue",componentFileChunkName:"v-3c506944",dataFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/aurora-music/index.html.js",dataFilePathRelative:"pages/aurora-music/index.html.js",dataFileChunkName:"v-3c506944",htmlFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/dist/aurora-music/index.html",htmlFilePathRelative:"aurora-music/index.html"},{data:{key:"v-3279cf61",path:"/aurora-archive/",title:"",lang:"zh-CN",frontmatter:{layout:"AuroraArchive",slug:"aurora-plugin-archive"},excerpt:"",headers:[],git:{}},key:"v-3279cf61",path:"/aurora-archive/",title:"",lang:"zh-CN",frontmatter:{layout:"AuroraArchive",slug:"aurora-plugin-archive"},excerpt:"",headers:[],content:"",contentRendered:"",date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:null,pathLocale:"/",permalink:null,routeMeta:{},slug:"",filePath:null,filePathRelative:null,componentFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/aurora-archive/index.html.vue",componentFilePathRelative:"pages/aurora-archive/index.html.vue",componentFileChunkName:"v-3279cf61",dataFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/.temp/pages/aurora-archive/index.html.js",dataFilePathRelative:"pages/aurora-archive/index.html.js",dataFileChunkName:"v-3279cf61",htmlFilePath:"C:/Users/mi/Desktop/我的博客/docs/.vuepress/dist/aurora-archive/index.html",htmlFilePathRelative:"aurora-archive/index.html"}]}},n=>{n.O(0,[954,590],(()=>(5698,n(n.s=5698)))),n.O()}]);